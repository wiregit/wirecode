diff --git a/.classpath b/.classpath
index 70ab788..faf6b68 100755
--- a/.classpath
+++ b/.classpath
@@ -137,7 +137,7 @@
 	<classpathentry kind="src" output="components/swarm/build/classes" path="components/swarm/src/main/java"/>
 	<classpathentry kind="src" output="components/swarm/build/tests" path="components/swarm/src/test/java"/>
 	<classpathentry kind="src" path="components/swarm/src/test/resources"/>
-	<classpathentry kind="lib" path="lib/jars/httpclient-4.0-beta1.jar" sourcepath="lib/sources/httpclient-4.0-beta1.zip"/>
+	<classpathentry kind="lib" path="lib/jars/httpclient-4.0-beta1.jar" sourcepath="lib/sources/httpclient-4.0-beta1-src.zip"/>
 	<classpathentry kind="lib" path="lib/jars/httpcore-4.0-beta2.jar" sourcepath="lib/sources/httpcore-4.0.beta2-src.zip"/>
 	<classpathentry kind="lib" path="lib/jars/httpcore-nio-4.0-beta2.jar" sourcepath="lib/sources/httpcore-nio-4.0-beta2-src.zip"/>
 	<classpathentry kind="lib" path="lib/jars/swing-worker-1.1.jar"/>
diff --git a/components/common/src/main/java/org/limewire/util/StringUtils.java b/components/common/src/main/java/org/limewire/util/StringUtils.java
new file mode 100644
index 0000000..d752bbc
--- a/components/core-api/src/main/java/org/limewire/core/api/browse/BrowseFactory.java
+++ b/components/core-api/src/main/java/org/limewire/core/api/browse/BrowseFactory.java
@@ -1,7 +1,7 @@
 package org.limewire.core.api.browse;
 
-import org.limewire.io.Address;
+import org.limewire.core.api.friend.FriendPresence;
 
 public interface BrowseFactory {
-    Browse createBrowse(Address address);
+    Browse createBrowse(FriendPresence friendPresence);
 }
diff --git a/components/core-api/src/main/java/org/limewire/core/api/download/ResultDownloader.java b/components/core-api/src/main/java/org/limewire/core/api/download/ResultDownloader.java
index 1c47aa2..cb9af02 100644
--- a/components/core-api/src/main/java/org/limewire/core/api/download/ResultDownloader.java
+++ b/components/core-api/src/main/java/org/limewire/core/api/download/ResultDownloader.java
@@ -1,14 +1,14 @@
 package org.limewire.core.api.download;
 
-import java.util.List;
 import java.io.IOException;
+import java.util.List;
 
+import org.limewire.core.api.friend.FriendPresence;
 import org.limewire.core.api.library.RemoteFileItem;
 import org.limewire.core.api.search.Search;
 import org.limewire.core.api.search.SearchResult;
 import org.limewire.io.InvalidDataException;
 import org.limewire.xmpp.api.client.FileMetaData;
-import org.limewire.xmpp.api.client.LimePresence;
 
 public interface ResultDownloader {
 
@@ -36,7 +36,7 @@ public interface ResultDownloader {
      *         saving the file
      * @throws InvalidDataException if the FileMetaData is malformed
      */
-    public DownloadItem addDownload(LimePresence presence, FileMetaData chatFileDesc)
+    public DownloadItem addDownload(FriendPresence presence, FileMetaData chatFileDesc)
             throws SaveLocationException, InvalidDataException;
 
     /**
--- a/components/core-glue/src/main/java/org/limewire/core/impl/browse/CoreBrowse.java
+++ b/components/core-glue/src/main/java/org/limewire/core/impl/browse/CoreBrowse.java
@@ -5,10 +5,10 @@ import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.limewire.core.api.browse.Browse;
 import org.limewire.core.api.browse.BrowseListener;
+import org.limewire.core.api.friend.FriendPresence;
 import org.limewire.core.impl.search.QueryReplyListener;
 import org.limewire.core.impl.search.QueryReplyListenerList;
 import org.limewire.core.impl.search.RemoteFileDescAdapter;
-import org.limewire.io.Address;
 import org.limewire.io.IpPort;
 import org.limewire.util.Objects;
 
@@ -22,16 +22,16 @@ import com.limegroup.gnutella.messages.QueryReply;
 public class CoreBrowse implements Browse {    
     
     private final SearchServices searchServices;
-    private final Address addr;
+    private final FriendPresence friendPresence;
     private final QueryReplyListenerList listenerList;
     private final AtomicBoolean started = new AtomicBoolean(false);
     private volatile byte[] browseGuid;
     private volatile QueryReplyListener listener;
 
     @AssistedInject
-    public CoreBrowse(@Assisted Address address, SearchServices searchServices,
+    public CoreBrowse(@Assisted FriendPresence friendPresence, SearchServices searchServices,
             QueryReplyListenerList listenerList) {
-        this.addr = Objects.nonNull(address, "address");
+        this.friendPresence = Objects.nonNull(friendPresence, "friendPresence");
         this.searchServices = searchServices;
         this.listenerList = listenerList;
     }
@@ -46,7 +46,7 @@ public class CoreBrowse implements Browse {
         listener = new BrowseResultAdapter(browseListener);
         listenerList.addQueryReplyListener(browseGuid, listener);
         
-        searchServices.doAsynchronousBrowseHost(addr, new GUID(browseGuid), browseListener);
+        searchServices.doAsynchronousBrowseHost(friendPresence, new GUID(browseGuid), browseListener);
     }
 
     @Override
diff --git a/components/core-glue/src/main/java/org/limewire/core/impl/download/CoreDownloadItem.java b/components/core-glue/src/main/java/org/limewire/core/impl/download/CoreDownloadItem.java
new file mode 100644
index 0000000..406a34c
--- a/components/core-glue/src/main/java/org/limewire/core/impl/download/CoreDownloadListManager.java
+++ b/components/core-glue/src/main/java/org/limewire/core/impl/download/CoreDownloadListManager.java
@@ -16,6 +16,7 @@ import org.limewire.core.api.download.DownloadListManager;
 import org.limewire.core.api.download.DownloadListener;
 import org.limewire.core.api.download.DownloadState;
 import org.limewire.core.api.download.SaveLocationException;
+import org.limewire.core.api.friend.FriendPresence;
 import org.limewire.core.api.library.RemoteFileItem;
 import org.limewire.core.api.search.Search;
 import org.limewire.core.api.search.SearchResult;
@@ -33,12 +34,6 @@ import org.limewire.setting.FileSetting;
 import org.limewire.util.FileUtils;
 import org.limewire.util.MediaType;
 import org.limewire.xmpp.api.client.FileMetaData;
-import org.limewire.xmpp.api.client.LimePresence;
-
-import ca.odell.glazedlists.BasicEventList;
-import ca.odell.glazedlists.EventList;
-import ca.odell.glazedlists.GlazedLists;
-import ca.odell.glazedlists.ObservableElementList;
 
 import com.google.inject.Inject;
 import com.google.inject.Singleton;
@@ -51,6 +46,11 @@ import com.limegroup.gnutella.URN;
 import com.limegroup.gnutella.downloader.RemoteFileDescFactory;
 import com.limegroup.gnutella.net.address.FirewalledAddress;
 
+import ca.odell.glazedlists.BasicEventList;
+import ca.odell.glazedlists.EventList;
+import ca.odell.glazedlists.GlazedLists;
+import ca.odell.glazedlists.ObservableElementList;
+
 
 @Singleton
 public class CoreDownloadListManager implements DownloadListManager {
@@ -154,7 +154,7 @@ public class CoreDownloadListManager implements DownloadListManager {
     }
     
     @Override
-    public DownloadItem addDownload(LimePresence presence, FileMetaData fileMeta)
+    public DownloadItem addDownload(FriendPresence presence, FileMetaData fileMeta)
             throws SaveLocationException, InvalidDataException {
         Category category = MediaTypeConverter.toCategory(
                 MediaType.getMediaTypeForExtension(
@@ -165,7 +165,7 @@ public class CoreDownloadListManager implements DownloadListManager {
                 null, null, null, false, category);
     }
 
-    private RemoteFileDesc createRfdFromChatResult(LimePresence presence, FileMetaData fileMeta)
+    private RemoteFileDesc createRfdFromChatResult(FriendPresence presence, FileMetaData fileMeta)
             throws SaveLocationException, InvalidDataException {
         Connectable publicAddress;
         Address address = presence.getPresenceAddress();
diff --git a/components/core-glue/src/main/java/org/limewire/core/impl/library/CoreGlueLibraryModule.java b/components/core-glue/src/main/java/org/limewire/core/impl/library/CoreGlueLibraryModule.java
new file mode 100755
index 0000000..689990a
--- a/components/core-glue/src/main/java/org/limewire/core/impl/library/PresenceLibraryBrowser.java
+++ b/components/core-glue/src/main/java/org/limewire/core/impl/library/PresenceLibraryBrowser.java
@@ -10,7 +10,6 @@ import org.limewire.core.api.library.RemoteFileItem;
 import org.limewire.core.api.library.RemoteLibraryManager;
 import org.limewire.core.api.search.SearchResult;
 import org.limewire.core.impl.search.RemoteFileDescAdapter;
-import org.limewire.io.Address;
 import org.limewire.listener.ListenerSupport;
 import org.limewire.listener.EventListener;
 import org.limewire.logging.Log;
@@ -72,10 +71,9 @@ class PresenceLibraryBrowser implements EventListener<LibraryChangedEvent> {
     }
 
     private void browse(final PresenceLibrary presenceLibrary, final FriendPresence friendPresence) {
-        Address address = friendPresence.getPresenceAddress();
         presenceLibrary.setState(LibraryState.LOADING);
         LOG.debugf("browsing {0} ...", friendPresence.getPresenceId());
-        browseFactory.createBrowse(address).start(new BrowseListener() {
+        browseFactory.createBrowse(friendPresence).start(new BrowseListener() {
             public void handleBrowseResult(SearchResult searchResult) {
                 LOG.debugf("browse result: {0}, {1}", searchResult.getUrn(), searchResult.getSize());
                 RemoteFileDescAdapter remoteFileDescAdapter = (RemoteFileDescAdapter)searchResult;
diff --git a/components/core-glue/src/main/java/org/limewire/core/impl/library/RemoteLibraryManagerImpl.java b/components/core-glue/src/main/java/org/limewire/core/impl/library/RemoteLibraryManagerImpl.java
new file mode 100644
index 0000000..ae21605
--- a/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/CoreGlueXMPPModule.java
+++ b/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/CoreGlueXMPPModule.java
@@ -6,8 +6,12 @@ import java.util.Map;
 import org.limewire.inject.AbstractModule;
 import org.limewire.xmpp.api.client.XMPPConnectionConfiguration;
 import org.limewire.xmpp.client.LimeWireXMPPModule;
+import org.limewire.security.MACCalculator;
+import org.limewire.security.MACCalculatorRepositoryManager;
+import org.limewire.concurrent.AbstractLazySingletonProvider;
 
 import com.google.inject.TypeLiteral;
+import com.google.inject.name.Names;
 
 public class CoreGlueXMPPModule extends AbstractModule {
     protected void configure() {
@@ -18,5 +22,14 @@ public class CoreGlueXMPPModule extends AbstractModule {
         bind(new TypeLiteral<Map<String, XMPPUserSettings.XMPPUserConfiguration>>(){}).toProvider(XMPPUserSettings.XMPPUserConfigs.class);
         bind(FriendShareListRefresher.FriendShareListEventImpl.class);
         bind(FriendShareListRefresher.RosterEventListenerImpl.class);
+        bind(MACCalculator.class).annotatedWith(Names.named("xmppMACCalculator")).toProvider(XMPPSessionMACCalculatorProvider.class);
+        bind(CoreGlueXMPPService.class);
+    }
+    
+    private static class XMPPSessionMACCalculatorProvider extends AbstractLazySingletonProvider<MACCalculator> {
+        @Override
+        protected MACCalculator createObject() {
+            return MACCalculatorRepositoryManager.createDefaultCalculatorFactory().createMACCalculator();
+        }
     }
 }
diff --git a/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/CoreGlueXMPPService.java b/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/CoreGlueXMPPService.java
new file mode 100644
index 0000000..c4ee463
--- /dev/null
+++ b/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/CoreGlueXMPPService.java
@@ -0,0 +1,56 @@
+package org.limewire.core.impl.xmpp;
+
+import org.limewire.i18n.I18nMarker;
+import org.limewire.lifecycle.Service;
+import org.limewire.lifecycle.ServiceRegistry;
+
+import com.google.inject.Inject;
+import com.google.inject.Provider;
+import com.google.inject.Singleton;
+import com.limegroup.gnutella.HTTPAcceptor;
+import com.limegroup.gnutella.uploader.HttpRequestHandlerFactory;
+
+@Singleton
+public class CoreGlueXMPPService implements Service {
+
+    private final Provider<HTTPAcceptor> httpAcceptor;
+    private final HttpRequestHandlerFactory httpRequestHandlerFactory;
+    private final Provider<FriendFileListProvider> authenticatingBrowseFriendListProvider;
+    
+    private final static String FRIEND_BROWSE_PATTERN = "/friend/browse";
+    private final static String FRIEND_DOWNLOAD_PATTERN = "/friend/download";
+
+    @Inject
+    public CoreGlueXMPPService(Provider<HTTPAcceptor> httpAcceptor, HttpRequestHandlerFactory httpRequestHandlerFactory,
+           Provider<FriendFileListProvider> authenticatingBrowseFriendListProvider) {
+        this.httpAcceptor = httpAcceptor;
+        this.httpRequestHandlerFactory = httpRequestHandlerFactory;
+        this.authenticatingBrowseFriendListProvider = authenticatingBrowseFriendListProvider;
+    }
+    
+    @Inject
+    void register(ServiceRegistry registry) {
+        registry.register(this);
+    }
+    
+    @Override
+    public String getServiceName() {
+        return I18nMarker.marktr("XMPP Service");
+    }
+
+    @Override
+    public void initialize() {
+    }
+
+    @Override
+    public void start() {
+        httpAcceptor.get().registerHandler(FRIEND_BROWSE_PATTERN, httpRequestHandlerFactory.createBrowseRequestHandler(authenticatingBrowseFriendListProvider.get(), true)); 
+        httpAcceptor.get().registerHandler(FRIEND_DOWNLOAD_PATTERN, httpRequestHandlerFactory.createFileRequestHandler(authenticatingBrowseFriendListProvider.get(), true));
+    }
+
+    @Override
+    public void stop() {
+        httpAcceptor.get().unregisterHandler(FRIEND_BROWSE_PATTERN);
+    }
+
+}
diff --git a/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/FriendFileListProvider.java b/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/FriendFileListProvider.java
new file mode 100644
index 0000000..979b58e
--- /dev/null
+++ b/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/FriendFileListProvider.java
@@ -0,0 +1,75 @@
+package org.limewire.core.impl.xmpp;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.net.URLDecoder;
+
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpStatus;
+import org.apache.http.RequestLine;
+import org.apache.http.auth.Credentials;
+import org.apache.http.protocol.HttpContext;
+import org.limewire.http.auth.ServerAuthState;
+
+import com.google.inject.Inject;
+import com.limegroup.gnutella.FileList;
+import com.limegroup.gnutella.FileManager;
+import com.limegroup.gnutella.uploader.HttpException;
+import com.limegroup.gnutella.uploader.authentication.HttpRequestFileListProvider;
+
+public class FriendFileListProvider implements HttpRequestFileListProvider {
+
+    private final FileManager fileManager;
+
+    @Inject
+    public FriendFileListProvider(FileManager fileManager) {
+        this.fileManager = fileManager;
+    }
+    
+    @Override
+    public FileList getFileList(HttpRequest request, HttpContext httpContext) throws HttpException, IOException, org.apache.http.HttpException {
+        ServerAuthState authState = (ServerAuthState)httpContext.getAttribute(ServerAuthState.AUTH_STATE);
+        if(authState != null) {
+            Credentials credentials = authState.getCredentials();
+            if(credentials != null) {
+                FileList buddyFileList = fileManager.getFriendFileList(credentials.getUserPrincipal().getName());
+                if (buddyFileList == null) {
+                    throw new HttpException("no such list for: " + credentials.getUserPrincipal().getName(), HttpStatus.SC_NOT_FOUND);
+                }
+                return buddyFileList;
+            }
+        }
+        throw new HttpException("forbidden", HttpStatus.SC_FORBIDDEN);
+    }
+    
+    String parseFriend(HttpRequest request) throws HttpException {
+        RequestLine requestLine = request.getRequestLine();
+        String uri;
+        try {
+            uri = URLDecoder.decode(requestLine.getUri(), "UTF-8");
+            int lastSlash = uri.lastIndexOf('/');
+            // check for trailing slash
+            if (lastSlash == uri.length() - 1) {
+                lastSlash = uri.lastIndexOf('/', uri.length() - 2);
+                if (lastSlash != -1) {
+                    return uri.substring(lastSlash + 1, uri.length() - 1);
+                }
+            }
+            if (lastSlash != -1) {
+                return uri.substring(lastSlash + 1);
+            }
+        } catch (UnsupportedEncodingException e) {
+            throw new RuntimeException(e);
+        }
+        throw new HttpException("no friend id:", HttpStatus.SC_BAD_REQUEST);
+    }
+    
+    String getFriend(HttpRequest request) throws HttpException {
+        String friendId = parseFriend(request);
+        if (friendId.contains(":")) {
+            throw new HttpException("invalid friend id:" + String.valueOf(friendId), HttpStatus.SC_BAD_REQUEST);
+        }
+        return friendId;
+    }
+     
+}
diff --git a/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/FriendShareListRefresher.java b/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/FriendShareListRefresher.java
new file mode 100644
index 0000000..ce3a980
--- a/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/XMPPConfigurationImpl.java
+++ b/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/XMPPConfigurationImpl.java
@@ -11,15 +11,17 @@ public class XMPPConfigurationImpl implements XMPPConnectionConfiguration {
     private final XMPPUserSettings.XMPPUserConfiguration userConfiguration;
     private final EventListener<RosterEvent> rosterListener;
     private final XMPPErrorListener errorListener;
+    private String resource;
 
     public XMPPConfigurationImpl(XMPPServerSettings.XMPPServerConfiguration serverConfiguration,
                                  XMPPUserSettings.XMPPUserConfiguration userConfiguration,
                                  EventListener<RosterEvent> rosterListener,
-                                 XMPPErrorListener errorListener) {
+                                 XMPPErrorListener errorListener, String resource) {
         this.serverConfiguration = serverConfiguration;
         this.userConfiguration = userConfiguration;
         this.rosterListener = rosterListener;
         this.errorListener = errorListener;
+        this.resource = resource;
     }
 
     public boolean isDebugEnabled() {
@@ -69,4 +71,18 @@ public class XMPPConfigurationImpl implements XMPPConnectionConfiguration {
     public XMPPErrorListener getErrorListener() {
         return errorListener;
     }
+
+    public String getMyID() {
+        return getUsername();
+    }
+
+    public String getNetworkName() {
+        return getServiceName();
+    }
+
+    @Override
+    public String getResource() {
+        return resource;
+    }
+    
 }
diff --git a/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/XMPPConfigurationListProvider.java b/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/XMPPConfigurationListProvider.java
index 19fac3b..c9d66e7 100644
--- a/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/XMPPConfigurationListProvider.java
+++ b/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/XMPPConfigurationListProvider.java
@@ -3,20 +3,23 @@ package org.limewire.core.impl.xmpp;
 import java.util.ArrayList;
 import java.util.Map;
 
+import org.apache.commons.codec.binary.Base64;
+import org.limewire.security.SHA1;
+import org.limewire.util.StringUtils;
 import org.limewire.xmpp.api.client.XMPPConnectionConfiguration;
 
 import com.google.inject.Inject;
 import com.google.inject.Provider;
 import com.google.inject.Singleton;
+import com.limegroup.gnutella.ApplicationServices;
 
 @Singleton
 class XMPPConfigurationListProvider extends ArrayList<XMPPConnectionConfiguration> {
 
     @Inject
     XMPPConfigurationListProvider(Provider<Map<String, XMPPServerSettings.XMPPServerConfiguration>> serverConfigs,
-                                  Provider<Map<String, XMPPUserSettings.XMPPUserConfiguration>> userConfigs/*,
-                                  EventListener<RosterEvent> rosterListener,
-                                  XMPPErrorListener errorListener*/) {
+                                  Provider<Map<String, XMPPUserSettings.XMPPUserConfiguration>> userConfigs,
+                                  ApplicationServices applicationServices) {
         for(String serviceName : serverConfigs.get().keySet()) {
             XMPPServerSettings.XMPPServerConfiguration serverConfiguration = serverConfigs.get().get(serviceName);
             XMPPUserSettings.XMPPUserConfiguration userConfiguration = userConfigs.get().get(serviceName);
@@ -24,7 +27,15 @@ class XMPPConfigurationListProvider extends ArrayList<XMPPConnectionConfiguratio
                 userConfiguration = new XMPPUserSettings.XMPPUserConfiguration(serviceName);
             }
             // TODO per-configuration RosterListeners, XMPPErrorListeners
-            add(new XMPPConfigurationImpl(serverConfiguration, userConfiguration, null, null));
+           
+            // the resource is set to a hash of the client guid to uniquely
+            // identify the instance of the client
+            add(new XMPPConfigurationImpl(serverConfiguration, userConfiguration, null, null, 
+                    createHash(applicationServices.getMyGUID())));
         }
     }
+    
+    private static String createHash(byte[] guid) {
+        return StringUtils.getUTF8String(Base64.encodeBase64(new SHA1().digest(guid)));
+    }
 }
diff --git a/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/XMPPServerSettings.java b/components/core-glue/src/main/java/org/limewire/core/impl/xmpp/XMPPServerSettings.java
index ac7bede..0ea1297 100644
--- /dev/null
+++ b/components/core-glue/src/test/java/org/limewire/core/impl/xmpp/AuthenticatingBrowseFriendListProviderTest.java
@@ -0,0 +1,120 @@
+package org.limewire.core.impl.xmpp;
+
+import java.util.Arrays;
+
+import org.apache.commons.codec.binary.Base64;
+import org.apache.http.auth.AUTH;
+import org.apache.http.message.BasicHeader;
+import org.apache.http.message.BasicHttpRequest;
+import org.apache.http.protocol.BasicHttpContext;
+import org.hamcrest.BaseMatcher;
+import org.hamcrest.Description;
+import org.jmock.Expectations;
+import org.jmock.Mockery;
+import org.limewire.security.MACCalculator;
+import org.limewire.security.SecurityToken.TokenData;
+import org.limewire.util.BaseTestCase;
+import org.limewire.util.StringUtils;
+
+import com.limegroup.gnutella.FileList;
+import com.limegroup.gnutella.FileManager;
+import com.limegroup.gnutella.uploader.HttpException;
+
+public class AuthenticatingBrowseFriendListProviderTest extends BaseTestCase {
+
+    private Mockery context;
+    private FileManager fileManager;
+    private MACCalculator calculator;
+    private FriendFileListProvider browseFriendListProvider;
+
+    public AuthenticatingBrowseFriendListProviderTest(String name) {
+        super(name);
+    }
+    
+    @Override
+    protected void setUp() throws Exception {
+        context = new Mockery();
+        fileManager = context.mock(FileManager.class);
+        calculator = context.mock(MACCalculator.class);
+        browseFriendListProvider = new FriendFileListProvider(fileManager);
+    }
+
+    public void testGetFriendForValidEntries() throws Exception {
+        BasicHttpRequest request = new BasicHttpRequest("GET", "/friend/me%40me.com");
+        assertEquals("me@me.com", browseFriendListProvider.getFriend(request));
+        request = new BasicHttpRequest("GET", "/friend/me%40me.com/");
+        assertEquals("me@me.com", browseFriendListProvider.getFriend(request));
+    }
+    
+    public void testGetFriendForInvalidEntries() {
+        BasicHttpRequest request = new BasicHttpRequest("GET", "me%40me.com");
+        try {
+            browseFriendListProvider.getFriend(request);
+            fail("exception expected, not a valid request");
+        } catch (HttpException he) {
+        }
+        request = new BasicHttpRequest("GET", "");
+        try {
+            browseFriendListProvider.getFriend(request);
+            fail("exception expected, not a valid request");
+        } catch (HttpException he) {
+        }
+        request = new BasicHttpRequest("GET", "me:@me.com");
+        try {
+            browseFriendListProvider.getFriend(request);
+            fail("exception expected, not a valid request");
+        } catch (HttpException he) {
+        }
+    }
+    
+    public void testGetFileListToBrowse() throws Exception {
+        final FileList expectedFileList = context.mock(FileList.class);
+        context.checking(new Expectations() { {
+            one(calculator).getMACBytes(with(new BaseMatcher<TokenData>() {
+                @Override
+                public boolean matches(Object item) {
+                    TokenData tokenData = (TokenData)item;
+                    return Arrays.equals(tokenData.getData(), StringUtils.toUTF8Bytes("me@me.com"));
+                }
+                @Override
+                public void describeTo(Description description) {
+                }
+            }));
+            will(returnValue(StringUtils.toUTF8Bytes("password")));
+            one(fileManager).getFriendFileList("me@me.com");
+            will(returnValue(expectedFileList));
+        }});
+        BasicHttpRequest request = new BasicHttpRequest("GET", "/friend/me%40me.com");
+        request.addHeader(new BasicHeader(AUTH.WWW_AUTH_RESP, "Basic " + StringUtils.getASCIIString(Base64.encodeBase64(StringUtils.toUTF8Bytes("me@me.com:password")))));
+        FileList fileList = browseFriendListProvider.getFileList(request, new BasicHttpContext());
+        assertSame(expectedFileList, fileList);
+        context.assertIsSatisfied();
+    }
+    
+    public void testGetFileListToBrowseWithNoFileList() throws Exception {
+        context.checking(new Expectations() { {
+            one(calculator).getMACBytes(with(new BaseMatcher<TokenData>() {
+                @Override
+                public boolean matches(Object item) {
+                    TokenData tokenData = (TokenData)item;
+                    return Arrays.equals(tokenData.getData(), StringUtils.toUTF8Bytes("me@me.com"));
+                }
+                @Override
+                public void describeTo(Description description) {
+                }
+            }));
+            will(returnValue(StringUtils.toUTF8Bytes("me@me.com")));
+            one(fileManager).getFriendFileList("me@me.com");
+            will(returnValue(null));
+        }});
+        BasicHttpRequest request = new BasicHttpRequest("GET", "/friend/me%40me.com");
+        request.addHeader(new BasicHeader(AUTH.WWW_AUTH_RESP, "Basic " + StringUtils.getASCIIString(Base64.encodeBase64(StringUtils.toUTF8Bytes("me@me.com:me@me.com")))));
+        try {
+            browseFriendListProvider.getFileList(request, new BasicHttpContext());
+            fail("should have thrown exception");
+        } catch (HttpException e) {
+        }
+        context.assertIsSatisfied();
+    }
+
+}
diff --git a/components/http/src/main/java/org/limewire/http/BasicHttpAcceptor.java b/components/http/src/main/java/org/limewire/http/BasicHttpAcceptor.java
index cd6fdee..11ebf62 100644
--- a/components/http/src/main/java/org/limewire/http/BasicHttpAcceptor.java
+++ b/components/http/src/main/java/org/limewire/http/BasicHttpAcceptor.java
@@ -32,13 +32,14 @@ import org.apache.http.protocol.HttpRequestHandlerRegistry;
 import org.apache.http.protocol.ResponseContent;
 import org.apache.http.protocol.ResponseDate;
 import org.apache.http.protocol.ResponseServer;
+import org.limewire.http.auth.RequestAuthenticator;
 import org.limewire.http.protocol.ExtendedAsyncNHttpServiceHandler;
 import org.limewire.http.protocol.HttpServiceEventListener;
 import org.limewire.http.protocol.LimeResponseConnControl;
 import org.limewire.http.protocol.SynchronizedHttpProcessor;
 import org.limewire.http.protocol.SynchronizedNHttpRequestHandlerRegistry;
-import org.limewire.http.reactor.DispatchedIOReactor;
 import org.limewire.http.reactor.DefaultDispatchedIOReactor;
+import org.limewire.http.reactor.DispatchedIOReactor;
 import org.limewire.lifecycle.Service;
 import org.limewire.net.ConnectionAcceptor;
 import org.limewire.net.ConnectionDispatcher;
@@ -60,6 +61,8 @@ public class BasicHttpAcceptor implements ConnectionAcceptor, Service {
     public static final String[] DEFAULT_METHODS = new String[] { "GET",
             "HEAD", "POST", };
 
+    private final RequestAuthenticator requestAuthenticator;
+    
     private final String[] supportedMethods;
 
     private final NHttpRequestHandlerRegistry registry;
@@ -78,18 +81,23 @@ public class BasicHttpAcceptor implements ConnectionAcceptor, Service {
 
     private AtomicBoolean started = new AtomicBoolean();
 
-    public BasicHttpAcceptor(HttpParams params, String... supportedMethods) {
+    public BasicHttpAcceptor(HttpParams params,
+                             RequestAuthenticator requestAuthenticator,
+                             String... supportedMethods) {
         this.params = params;
+        this.requestAuthenticator = requestAuthenticator;
         this.supportedMethods = supportedMethods;
         
         this.registry = new SynchronizedNHttpRequestHandlerRegistry();
         this.processor = new SynchronizedHttpProcessor();
         
-        initializeDefaultInterceptor();
+        initializeDefaultInterceptor(requestAuthenticator);
     }
     
-    private void initializeDefaultInterceptor() {
+    private void initializeDefaultInterceptor(HttpProcessor requestAuthenticator) {
         // intercepts HTTP requests and responses
+        addRequestInterceptor(requestAuthenticator);
+        addResponseInterceptor(requestAuthenticator);
         addResponseInterceptor(new ResponseDate());
         addResponseInterceptor(new ResponseServer());
         addResponseInterceptor(new ResponseContent());
@@ -234,7 +242,7 @@ public class BasicHttpAcceptor implements ConnectionAcceptor, Service {
      */
     public void registerHandler(final String pattern,
             final NHttpRequestHandler handler) {
-        registry.register(pattern, handler);
+        registry.register(pattern, requestAuthenticator.guardedHandler(pattern, handler));       
     }
 
     /**
diff --git a/components/http/src/main/java/org/limewire/http/LimeWireHttpModule.java b/components/http/src/main/java/org/limewire/http/LimeWireHttpModule.java
index 560ac3c..3f26d5d 100644
--- a/components/http/src/main/java/org/limewire/http/LimeWireHttpModule.java
+++ b/components/http/src/main/java/org/limewire/http/LimeWireHttpModule.java
@@ -1,5 +1,6 @@
 package org.limewire.http;
 
+import org.limewire.http.auth.LimeWireHttpAuthModule;
 import org.limewire.http.httpclient.LimeWireHttpClientModule;
 import org.limewire.inject.AbstractModule;
 
@@ -11,5 +12,6 @@ public class LimeWireHttpModule extends AbstractModule {
     @Override
     protected void configure() {
         binder().install(new LimeWireHttpClientModule());
+        binder().install(new LimeWireHttpAuthModule());
     }
 }
diff --git a/components/http/src/main/java/org/limewire/http/auth/Authenticator.java b/components/http/src/main/java/org/limewire/http/auth/Authenticator.java
new file mode 100644
index 0000000..1e9b934
--- /dev/null
+++ b/components/http/src/main/java/org/limewire/http/auth/Authenticator.java
@@ -0,0 +1,8 @@
+package org.limewire.http.auth;
+
+import org.apache.http.auth.Credentials;
+
+public interface Authenticator {
+    void register(AuthenticatorRegistry registry);
+    boolean authenticate(Credentials credentials);
+}
diff --git a/components/http/src/main/java/org/limewire/http/auth/AuthenticatorRegistry.java b/components/http/src/main/java/org/limewire/http/auth/AuthenticatorRegistry.java
new file mode 100644
index 0000000..8c1db03
--- /dev/null
+++ b/components/http/src/main/java/org/limewire/http/auth/AuthenticatorRegistry.java
@@ -0,0 +1,5 @@
+package org.limewire.http.auth;
+
+public interface AuthenticatorRegistry {
+    void addAuthenticator(Authenticator userStore);
+}
diff --git a/components/http/src/main/java/org/limewire/http/auth/AuthenticatorRegistryImpl.java b/components/http/src/main/java/org/limewire/http/auth/AuthenticatorRegistryImpl.java
new file mode 100644
index 0000000..55117f1
--- /dev/null
+++ b/components/http/src/main/java/org/limewire/http/auth/AuthenticatorRegistryImpl.java
@@ -0,0 +1,43 @@
+package org.limewire.http.auth;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.apache.http.auth.Credentials;
+
+import com.google.inject.Singleton;
+
+@Singleton
+public class AuthenticatorRegistryImpl implements Authenticator, AuthenticatorRegistry {
+    
+    private final ReadWriteLock lock = new ReentrantReadWriteLock();
+    private final Set<Authenticator> authenticators = new HashSet<Authenticator>();
+    
+    public void register(AuthenticatorRegistry registry) {
+    }
+
+    public boolean authenticate(Credentials credentials) {
+        lock.readLock().lock();
+        try {
+            for(Authenticator authenticator : authenticators) {
+                if(authenticator.authenticate(credentials)) {
+                    return true;
+                }
+            }
+        } finally {
+            lock.readLock().unlock();
+        }
+        return false;
+    }
+
+    public void addAuthenticator(Authenticator authenticator) {
+        lock.writeLock().lock();
+        try {
+            authenticators.add(authenticator);
+        } finally {
+            lock.writeLock().unlock();
+        }
+    }
+}
diff --git a/components/http/src/main/java/org/limewire/http/auth/BasicAuthScheme.java b/components/http/src/main/java/org/limewire/http/auth/BasicAuthScheme.java
new file mode 100644
index 0000000..63b4211
--- /dev/null
+++ b/components/http/src/main/java/org/limewire/http/auth/BasicAuthScheme.java
@@ -0,0 +1,58 @@
+package org.limewire.http.auth;
+
+import java.util.StringTokenizer;
+
+import org.apache.commons.codec.binary.Base64;
+import org.apache.http.Header;
+import org.apache.http.HttpRequest;
+import org.apache.http.auth.AUTH;
+import org.apache.http.auth.Credentials;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.message.BasicHeader;
+import org.limewire.util.StringUtils;
+
+import com.google.inject.Inject;
+import com.google.inject.Singleton;
+
+@Singleton
+public class BasicAuthScheme implements ServerAuthScheme {
+    
+    private final Authenticator userStore;
+    private boolean complete;
+
+    @Inject
+    public BasicAuthScheme(Authenticator userStore) {
+        this.userStore = userStore;
+    }
+
+    public void setComplete() {
+        complete = true;
+    }
+
+    public boolean isComplete() {
+        return complete;
+    }
+
+    public Credentials authenticate(HttpRequest request) {
+        Header authHeader = request.getFirstHeader(AUTH.WWW_AUTH_RESP);
+        if(authHeader != null) {
+            StringTokenizer st = new StringTokenizer(authHeader.getValue());
+            if(st.hasMoreTokens()) {
+                if(st.nextToken().trim().equalsIgnoreCase("Basic")) {
+                    if(st.hasMoreTokens()) {
+                        byte [] userNamePassword = Base64.decodeBase64(st.nextToken().trim().getBytes());
+                        Credentials credentials = new UsernamePasswordCredentials(StringUtils.getUTF8String(userNamePassword));
+                        if(userStore.authenticate(credentials)) {
+                            return credentials;
+                        }
+                    }
+                }
+            } 
+        }
+        return null;
+    }
+
+    public Header createChallenge() {
+        return new BasicHeader(AUTH.WWW_AUTH, "Basic realm=\"secure\"");
+    }
+}
diff --git a/components/http/src/main/java/org/limewire/http/auth/LimeWireHttpAuthModule.java b/components/http/src/main/java/org/limewire/http/auth/LimeWireHttpAuthModule.java
new file mode 100644
index 0000000..ddbfc7b
--- /dev/null
+++ b/components/http/src/main/java/org/limewire/http/auth/LimeWireHttpAuthModule.java
@@ -0,0 +1,13 @@
+package org.limewire.http.auth;
+
+import org.limewire.inject.AbstractModule;
+
+public class LimeWireHttpAuthModule extends AbstractModule {
+    
+    @Override
+    protected void configure() {
+        bind(RequestAuthenticator.class).to(RequestAuthenticatorImpl.class);
+        bind(AuthenticatorRegistry.class).to(AuthenticatorRegistryImpl.class);
+        bind(Authenticator.class).to(AuthenticatorRegistryImpl.class);
+    }
+}
diff --git a/components/http/src/main/java/org/limewire/http/auth/Protected.java b/components/http/src/main/java/org/limewire/http/auth/Protected.java
new file mode 100644
index 0000000..d9ec3c8
--- /dev/null
+++ b/components/http/src/main/java/org/limewire/http/auth/Protected.java
@@ -0,0 +1,14 @@
+package org.limewire.http.auth;
+
+import java.lang.annotation.Target;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Documented;
+
+@Target(value = {ElementType.TYPE})
+@Retention(value = RetentionPolicy.RUNTIME)
+@Documented
+/** Used to mark an HttpRequestHandler as needing authentication*/
+public @interface Protected {
+}
diff --git a/components/http/src/main/java/org/limewire/http/auth/ProtectedURLRegistry.java b/components/http/src/main/java/org/limewire/http/auth/ProtectedURLRegistry.java
new file mode 100644
index 0000000..a1c9773
--- /dev/null
+++ b/components/http/src/main/java/org/limewire/http/auth/ProtectedURLRegistry.java
@@ -0,0 +1,5 @@
+package org.limewire.http.auth;
+
+public interface ProtectedURLRegistry {
+    void addProtectedURL(String url);
+}
diff --git a/components/http/src/main/java/org/limewire/http/auth/RequestAuthenticator.java b/components/http/src/main/java/org/limewire/http/auth/RequestAuthenticator.java
new file mode 100644
index 0000000..004d129
--- /dev/null
+++ b/components/http/src/main/java/org/limewire/http/auth/RequestAuthenticator.java
@@ -0,0 +1,8 @@
+package org.limewire.http.auth;
+
+import org.apache.http.protocol.HttpProcessor;
+import org.apache.http.nio.protocol.NHttpRequestHandler;
+
+public interface RequestAuthenticator extends HttpProcessor {
+    NHttpRequestHandler guardedHandler(String url, NHttpRequestHandler handler);
+}
diff --git a/components/http/src/main/java/org/limewire/http/auth/RequestAuthenticatorImpl.java b/components/http/src/main/java/org/limewire/http/auth/RequestAuthenticatorImpl.java
new file mode 100644
index 0000000..e0a89ca
--- /dev/null
+++ b/components/http/src/main/java/org/limewire/http/auth/RequestAuthenticatorImpl.java
@@ -0,0 +1,113 @@
+package org.limewire.http.auth;
+
+import java.io.IOException;
+
+import org.apache.http.HttpEntityEnclosingRequest;
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.auth.Credentials;
+import org.apache.http.nio.entity.ConsumingNHttpEntity;
+import org.apache.http.nio.protocol.NHttpRequestHandler;
+import org.apache.http.nio.protocol.NHttpResponseTrigger;
+import org.apache.http.protocol.HttpContext;
+import org.apache.http.protocol.UriPatternMatcher;
+
+import com.google.inject.Inject;
+import com.google.inject.Singleton;
+
+
+@Singleton
+public class RequestAuthenticatorImpl implements RequestAuthenticator {
+    final Authenticator userStore;
+    final UriPatternMatcher protectedURIs;
+    
+    @Inject
+    public RequestAuthenticatorImpl(Authenticator userStore) {
+        this.userStore = userStore;
+        protectedURIs = new UriPatternMatcher();
+    }
+
+    public void process(HttpRequest request, HttpContext context) throws HttpException, IOException {
+        if (request == null) {
+            throw new IllegalArgumentException("HTTP request may not be null");
+        }
+        if (context == null) {
+            throw new IllegalArgumentException("HTTP context may not be null");
+        }
+        
+        ServerAuthState authState = new ServerAuthState();
+        ServerAuthScheme authScheme = new BasicAuthScheme(userStore);
+        authState.setScheme(authScheme);  // TODO other schemes, scheme registry, etc
+        context.setAttribute(ServerAuthState.AUTH_STATE, authState);
+        if(protectedURIs.lookup(request.getRequestLine().getUri()) != null) {
+            Credentials credentials = authScheme.authenticate(request);
+            if(credentials != null) {
+                authState.setCredentials(credentials);
+                authScheme.setComplete();
+            }                
+        } else {
+            authScheme.setComplete();
+        }
+    }
+
+    public void process(HttpResponse response, HttpContext context) throws HttpException, IOException {
+        int i = 0;
+//        if (response == null) {
+//            throw new IllegalArgumentException("HTTP response may not be null");
+//        }
+//        if (context == null) {
+//            throw new IllegalArgumentException("HTTP context may not be null");
+//        }
+//        
+//        ServerAuthState authState = (ServerAuthState) context.getAttribute(ServerAuthState.AUTH_STATE);
+//        ServerAuthScheme authScheme = authState.getScheme();
+//        if (!authScheme.isComplete()) {
+//            response.addHeader(authScheme.createChallenge());    
+//        } 
+    }
+    
+    public NHttpRequestHandler guardedHandler(String url, NHttpRequestHandler handler) {
+        if(isProtected(handler)) {
+            protectedURIs.register(url, url);
+            return new GuardingHandler(handler);
+        } else {
+            return handler;
+        }
+    }
+    
+    private boolean isProtected(NHttpRequestHandler handler) {
+        return handler.getClass().getAnnotation(Protected.class) != null;        
+    }
+    
+    private class GuardingHandler implements NHttpRequestHandler {
+        private final NHttpRequestHandler handler;
+
+        public GuardingHandler(NHttpRequestHandler handler) {
+            this.handler = handler;
+        }
+
+        public ConsumingNHttpEntity entityRequest(HttpEntityEnclosingRequest request, HttpContext context) throws HttpException, IOException {
+            ServerAuthState authState = (ServerAuthState) context.getAttribute(ServerAuthState.AUTH_STATE);
+            ServerAuthScheme authScheme = authState.getScheme();
+            if(authScheme.isComplete()) {
+                return handler.entityRequest(request, context);
+            } else {
+                return null; // TODO ?    
+            }
+        }
+
+        public void handle(HttpRequest request, HttpResponse response, NHttpResponseTrigger trigger, HttpContext context) throws HttpException, IOException {
+            ServerAuthState authState = (ServerAuthState) context.getAttribute(ServerAuthState.AUTH_STATE);
+            ServerAuthScheme authScheme = authState.getScheme();
+            if(authScheme.isComplete()) {
+                handler.handle(request, response, trigger, context);
+            } else {
+                response.setStatusCode(HttpStatus.SC_UNAUTHORIZED);
+                response.addHeader(authScheme.createChallenge());
+                trigger.submitResponse(response);
+            }
+        }
+    }
+}
diff --git a/components/http/src/main/java/org/limewire/http/auth/ServerAuthScheme.java b/components/http/src/main/java/org/limewire/http/auth/ServerAuthScheme.java
new file mode 100644
index 0000000..4a96b79
--- /dev/null
+++ b/components/http/src/main/java/org/limewire/http/auth/ServerAuthScheme.java
@@ -0,0 +1,12 @@
+package org.limewire.http.auth;
+
+import org.apache.http.Header;
+import org.apache.http.HttpRequest;
+import org.apache.http.auth.Credentials;
+
+public interface ServerAuthScheme {
+    void setComplete();
+    boolean isComplete();
+    Credentials authenticate(HttpRequest request);
+    Header createChallenge();
+}
diff --git a/components/http/src/main/java/org/limewire/http/auth/ServerAuthState.java b/components/http/src/main/java/org/limewire/http/auth/ServerAuthState.java
new file mode 100644
index 0000000..f22b04c
--- /dev/null
+++ b/components/http/src/main/java/org/limewire/http/auth/ServerAuthState.java
@@ -0,0 +1,27 @@
+package org.limewire.http.auth;
+
+import org.apache.http.auth.Credentials;
+
+public class ServerAuthState {
+
+    public static final String AUTH_STATE = "http.server.auth"; 
+
+    private ServerAuthScheme scheme;
+    private Credentials credentials;
+
+    public ServerAuthScheme getScheme() {
+        return scheme;
+    }
+
+    public void setScheme(ServerAuthScheme scheme) {
+        this.scheme = scheme;
+    }
+
+    public Credentials getCredentials() {
+        return credentials;
+    }
+
+    public void setCredentials(Credentials credentials) {
+        this.credentials = credentials;
+    }
+}
diff --git a/components/http/src/main/java/org/limewire/http/httpclient/LimeHttpClient.java b/components/http/src/main/java/org/limewire/http/httpclient/LimeHttpClient.java
index 6979419..6ec4a1a 100644
--- a/components/http/src/main/java/org/limewire/http/httpclient/LimeHttpClient.java
+++ b/components/http/src/main/java/org/limewire/http/httpclient/LimeHttpClient.java
@@ -1,6 +1,7 @@
 package org.limewire.http.httpclient;
 
 import org.apache.http.HttpResponse;
+import org.apache.http.auth.Credentials;
 import org.apache.http.client.HttpClient;
 import org.apache.http.params.HttpParams;
 
@@ -14,6 +15,8 @@ public interface LimeHttpClient extends HttpClient {
      * @param params the params to use
      */
     public void setParams(HttpParams params);
+    
+    public void setCredentials(Credentials credentials);
 
     /**
      * Does any necessary cleanup to allow 
diff --git a/components/http/src/main/java/org/limewire/http/httpclient/LimeHttpClientImpl.java b/components/http/src/main/java/org/limewire/http/httpclient/LimeHttpClientImpl.java
index 100fbed..86e53c9 100644
--- a/components/http/src/main/java/org/limewire/http/httpclient/LimeHttpClientImpl.java
+++ b/components/http/src/main/java/org/limewire/http/httpclient/LimeHttpClientImpl.java
@@ -4,7 +4,10 @@ import java.io.IOException;
 import java.net.Socket;
 
 import org.apache.http.HttpResponse;
+import org.apache.http.auth.Credentials;
+import org.apache.http.auth.AuthScope;
 import org.apache.http.client.HttpRequestRetryHandler;
+import org.apache.http.client.CredentialsProvider;
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.params.HttpParams;
 import org.apache.http.protocol.HttpContext;
@@ -17,6 +20,7 @@ import com.google.inject.Provider;
  * <code>SocketWrappingHttpClient</code> 
  */
 class LimeHttpClientImpl extends DefaultHttpClient implements SocketWrappingHttpClient {
+    private Credentials credentials;
 
     public void setSocket(Socket socket) {
         ((ReapingClientConnectionManager)getConnectionManager()).setSocket(socket);
@@ -45,6 +49,27 @@ class LimeHttpClientImpl extends DefaultHttpClient implements SocketWrappingHttp
         };
     }
 
+    public void setCredentials(Credentials credentials) {
+        this.credentials = credentials;
+    }
+
+    @Override
+    protected CredentialsProvider createCredentialsProvider() {
+        return new CredentialsProvider() {
+            public void setCredentials(AuthScope authscope, Credentials credentials) {
+                throw new UnsupportedOperationException();
+            }
+
+            public Credentials getCredentials(AuthScope authscope) {
+                return credentials;
+            }
+
+            public void clear() {
+                credentials = null;
+            }
+        };
+    }
+
     private void close(HttpResponse response) {
         HttpClientUtils.releaseConnection(response);
     }
diff --git a/components/http/src/main/java/org/limewire/http/httpclient/LimeWireHttpClientModule.java b/components/http/src/main/java/org/limewire/http/httpclient/LimeWireHttpClientModule.java
index 2cf4d1b..402e1b3 100755
--- a/components/http/src/main/java/org/limewire/http/httpclient/LimeWireHttpClientModule.java
+++ b/components/http/src/main/java/org/limewire/http/httpclient/LimeWireHttpClientModule.java
@@ -1,204 +1,206 @@
-package org.limewire.http.httpclient;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.net.UnknownHostException;
-import java.util.concurrent.ScheduledExecutorService;
-
-import org.apache.http.client.params.ClientPNames;
-import org.apache.http.client.params.HttpClientParams;
-import org.apache.http.conn.ConnectTimeoutException;
-import org.apache.http.conn.scheme.Scheme;
-import org.apache.http.conn.scheme.SchemeRegistry;
-import org.apache.http.conn.scheme.SocketFactory;
-import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpParams;
-import org.limewire.concurrent.AbstractLazySingletonProvider;
-import org.limewire.net.SocketsManager;
-import org.limewire.nio.NBSocket;
-
-import com.google.inject.AbstractModule;
-import com.google.inject.Inject;
-import com.google.inject.Provider;
-import com.google.inject.Scopes;
-import com.google.inject.Singleton;
-import com.google.inject.name.Named;
-import com.google.inject.name.Names;
-
-public class LimeWireHttpClientModule extends AbstractModule {
-    
-    @Override
-    protected void configure() {        
-        bind(ReapingClientConnectionManager.class).annotatedWith(Names.named("nonBlockingConnectionManager")).toProvider(LimeClientConnectionManagerProvider.class).in(Scopes.SINGLETON);
-        bind(ReapingClientConnectionManager.class).annotatedWith(Names.named("socketWrappingConnectionManager")).toProvider(SocketWrappingClientConnectionManagerProvider.class).in(Scopes.SINGLETON);
-        bind(LimeHttpClient.class).toProvider(NonBlockingLimeHttpClientProvider.class);
-        bind(SocketWrappingHttpClient.class).toProvider(SocketWrappingLimeHttpClientProvider.class);
-        bind(SchemeRegistry.class).annotatedWith(Names.named("limeSchemeRegistry")).toProvider(LimeSchemeRegistryProvider.class);
-        bind(SchemeRegistry.class).annotatedWith(Names.named("socketWrappingSchemeRegistry")).toProvider(SocketWrappingSchemeRegistryProvider.class);
-        bind(SocketWrapperProtocolSocketFactory.class);
-        bind(HttpParams.class).annotatedWith(Names.named("defaults")).toProvider(DefaultHttpParamsProvider.class);
-    }
-    
-    private abstract static class AbstractLimeHttpClientProvider implements Provider<SocketWrappingHttpClient> {
-        private ReapingClientConnectionManager manager;
-        private final Provider<HttpParams> defaultParams;
-
-        public AbstractLimeHttpClientProvider(ReapingClientConnectionManager manager, Provider<HttpParams> defaultParams) {
-            this.manager = manager;
-            this.defaultParams = defaultParams;
-        }
-
-        public SocketWrappingHttpClient get() {
-            return new LimeHttpClientImpl(manager, defaultParams);
-        }
-    }
-    
-    @Singleton
-    private static class NonBlockingLimeHttpClientProvider extends AbstractLimeHttpClientProvider {
-        @Inject
-        public NonBlockingLimeHttpClientProvider(@Named("nonBlockingConnectionManager") ReapingClientConnectionManager manager, @Named("defaults") Provider<HttpParams> defaultParams) {
-            super(manager, defaultParams);
-        }        
-    }
-    
-    @Singleton
-    private static class SocketWrappingLimeHttpClientProvider extends AbstractLimeHttpClientProvider {
-        @Inject
-        public SocketWrappingLimeHttpClientProvider(@Named("socketWrappingConnectionManager") ReapingClientConnectionManager manager, @Named("defaults") Provider<HttpParams> defaultParams) {
-            super(manager, defaultParams);
-        }        
-    }
-    
-    @Singleton
-    private static class LimeSchemeRegistryProvider extends AbstractLazySingletonProvider<SchemeRegistry> {
-        private final Provider<SocketsManager> socketsManager;
-        
-        @Inject
-        public LimeSchemeRegistryProvider(Provider<SocketsManager> socketsManager) {
-            this.socketsManager = socketsManager;
-        }
-
-        @Override
-        protected SchemeRegistry createObject() {
-            SchemeRegistry registry = new SchemeRegistry();
-            registry.register(new Scheme("http", new LimeSocketFactory(socketsManager, SocketsManager.ConnectType.PLAIN), 80));
-            registry.register(new Scheme("tls", new LimeSocketFactory(socketsManager, SocketsManager.ConnectType.TLS),80));
-            registry.register(new Scheme("https", new LimeSocketFactory(socketsManager, SocketsManager.ConnectType.TLS),80));
-            return registry;
-        }
-    }
-    
-    @Singleton
-    private static class SocketWrappingSchemeRegistryProvider extends AbstractLazySingletonProvider<SchemeRegistry> {
-
-        @Override
-        protected SchemeRegistry createObject() {
-            SchemeRegistry registry = new SchemeRegistry();
-            registry.register(new Scheme("http", new SocketWrapperProtocolSocketFactory(), 80));
-            registry.register(new Scheme("tls", new SocketWrapperProtocolSocketFactory(),80));
-            registry.register(new Scheme("https", new SocketWrapperProtocolSocketFactory(),80));
-            return registry;
-        }
-    }
-    
-    private abstract static class AbstractClientConnectionManagerProvider extends AbstractLazySingletonProvider<ReapingClientConnectionManager> {
-        private final Provider<SchemeRegistry> registry;
-        private final Provider<ScheduledExecutorService> scheduler;
-        private final Provider<HttpParams> defaultParams;
-
-        public AbstractClientConnectionManagerProvider(Provider<SchemeRegistry> registry, Provider<ScheduledExecutorService> scheduler, Provider<HttpParams> defaultParams) {
-            this.registry = registry;
-            this.scheduler = scheduler;
-            this.defaultParams = defaultParams;
-        }
-
-        @Override
-        public ReapingClientConnectionManager createObject() {
-            return new ReapingClientConnectionManager(registry, scheduler, defaultParams);
-        }
-    }
-    
-    @Singleton
-    private static class LimeClientConnectionManagerProvider extends AbstractClientConnectionManagerProvider {
-
-        @Inject
-        public LimeClientConnectionManagerProvider(@Named("limeSchemeRegistry")Provider<SchemeRegistry> registry, @Named("backgroundExecutor") Provider<ScheduledExecutorService> scheduler, @Named("defaults") Provider<HttpParams> defaultParams) {
-            super(registry, scheduler, defaultParams);
-        }
-    }
-    
-    @Singleton
-    private static class SocketWrappingClientConnectionManagerProvider extends AbstractClientConnectionManagerProvider {
-
-        @Inject
-        public SocketWrappingClientConnectionManagerProvider(@Named("socketWrappingSchemeRegistry")Provider<SchemeRegistry> registry, @Named("backgroundExecutor") Provider<ScheduledExecutorService> scheduler, @Named("defaults") Provider<HttpParams> defaultParams) {
-            super(registry, scheduler, defaultParams);
-        }
-    }
-    
-    private static class LimeSocketFactory implements SocketFactory {
-        final Provider<SocketsManager> socketsManager;
-        final SocketsManager.ConnectType type;
-        
-        public LimeSocketFactory(Provider<SocketsManager> socketsManager, SocketsManager.ConnectType type) {
-            this.socketsManager = socketsManager;
-            this.type = type;
-        }
-
-        public Socket createSocket() throws IOException {
-            return socketsManager.get().create(type);
-        }
-
-        public Socket connectSocket(Socket socket, String targetHost, int targetPort, InetAddress localAddress, int localPort, HttpParams httpParams) throws IOException, UnknownHostException, ConnectTimeoutException {
-            if(socket == null) {
-                socket = createSocket();
-            }
-            InetSocketAddress localSocketAddr = null;
-            if((localAddress != null && !localAddress.isAnyLocalAddress()) || localPort > 0) {
-                localSocketAddr = new InetSocketAddress(localAddress, localPort);
-            }
-            return socketsManager.get().connect((NBSocket)socket, localSocketAddr, new InetSocketAddress(targetHost,targetPort), HttpConnectionParams.getConnectionTimeout(httpParams), type);
-        }
-
-        public boolean isSecure(Socket socket) throws IllegalArgumentException {
-            return false; // TODO type.equals(SocketsManager.ConnectType.TLS);  // TODO use socket instead?
-        }        
-    }
-    
-    @Singleton
-    private static class DefaultHttpParamsProvider implements Provider<HttpParams>{
-        /**
-         * The amount of time to wait while trying to connect to a specified
-         * host via TCP.  If we exceed this value, an IOException is thrown
-         * while trying to connect.
-         */
-        private static final int CONNECTION_TIMEOUT = 5000;
-        
-        /**
-         * The amount of time to wait while receiving data from a specified
-         * host.  Used as an SO_TIMEOUT.
-         */
-        private static final int TIMEOUT = 8000;
-        
-        /**
-         * The maximum number of times to allow redirects from hosts.
-         */
-        private static final int MAXIMUM_REDIRECTS = 10;
-        
-        @Inject
-        private DefaultHttpParamsProvider(){}
-        
-        public HttpParams get() {
-            BasicHttpParams params = new BasicHttpParams();
-            HttpConnectionParams.setConnectionTimeout(params, CONNECTION_TIMEOUT);
-            HttpConnectionParams.setSoTimeout(params, TIMEOUT);
-            HttpClientParams.setRedirecting(params, true);
-            params.setIntParameter(ClientPNames.MAX_REDIRECTS, MAXIMUM_REDIRECTS);
-            return params;
-        }
-    }
-
-}
+package org.limewire.http.httpclient;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import java.util.concurrent.ScheduledExecutorService;
+
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.params.ClientPNames;
+import org.apache.http.client.params.HttpClientParams;
+import org.apache.http.conn.ConnectTimeoutException;
+import org.apache.http.conn.scheme.Scheme;
+import org.apache.http.conn.scheme.SchemeRegistry;
+import org.apache.http.conn.scheme.SocketFactory;
+import org.apache.http.params.BasicHttpParams;
+import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpParams;
+import org.limewire.concurrent.AbstractLazySingletonProvider;
+import org.limewire.net.SocketsManager;
+import org.limewire.nio.NBSocket;
+
+import com.google.inject.AbstractModule;
+import com.google.inject.Inject;
+import com.google.inject.Provider;
+import com.google.inject.Scopes;
+import com.google.inject.Singleton;
+import com.google.inject.name.Named;
+import com.google.inject.name.Names;
+
+public class LimeWireHttpClientModule extends AbstractModule {
+    
+    @Override
+    protected void configure() {        
+        bind(ReapingClientConnectionManager.class).annotatedWith(Names.named("nonBlockingConnectionManager")).toProvider(LimeClientConnectionManagerProvider.class).in(Scopes.SINGLETON);
+        bind(ReapingClientConnectionManager.class).annotatedWith(Names.named("socketWrappingConnectionManager")).toProvider(SocketWrappingClientConnectionManagerProvider.class).in(Scopes.SINGLETON);
+        bind(LimeHttpClient.class).toProvider(NonBlockingLimeHttpClientProvider.class);
+        bind(HttpClient.class).toProvider(NonBlockingLimeHttpClientProvider.class);
+        bind(SocketWrappingHttpClient.class).toProvider(SocketWrappingLimeHttpClientProvider.class);
+        bind(SchemeRegistry.class).annotatedWith(Names.named("limeSchemeRegistry")).toProvider(LimeSchemeRegistryProvider.class);
+        bind(SchemeRegistry.class).annotatedWith(Names.named("socketWrappingSchemeRegistry")).toProvider(SocketWrappingSchemeRegistryProvider.class);
+        bind(SocketWrapperProtocolSocketFactory.class);
+        bind(HttpParams.class).annotatedWith(Names.named("defaults")).toProvider(DefaultHttpParamsProvider.class);
+    }
+    
+    private abstract static class AbstractLimeHttpClientProvider implements Provider<SocketWrappingHttpClient> {
+        private ReapingClientConnectionManager manager;
+        private final Provider<HttpParams> defaultParams;
+
+        public AbstractLimeHttpClientProvider(ReapingClientConnectionManager manager, Provider<HttpParams> defaultParams) {
+            this.manager = manager;
+            this.defaultParams = defaultParams;
+        }
+
+        public SocketWrappingHttpClient get() {
+            return new LimeHttpClientImpl(manager, defaultParams);
+        }
+    }
+    
+    @Singleton
+    private static class NonBlockingLimeHttpClientProvider extends AbstractLimeHttpClientProvider {
+        @Inject
+        public NonBlockingLimeHttpClientProvider(@Named("nonBlockingConnectionManager") ReapingClientConnectionManager manager, @Named("defaults") Provider<HttpParams> defaultParams) {
+            super(manager, defaultParams);
+        }        
+    }
+    
+    @Singleton
+    private static class SocketWrappingLimeHttpClientProvider extends AbstractLimeHttpClientProvider {
+        @Inject
+        public SocketWrappingLimeHttpClientProvider(@Named("socketWrappingConnectionManager") ReapingClientConnectionManager manager, @Named("defaults") Provider<HttpParams> defaultParams) {
+            super(manager, defaultParams);
+        }        
+    }
+    
+    @Singleton
+    private static class LimeSchemeRegistryProvider extends AbstractLazySingletonProvider<SchemeRegistry> {
+        private final Provider<SocketsManager> socketsManager;
+        
+        @Inject
+        public LimeSchemeRegistryProvider(Provider<SocketsManager> socketsManager) {
+            this.socketsManager = socketsManager;
+        }
+
+        @Override
+        protected SchemeRegistry createObject() {
+            SchemeRegistry registry = new SchemeRegistry();
+            registry.register(new Scheme("http", new LimeSocketFactory(socketsManager, SocketsManager.ConnectType.PLAIN), 80));
+            registry.register(new Scheme("tls", new LimeSocketFactory(socketsManager, SocketsManager.ConnectType.TLS),80));
+            registry.register(new Scheme("https", new LimeSocketFactory(socketsManager, SocketsManager.ConnectType.TLS),80));
+            return registry;
+        }
+    }
+    
+    @Singleton
+    private static class SocketWrappingSchemeRegistryProvider extends AbstractLazySingletonProvider<SchemeRegistry> {
+
+        @Override
+        protected SchemeRegistry createObject() {
+            SchemeRegistry registry = new SchemeRegistry();
+            registry.register(new Scheme("http", new SocketWrapperProtocolSocketFactory(), 80));
+            registry.register(new Scheme("tls", new SocketWrapperProtocolSocketFactory(),80));
+            registry.register(new Scheme("https", new SocketWrapperProtocolSocketFactory(),80));
+            return registry;
+        }
+    }
+    
+    private abstract static class AbstractClientConnectionManagerProvider extends AbstractLazySingletonProvider<ReapingClientConnectionManager> {
+        private final Provider<SchemeRegistry> registry;
+        private final Provider<ScheduledExecutorService> scheduler;
+        private final Provider<HttpParams> defaultParams;
+
+        public AbstractClientConnectionManagerProvider(Provider<SchemeRegistry> registry, Provider<ScheduledExecutorService> scheduler, Provider<HttpParams> defaultParams) {
+            this.registry = registry;
+            this.scheduler = scheduler;
+            this.defaultParams = defaultParams;
+        }
+
+        @Override
+        public ReapingClientConnectionManager createObject() {
+            return new ReapingClientConnectionManager(registry, scheduler, defaultParams);
+        }
+    }
+    
+    @Singleton
+    private static class LimeClientConnectionManagerProvider extends AbstractClientConnectionManagerProvider {
+
+        @Inject
+        public LimeClientConnectionManagerProvider(@Named("limeSchemeRegistry")Provider<SchemeRegistry> registry, @Named("backgroundExecutor") Provider<ScheduledExecutorService> scheduler, @Named("defaults") Provider<HttpParams> defaultParams) {
+            super(registry, scheduler, defaultParams);
+        }
+    }
+    
+    @Singleton
+    private static class SocketWrappingClientConnectionManagerProvider extends AbstractClientConnectionManagerProvider {
+
+        @Inject
+        public SocketWrappingClientConnectionManagerProvider(@Named("socketWrappingSchemeRegistry")Provider<SchemeRegistry> registry, @Named("backgroundExecutor") Provider<ScheduledExecutorService> scheduler, @Named("defaults") Provider<HttpParams> defaultParams) {
+            super(registry, scheduler, defaultParams);
+        }
+    }
+    
+    private static class LimeSocketFactory implements SocketFactory {
+        final Provider<SocketsManager> socketsManager;
+        final SocketsManager.ConnectType type;
+        
+        public LimeSocketFactory(Provider<SocketsManager> socketsManager, SocketsManager.ConnectType type) {
+            this.socketsManager = socketsManager;
+            this.type = type;
+        }
+
+        public Socket createSocket() throws IOException {
+            return socketsManager.get().create(type);
+        }
+
+        public Socket connectSocket(Socket socket, String targetHost, int targetPort, InetAddress localAddress, int localPort, HttpParams httpParams) throws IOException, UnknownHostException, ConnectTimeoutException {
+            if(socket == null) {
+                socket = createSocket();
+            }
+            InetSocketAddress localSocketAddr = null;
+            if((localAddress != null && !localAddress.isAnyLocalAddress()) || localPort > 0) {
+                localSocketAddr = new InetSocketAddress(localAddress, localPort);
+            }
+            return socketsManager.get().connect((NBSocket)socket, localSocketAddr, new InetSocketAddress(targetHost,targetPort), HttpConnectionParams.getConnectionTimeout(httpParams), type);
+        }
+
+        public boolean isSecure(Socket socket) throws IllegalArgumentException {
+            return false; // TODO type.equals(SocketsManager.ConnectType.TLS);  // TODO use socket instead?
+        }        
+    }
+    
+    @Singleton
+    private static class DefaultHttpParamsProvider implements Provider<HttpParams>{
+        /**
+         * The amount of time to wait while trying to connect to a specified
+         * host via TCP.  If we exceed this value, an IOException is thrown
+         * while trying to connect.
+         */
+        private static final int CONNECTION_TIMEOUT = 5000;
+        
+        /**
+         * The amount of time to wait while receiving data from a specified
+         * host.  Used as an SO_TIMEOUT.
+         */
+        private static final int TIMEOUT = 8000;
+        
+        /**
+         * The maximum number of times to allow redirects from hosts.
+         */
+        private static final int MAXIMUM_REDIRECTS = 10;
+        
+        @Inject
+        private DefaultHttpParamsProvider(){}
+        
+        public HttpParams get() {
+            BasicHttpParams params = new BasicHttpParams();
+            HttpConnectionParams.setConnectionTimeout(params, CONNECTION_TIMEOUT);
+            HttpConnectionParams.setSoTimeout(params, TIMEOUT);
+            HttpClientParams.setRedirecting(params, true);
+            params.setIntParameter(ClientPNames.MAX_REDIRECTS, MAXIMUM_REDIRECTS);
+            return params;
+        }
+    }
+
+}
diff --git a/components/http/src/main/java/org/limewire/http/httpclient/SimpleLimeHttpClient.java b/components/http/src/main/java/org/limewire/http/httpclient/SimpleLimeHttpClient.java
index ff14fdb..0f04753 100755
--- a/components/http/src/main/java/org/limewire/http/httpclient/SimpleLimeHttpClient.java
+++ b/components/http/src/main/java/org/limewire/http/httpclient/SimpleLimeHttpClient.java
@@ -1,12 +1,36 @@
-package org.limewire.http.httpclient;
-
-import org.apache.http.HttpResponse;
-import org.apache.http.impl.client.DefaultHttpClient;
-
-public class SimpleLimeHttpClient extends DefaultHttpClient implements LimeHttpClient {
-
-    public void releaseConnection(HttpResponse response) {
-        HttpClientUtils.releaseConnection(response);
-    }
-
-}
+package org.limewire.http.httpclient;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.client.CredentialsProvider;
+import org.apache.http.auth.Credentials;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+public class SimpleLimeHttpClient extends DefaultHttpClient implements LimeHttpClient {
+    private Credentials credentials;
+
+    public void releaseConnection(HttpResponse response) {
+        HttpClientUtils.releaseConnection(response);
+    }
+
+    public void setCredentials(Credentials credentials) {
+        this.credentials = credentials;
+    }
+
+    @Override
+    protected CredentialsProvider createCredentialsProvider() {
+        return new CredentialsProvider() {
+            public void setCredentials(AuthScope authscope, Credentials credentials) {
+                throw new UnsupportedOperationException();    
+            }
+
+            public Credentials getCredentials(AuthScope authscope) {
+                return credentials;
+            }
+
+            public void clear() {
+                throw new UnsupportedOperationException();        
+            }
+        };
+    }
+}
diff --git a/components/http/src/test/java/org/limewire/http/BasicAuthenticationRequestInterceptorTest.java b/components/http/src/test/java/org/limewire/http/BasicAuthenticationRequestInterceptorTest.java
new file mode 100644
index 0000000..e63be9d
--- /dev/null
+++ b/components/http/src/test/java/org/limewire/http/BasicAuthenticationRequestInterceptorTest.java
@@ -0,0 +1,74 @@
+package org.limewire.http;
+
+import java.io.IOException;
+
+import org.apache.http.Header;
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.impl.auth.BasicScheme;
+import org.apache.http.message.BasicHttpRequest;
+import org.apache.http.protocol.BasicHttpContext;
+import org.limewire.util.BaseTestCase;
+
+public class BasicAuthenticationRequestInterceptorTest extends BaseTestCase {
+
+    public BasicAuthenticationRequestInterceptorTest(String name) {
+        super(name);
+    }
+
+    public void testProcessNoCredentials() throws Exception {
+        BasicHttpContext context = new BasicHttpContext();
+        try {
+            new BasicAuthenticationRequestInterceptor("mellow", "world").process(new BasicHttpRequest("GET", "/"), context);
+            fail("expected exception");
+        } catch (HttpException e) {
+        }
+    }
+    
+    public void testProcessWrongUsername() throws IOException {
+        BasicHttpContext context = new BasicHttpContext();
+        try {
+            new BasicAuthenticationRequestInterceptor("mellow", "world").process(createRequest("hello", "world"), context);
+            fail("expected exception");
+        } catch (HttpException e) {
+        }
+    }
+    
+    public void testProcessWrongPassword() throws IOException {
+        BasicHttpContext context = new BasicHttpContext();
+        try {
+            new BasicAuthenticationRequestInterceptor("hello", "morld").process(createRequest("hello", "world"), context);
+            fail("expected exception");
+        } catch (HttpException e) {
+        }
+    }
+    
+    public void testProcessValidCredentials() throws IOException {
+        BasicHttpContext context = new BasicHttpContext();
+        try {
+            new BasicAuthenticationRequestInterceptor("hello", "world").process(createRequest("hello", "world"), context);
+        } catch (HttpException e) {
+        }
+    }
+
+    public void testParseCredentialsGeneratedByBasicScheme() throws Exception {
+        Header header = createAuthorizationHeader("hello", "world\u30d5");
+        BasicAuthenticationRequestInterceptor acceptingInterceptor = new BasicAuthenticationRequestInterceptor("hello", "world\u30d5");
+        UsernamePasswordCredentials parsedCredentials = acceptingInterceptor.parseCredentials(header);
+        assertEquals("hello", parsedCredentials.getUserName());
+        assertEquals("world\u30d5", parsedCredentials.getPassword());
+    }
+    
+    private Header createAuthorizationHeader(String username, String password) {
+        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);
+        return BasicScheme.authenticate(credentials, "UTF-8", false);
+    }
+    
+    private HttpRequest createRequest(String username, String password) {
+        BasicHttpRequest request = new BasicHttpRequest("GET", "/");
+        request.addHeader(createAuthorizationHeader(username, password));
+        return request;
+    }
+
+}
diff --git a/components/http/src/test/java/org/limewire/http/BasicHttpAcceptorTest.java b/components/http/src/test/java/org/limewire/http/BasicHttpAcceptorTest.java
index 8246bdd..5a24c6e 100644
--- a/components/http/src/test/java/org/limewire/http/BasicHttpAcceptorTest.java
+++ b/components/http/src/test/java/org/limewire/http/BasicHttpAcceptorTest.java
@@ -5,12 +5,16 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.util.Arrays;
 
+import junit.framework.Test;
+
 import org.apache.http.HttpResponse;
 import org.apache.http.HttpStatus;
 import org.apache.http.client.HttpClient;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.methods.HttpHead;
 import org.apache.http.impl.client.DefaultHttpClient;
+import org.limewire.http.auth.RequestAuthenticatorImpl;
+import org.limewire.http.auth.AuthenticatorRegistryImpl;
 import org.limewire.http.handler.BasicMimeTypeProvider;
 import org.limewire.http.handler.FileRequestHandler;
 import org.limewire.http.httpclient.HttpClientUtils;
@@ -20,8 +24,6 @@ import org.limewire.net.ConnectionDispatcherImpl;
 import org.limewire.net.SocketAcceptor;
 import org.limewire.util.BaseTestCase;
 
-import junit.framework.Test;
-
 public class BasicHttpAcceptorTest extends BaseTestCase {
 
     private static final int PORT = 6668;
@@ -65,7 +67,9 @@ public class BasicHttpAcceptorTest extends BaseTestCase {
         acceptor.bind(PORT);
 
         httpAcceptor = new BasicHttpAcceptor(BasicHttpAcceptor
-                .createDefaultParams("agent", timeout), methods);
+                .createDefaultParams("agent", timeout),
+                new RequestAuthenticatorImpl(new AuthenticatorRegistryImpl()),
+                methods);
         httpAcceptor.start();
         
         connectionDispatcher.addConnectionAcceptor(httpAcceptor, true, httpAcceptor.getHttpMethods());
diff --git a/components/io/src/main/java/org/limewire/io/PermanentAddress.java b/components/io/src/main/java/org/limewire/io/PermanentAddress.java
new file mode 100644
index 0000000..cff076c
--- /dev/null
+++ b/components/io/src/main/java/org/limewire/io/PermanentAddress.java
@@ -0,0 +1,10 @@
+package org.limewire.io;
+
+/**
+ * Interface to mark an address a permanent address that can be serialized
+ * between sessions. These addresses usually need address resolution, examples
+ * could be a friend id, or a client guid.
+ */
+public interface PermanentAddress extends Address {
+
+}
diff --git a/components/security/build.xml b/components/security/build.xml
index b00061e..95f7ddd 100755
--- a/components/security/build.xml
+++ b/components/security/build.xml
@@ -10,8 +10,7 @@
 	</description>
 	
     <import file="../common/build-macros.xml"/>
-    <import file="../common/build.xml" />
-	<import file="../http/build.xml" />
+    <import file="../common/build.xml" />
 	<import file="../io/build.xml" />
     
     <target name="initialize" depends="lw-common.initialize, lw-http.initialize, lw-io.initialize" unless="initialized.security">
@@ -20,8 +19,10 @@
 			    <path refid="build.limewire.components.io.buildpath" />
 				<pathelement location="${limewire.lib.jars}/commons-logging.jar"/>
 				<pathelement location="${limewire.lib.jars}/dnsjava.jar"/>
-			    <path refid="build.limewire.components.common.buildpath"/>
-				<path refid="build.limewire.components.http.buildpath"/>
+                <pathelement location="${limewire.lib.jars}/httpclient-4.0-beta1.jar"/>
+                <pathelement location="${limewire.lib.jars}/httpcore-4.0-beta2.jar"/>
+		       	<pathelement location="${limewire.lib.jars}/httpcore-nio-4.0-beta2.jar"/>
+                <path refid="build.limewire.components.common.buildpath"/>
 			</src-classpath>
         </do.setup-properties>
     </target>
diff --git a/components/security/src/main/java/org/limewire/security/SHA1.java b/components/security/src/main/java/org/limewire/security/SHA1.java
new file mode 100644
index 0000000..65750f0
--- /dev/null
+++ b/components/security/src/main/java/org/limewire/security/SHA1.java
@@ -0,0 +1,707 @@
+/* @(#)SHA1.java	1.11 2004-04-26
+ * This file was freely contributed to the LimeWire project and is covered
+ * by its existing GPL licence, but it may be used individually as a public
+ * domain implementation of a published algorithm (see below for references).
+ * It was also freely contributed to the Bitzi public domain sources.
+ * @author  Philippe Verdy
+ */
+
+/* Sun may wish to change the following package name, if integrating this
+ * class in the Sun JCE Security Provider for Java 1.5 (code-named Tiger).
+ *
+ * You can include it in your own Security Provider by inserting
+ * this property in your Provider derived class:
+ * put("MessageDigest.SHA-1", "com.limegroup.gnutella.security.SHA1");
+ */
+ 
+package org.limewire.security;
+
+import java.security.DigestException;
+import java.security.MessageDigest;
+
+//--+---+1--+---+--2+---+---+3--+---+--4+---+---+5--+---+--6+---+---+7--+---+--
+//34567890123456789012345678901234567890123456789012345678901234567890123456789
+
+/**
+ * <p>The FIPS PUB 180-2 standard specifies four secure hash algorithms (SHA-1,
+ * SHA-256, SHA-384 and SHA-512) for computing a condensed representation of
+ * electronic data (message).  When a message of any length < 2^^64 bits (for
+ * SHA-1 and SHA-256) or < 2^^128 bits (for SHA-384 and SHA-512) is input to
+ * an algorithm, the result is an output called a message digest.  The message
+ * digests range in length from 160 to 512 bits, depending on the algorithm.
+ * Secure hash algorithms are typically used with other cryptographic
+ * algorithms, such as digital signature algorithms and keyed-hash message
+ * authentication codes, or in the generation of random numbers (bits).</p>
+ *
+ * <p>The four hash algorithms specified in this "SHS" standard are called
+ * secure because, for a given algorithm, it is computationally infeasible
+ * 1) to find a message that corresponds to a given message digest, or 2)
+ * to find two different messages that produce the same message digest.  Any
+ * change to a message will, with a very high probability, result in a
+ * different message digest.  This will result in a verification failure when
+ * the secure hash algorithm is used with a digital signature algorithm or a
+ * keyed-hash message authentication algorithm.</p>
+ *
+ * <p>A "SHS change notice" adds a SHA-224 algorithm for interoperability,
+ * which, like SHA-1 and SHA-256, operates on 512-bit blocks and 32-bit words,
+ * but truncates the final digest and uses distinct initialization values.</p>
+ *
+ * <p><b>References:</b></p>
+ * <ol>
+ *   <li> NIST FIPS PUB 180-2, "Secure Hash Signature Standard (SHS) with
+ *      change notice", National Institute of Standards and Technology (NIST),
+ *      2002 August 1, and U.S. Department of Commerce, August 26.<br>
+ *      <a href="http://csrc.ncsl.nist.gov/CryptoToolkit/Hash.html">
+ *      http://csrc.ncsl.nist.gov/CryptoToolkit/Hash.html</a>
+ *   <li> NIST FIPS PUB 180-1, "Secure Hash Standard",
+ *      U.S. Department of Commerce, May 1993.<br>
+ *      <a href="http://www.itl.nist.gov/div897/pubs/fip180-1.htm">
+ *      http://www.itl.nist.gov/div897/pubs/fip180-1.htm</a></li>
+ *   <li> Bruce Schneier, "Section 18.7 Secure Hash Algorithm (SHA)",
+ *      <cite>Applied Cryptography, 2nd edition</cite>, <br>
+ *      John Wiley &amp; Sons, 1996</li>
+ * </ol>
+ */
+public final class SHA1 extends MessageDigest implements Cloneable {
+
+    /**
+     * This implementation returns a fixed-size digest.
+     */
+    public static final int HASH_LENGTH = 20; // bytes == 160 bits
+
+    /**
+     * Private context for incomplete blocks and padding bytes.
+     * INVARIANT: padding must be in 0..63.
+     * When the padding reaches 64, a new block is computed, and
+     * the 56 last bytes are kept in the padding history.
+     */
+    private byte[] pad;
+    private int padding;
+
+    /**
+     * Private contextual byte count, sent in the next block,
+     * after the ending padding block.
+     */
+    private long bytes;
+
+    /**
+     * Private context that contains the current digest key.
+     */
+    private int hA, hB, hC, hD, hE;
+
+    /**
+     * Creates a SHA1 object with default initial state.
+     */
+    public SHA1() {
+        super("SHA-1");
+        pad = new byte[64];
+        init();
+    }
+
+    /**
+     * Clones this object.
+     */
+    @Override
+    public SHA1 clone() throws CloneNotSupportedException  {
+        SHA1 that = (SHA1)super.clone();
+        that.pad = this.pad.clone();
+        return that;
+    }
+
+    /**
+     * Returns the digest length in bytes.
+     *
+     * Can be used to allocate your own output buffer when
+     * computing multiple digests.
+     *
+     * Overrides the protected abstract method of
+     * <code>java.security.MessageDigestSpi</code>.
+     * @return the digest length in bytes.
+     */
+    @Override
+    public int engineGetDigestLength() {
+        return HASH_LENGTH;
+    }
+
+    /**
+     * Reset athen initialize the digest context.
+     *
+     * Overrides the protected abstract method of
+     * <code>java.security.MessageDigestSpi</code>.
+     */
+    @Override
+    protected void engineReset() {
+        int i = 60;
+        do {
+           pad[i    ] = (byte)0x00;
+           pad[i + 1] = (byte)0x00;
+           pad[i + 2] = (byte)0x00;
+           pad[i + 3] = (byte)0x00;
+        } while ((i -= 4) >= 0);
+        padding = 0;
+        bytes = 0;
+        init();
+    }
+
+    /**
+     * Initialize the digest context.
+     */
+    protected void init() {
+        hA = 0x67452301;
+        hB = 0xefcdab89;
+        hC = 0x98badcfe;
+        hD = 0x10325476;
+        hE = 0xc3d2e1f0;
+    }
+
+    /**
+     * Updates the digest using the specified byte.
+     * Requires internal buffering, and may be slow.
+     *
+     * Overrides the protected abstract method of
+     * java.security.MessageDigestSpi.
+     * @param input  the byte to use for the update.
+     */
+    @Override
+    public void engineUpdate(byte input) {
+        bytes++;
+        if (padding < 63) {
+            pad[padding++] = input;
+            return;
+        }
+        pad[63] = input;
+        computeBlock(pad, 0);
+        padding = 0;
+    }
+
+    /**
+     * Updates the digest using the specified array of bytes,
+     * starting at the specified offset.
+     *
+     * Input length can be any size. May require internal buffering,
+     * if input blocks are not multiple of 64 bytes.
+     *
+     * Overrides the protected abstract method of
+     * java.security.MessageDigestSpi.
+     * @param input  the array of bytes to use for the update.
+     * @param offset  the offset to start from in the array of bytes.
+     * @param length  the number of bytes to use, starting at offset.
+     */
+    @Override
+    public void engineUpdate(byte[] input, int offset, int len) {
+        if (offset >= 0 && len >= 0 && offset + len <= input.length) {
+            bytes += len;
+            /* Terminate the previous block. */
+            int padlen = 64 - padding;
+            if (padding > 0 && len >= padlen) {
+                System.arraycopy(input, offset, pad, padding, padlen);
+                computeBlock(pad, 0);
+                padding = 0;
+                offset += padlen;
+                len -= padlen;
+            }
+            /* Loop on large sets of complete blocks. */
+            while (len >= 512) {
+                computeBlock(input, offset);
+                computeBlock(input, offset + 64);
+                computeBlock(input, offset + 128);
+                computeBlock(input, offset + 192);
+                computeBlock(input, offset + 256);
+                computeBlock(input, offset + 320);
+                computeBlock(input, offset + 384);
+                computeBlock(input, offset + 448);
+                offset += 512;
+                len -= 512;
+            }
+            /* Loop on remaining complete blocks. */
+            while (len >= 64) {
+                computeBlock(input, offset);
+                offset += 64;
+                len -= 64;
+            }
+            /* remaining bytes kept for next block. */
+            if (len > 0) {
+                System.arraycopy(input, offset, pad, padding, len);
+                padding += len;
+            }
+            return;
+        }
+        throw new ArrayIndexOutOfBoundsException(offset);
+    }
+
+    /**
+     * Completes the hash computation by performing final operations
+     * such as padding. Computes the final hash and returns the final
+     * value as a byte[20] array. Once engineDigest has been called,
+     * the engine will be automatically reset as specified in the
+     * JavaSecurity MessageDigest specification.
+     *
+     * For faster operations with multiple digests, allocate your own
+     * array and use engineDigest(byte[], int offset, int len).
+     *
+     * Overrides the protected abstract method of
+     * java.security.MessageDigestSpi.
+     * @return the length of the digest stored in the output buffer.
+     */
+    @Override
+    public byte[] engineDigest() {
+        try {
+            final byte hashvalue[] = new byte[HASH_LENGTH];
+            engineDigest(hashvalue, 0, HASH_LENGTH);
+            return hashvalue;
+        } catch (DigestException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Completes the hash computation by performing final operations
+     * such as padding. Once engineDigest has been called, the engine
+     * will be automatically reset (see engineReset).
+     *
+     * Overrides the protected abstract method of
+     * java.security.MessageDigestSpi.
+     * @param hashvalue  the output buffer in which to store the digest.
+     * @param offset  offset to start from in the output buffer
+     * @param len  number of bytes within buf allotted for the digest.
+     *             Both this default implementation and the SUN provider
+     *             do not return partial digests.  The presence of this
+     *             parameter is solely for consistency in our API's.
+     *             If the value of this parameter is less than the
+     *             actual digest length, the method will throw a
+     *             DigestException.  This parameter is ignored if its
+     *             value is greater than or equal to the actual digest
+     *             length.
+     * @return  the length of the digest stored in the output buffer.
+     */
+    @Override
+    public int engineDigest(byte[] hashvalue, int offset, final int len)
+            throws DigestException {
+        if (len >= HASH_LENGTH) {
+            if (hashvalue.length - offset >= HASH_LENGTH) {
+                /* Flush the trailing bytes, adding padding bytes into last
+                 * blocks. */
+                int i;
+                /* Add padding null bytes but replace the last 8 padding bytes
+                 * by the little-endian 64-bit digested message bit-length. */
+                pad[i = padding] = (byte)0x80; /* required 1st padding byte */
+                /* Check if 8 bytes available in pad to store the total
+                 * message size */
+                switch (i) { /* INVARIANT: i must be in [0..63] */
+                case 52: pad[53] = (byte)0x00; /* no break; falls thru */
+                case 53: pad[54] = (byte)0x00; /* no break; falls thru */
+                case 54: pad[55] = (byte)0x00; /* no break; falls thru */
+                case 55: break;
+                case 56: pad[57] = (byte)0x00; /* no break; falls thru */
+                case 57: pad[58] = (byte)0x00; /* no break; falls thru */
+                case 58: pad[59] = (byte)0x00; /* no break; falls thru */
+                case 59: pad[60] = (byte)0x00; /* no break; falls thru */
+                case 60: pad[61] = (byte)0x00; /* no break; falls thru */
+                case 61: pad[62] = (byte)0x00; /* no break; falls thru */
+                case 62: pad[63] = (byte)0x00; /* no break; falls thru */
+                case 63:
+                    computeBlock(pad, 0);
+                    /* Clear the 56 first bytes of pad[]. */
+                    i = 52;
+                    do {
+                        pad[i    ] = (byte)0x00;
+                        pad[i + 1] = (byte)0x00;
+                        pad[i + 2] = (byte)0x00;
+                        pad[i + 3] = (byte)0x00;
+                    } while ((i -= 4) >= 0);
+                    break;
+                default:
+                    /* Clear the rest of 56 first bytes of pad[]. */
+                    switch (i & 3) {
+                    case 3: i++;
+                            break;
+                    case 2: pad[(i += 2) - 1] = (byte)0x00;
+                            break;
+                    case 1: pad[(i += 3) - 2] = (byte)0x00;
+                            pad[ i       - 1] = (byte)0x00;
+                            break;
+                    case 0: pad[(i += 4) - 3] = (byte)0x00;
+                            pad[ i       - 2] = (byte)0x00;
+                            pad[ i       - 1] = (byte)0x00;
+                    }
+                    do {
+                        pad[i    ] = (byte)0x00;
+                        pad[i + 1] = (byte)0x00;
+                        pad[i + 2] = (byte)0x00;
+                        pad[i + 3] = (byte)0x00;
+                    } while ((i += 4) < 56);
+                }
+                /* Convert the message size from bytes to big-endian bits. */
+                pad[56] = (byte)((i = (int)(bytes >>> 29)) >> 24);
+                pad[57] = (byte)(i >>> 16);
+                pad[58] = (byte)(i >>> 8);
+                pad[59] = (byte)i;
+                pad[60] = (byte)((i = (int)bytes << 3) >> 24);
+                pad[61] = (byte)(i >>> 16);
+                pad[62] = (byte)(i >>> 8);
+                pad[63] = (byte)i;
+                computeBlock(pad, 0);
+                /* Return the computed digest in big-endian byte order. */
+                hashvalue[offset     ] = (byte)((i = hA) >>> 24);
+                hashvalue[offset +  1] = (byte)(i >>> 16);
+                hashvalue[offset +  2] = (byte)(i >>> 8);
+                hashvalue[offset +  3] = (byte)i;
+                hashvalue[offset +  4] = (byte)((i = hB) >>> 24);
+                hashvalue[offset += 5] = (byte)(i >>> 16);
+                hashvalue[offset +  1] = (byte)(i >>> 8);
+                hashvalue[offset +  2] = (byte)i;
+                hashvalue[offset +  3] = (byte)((i = hC) >>> 24);
+                hashvalue[offset +  4] = (byte)(i >>> 16);
+                hashvalue[offset += 5] = (byte)(i >>> 8);
+                hashvalue[offset +  1] = (byte)i;
+                hashvalue[offset +  2] = (byte)((i = hD) >>> 24);
+                hashvalue[offset +  3] = (byte)(i >>> 16);
+                hashvalue[offset +  4] = (byte)(i >>> 8);
+                hashvalue[offset += 5] = (byte)i;
+                hashvalue[offset +  1] = (byte)((i = hE) >>> 24);
+                hashvalue[offset +  2] = (byte)(i >>> 16);
+                hashvalue[offset +  3] = (byte)(i >>> 8);
+                hashvalue[offset +  4] = (byte)i;
+                engineReset(); /* clear the evidence */
+                return HASH_LENGTH;
+            }
+            throw new DigestException(
+                "insufficient space in output buffer to store the digest");
+        }
+        throw new DigestException("partial digests not returned");
+    }
+
+    /**
+     * Updates the digest using the specified array of bytes,
+     * starting at the specified offset, but an implied length
+     * of exactly 64 bytes.
+     *
+     * Requires no internal buffering, but assumes a fixed input size,
+     * in which the required padding bytes may have been added.
+     *
+     * @param input  the array of bytes to use for the update.
+     * @param offset  the offset to start from in the array of bytes.
+     */
+    private void computeBlock(final byte[] input, int offset) {
+        /* Local temporary work variables for intermediate digests. */
+        int a, b, c, d, e;
+        /* Cache the input block into the local working set of 32-bit
+         * values, in big-endian byte order. Be careful when
+         * widening bytes or integers due to sign extension! */
+        int i00, i01, i02, i03, i04, i05, i06, i07,
+            i08, i09, i10, i11, i12, i13, i14, i15;
+        /* Use hash schedule function Ch (rounds 0..19):
+         *   Ch(x,y,z) = (x & y) ^ (~x & z) = (x & (y ^ z)) ^ z,
+         * and K00 = .... = K19 = 0x5a827999. */
+        /* First pass, on big endian input (rounds 0..15). */
+        e =  hE
+          +  (((a = hA) << 5) | (a >>> 27)) + 0x5a827999 // K00
+          +  (((b = hB) & ((c = hC)      ^ (d = hD))) ^ d) // Ch(b,c,d)
+          +  (i00 =  input[offset     ] << 24
+                  | (input[offset +  1] & 0xff) << 16
+                  | (input[offset +  2] & 0xff) << 8
+                  | (input[offset +  3] & 0xff)); // W00
+        d += ((e << 5) | (e >>> 27)) + 0x5a827999 // K01
+          +  ((a & ((b = (b << 30) | (b >>> 2)) ^ c)) ^ c) // Ch(a,b,c)
+          +  (i01 =  input[offset +  4] << 24
+                  | (input[offset += 5] & 0xff) << 16
+                  | (input[offset +  1] & 0xff) << 8
+                  | (input[offset +  2] & 0xff)); // W01
+        c += ((d << 5) | (d >>> 27)) + 0x5a827999 // K02
+          +  ((e & ((a = (a << 30) | (a >>> 2)) ^ b)) ^ b) // Ch(e,a,b)
+          +  (i02 =  input[offset +  3] << 24
+                  | (input[offset +  4] & 0xff) << 16
+                  | (input[offset += 5] & 0xff) << 8
+                  | (input[offset +  1] & 0xff)); // W02
+        b += ((c << 5) | (c >>> 27)) + 0x5a827999 // K03
+          +  ((d & ((e = (e << 30) | (e >>> 2)) ^ a)) ^ a) // Ch(d,e,a)
+          +  (i03 =  input[offset +  2] << 24
+                  | (input[offset +  3] & 0xff) << 16
+                  | (input[offset +  4] & 0xff) << 8
+                  | (input[offset += 5] & 0xff)); // W03
+        a += ((b << 5) | (b >>> 27)) + 0x5a827999 // K04
+          +  ((c & ((d = (d << 30) | (d >>> 2)) ^ e)) ^ e) // Ch(c,d,e)
+          +  (i04 =  input[offset +  1] << 24
+                  | (input[offset +  2] & 0xff) << 16
+                  | (input[offset +  3] & 0xff) << 8
+                  | (input[offset +  4] & 0xff)); // W04
+        e += ((a << 5) | (a >>> 27)) + 0x5a827999 // K05
+          +  ((b & ((c = (c << 30) | (c >>> 2)) ^ d)) ^ d) // Ch(b,c,d)
+          +  (i05 =  input[offset += 5] << 24
+                  | (input[offset +  1] & 0xff) << 16
+                  | (input[offset +  2] & 0xff) << 8
+                  | (input[offset +  3] & 0xff)); // W05
+        d += ((e << 5) | (e >>> 27)) + 0x5a827999 // K06
+          +  ((a & ((b = (b << 30) | (b >>> 2)) ^ c)) ^ c) // Ch(a,b,c)
+          +  (i06 =  input[offset +  4] << 24
+                  | (input[offset += 5] & 0xff) << 16
+                  | (input[offset +  1] & 0xff) << 8
+                  | (input[offset +  2] & 0xff)); // W06
+        c += ((d << 5) | (d >>> 27)) + 0x5a827999 // K07
+          +  ((e & ((a = (a << 30) | (a >>> 2)) ^ b)) ^ b) // Ch(e,a,b)
+          +  (i07 =  input[offset +  3] << 24
+                  | (input[offset +  4] & 0xff) << 16
+                  | (input[offset += 5] & 0xff) << 8
+                  | (input[offset +  1] & 0xff)); // W07
+        b += ((c << 5) | (c >>> 27)) + 0x5a827999 // K08
+          +  ((d & ((e = (e << 30) | (e >>> 2)) ^ a)) ^ a) // Ch(d,e,a)
+          +  (i08 =  input[offset +  2] << 24
+                  | (input[offset +  3] & 0xff) << 16
+                  | (input[offset +  4] & 0xff) << 8
+                  | (input[offset += 5] & 0xff)); // W08
+        a += ((b << 5) | (b >>> 27)) + 0x5a827999 // K09
+          +  ((c & ((d = (d << 30) | (d >>> 2)) ^ e)) ^ e) // Ch(c,d,e)
+          +  (i09 =  input[offset +  1] << 24
+                  | (input[offset +  2] & 0xff) << 16
+                  | (input[offset +  3] & 0xff) << 8
+                  | (input[offset +  4] & 0xff)); // W09
+        e += ((a << 5) | (a >>> 27)) + 0x5a827999 // K10
+          +  ((b & ((c = (c << 30) | (c >>> 2)) ^ d)) ^ d) // Ch(b,c,d)
+          +  (i10 =  input[offset += 5] << 24
+                  | (input[offset +  1] & 0xff) << 16
+                  | (input[offset +  2] & 0xff) << 8
+                  | (input[offset +  3] & 0xff)); // W10
+        d += ((e << 5) | (e >>> 27)) + 0x5a827999 // K11
+          +  ((a & ((b = (b << 30) | (b >>> 2)) ^ c)) ^ c) // Ch(a,b,c)
+          +  (i11 =  input[offset +  4] << 24
+                  | (input[offset += 5] & 0xff) << 16
+                  | (input[offset +  1] & 0xff) << 8
+                  | (input[offset +  2] & 0xff)); // W11
+        c += ((d << 5) | (d >>> 27)) + 0x5a827999 // K12
+          +  ((e & ((a = (a << 30) | (a >>> 2)) ^ b)) ^ b) // Ch(e,a,b)
+          +  (i12 =  input[offset +  3] << 24
+                  | (input[offset +  4] & 0xff) << 16
+                  | (input[offset += 5] & 0xff) << 8
+                  | (input[offset +  1] & 0xff)); // W12
+        b += ((c << 5) | (c >>> 27)) + 0x5a827999 // K13
+          +  ((d & ((e = (e << 30) | (e >>> 2)) ^ a)) ^ a) // Ch(d,e,a)
+          +  (i13 =  input[offset +  2] << 24
+                  | (input[offset +  3] & 0xff) << 16
+                  | (input[offset +  4] & 0xff) << 8
+                  | (input[offset += 5] & 0xff)); // W13
+        a += ((b << 5) | (b >>> 27)) + 0x5a827999 // K14
+          +  ((c & ((d = (d << 30) | (d >>> 2)) ^ e)) ^ e) // Ch(c,d,e)
+          +  (i14 =  input[offset +  1] << 24
+                  | (input[offset +  2] & 0xff) << 16
+                  | (input[offset +  3] & 0xff) << 8
+                  | (input[offset +  4] & 0xff)); // W14
+        e += ((a << 5) | (a >>> 27)) + 0x5a827999 // K15
+          +  ((b & ((c = (c << 30) | (c >>> 2)) ^ d)) ^ d) // Ch(b,c,d)
+          +  (i15 =  input[offset += 5] << 24
+                  | (input[offset +  1] & 0xff) << 16
+                  | (input[offset +  2] & 0xff) << 8
+                  | (input[offset +  3] & 0xff)); // W15
+        /* Second pass, on scheduled input (rounds 16..31). */
+        d += ((e << 5) | (e >>> 27)) + 0x5a827999 // K16
+          +  ((a & ((b = (b << 30) | (b >>> 2)) ^ c)) ^ c) // Ch(a,b,c)
+          +  (i00 = ((i00 ^= i02 ^ i08 ^ i13) << 1) | (i00 >>> 31)); // W16
+        c += ((d << 5) | (d >>> 27)) + 0x5a827999 // K17
+          +  ((e & ((a = (a << 30) | (a >>> 2)) ^ b)) ^ b) // Ch(e,a,b)
+          +  (i01 = ((i01 ^= i03 ^ i09 ^ i14) << 1) | (i01 >>> 31)); // W17
+        b += ((c << 5) | (c >>> 27)) + 0x5a827999 // K18
+          +  ((d & ((e = (e << 30) | (e >>> 2)) ^ a)) ^ a) // Ch(d,e,a)
+          +  (i02 = ((i02 ^= i04 ^ i10 ^ i15) << 1) | (i02 >>> 31)); // W18
+        a += ((b << 5) | (b >>> 27)) + 0x5a827999 // K19
+          +  ((c & ((d = (d << 30) | (d >>> 2)) ^ e)) ^ e) // Ch(c,d,e)
+          +  (i03 = ((i03 ^= i05 ^ i11 ^ i00) << 1) | (i03 >>> 31)); // W19
+        /* Use hash schedule function Parity (rounds 20..39):
+         *   Parity(x,y,z) = x ^ y ^ z,
+         * and K20 = .... = K39 = 0x6ed9eba1. */
+        e += ((a << 5) | (a >>> 27)) + 0x6ed9eba1 // K20
+          +  (b ^ (c = (c << 30) | (c >>> 2)) ^ d) // Parity(b,c,d)
+          +  (i04 = ((i04 ^= i06 ^ i12 ^ i01) << 1) | (i04 >>> 31)); // W20
+        d += ((e << 5) | (e >>> 27)) + 0x6ed9eba1 // K21
+          +  (a ^ (b = (b << 30) | (b >>> 2)) ^ c) // Parity(a,b,c)
+          +  (i05 = ((i05 ^= i07 ^ i13 ^ i02) << 1) | (i05 >>> 31)); // W21
+        c += ((d << 5) | (d >>> 27)) + 0x6ed9eba1 // K22
+          +  (e ^ (a = (a << 30) | (a >>> 2)) ^ b) // Parity(e,a,b)
+          +  (i06 = ((i06 ^= i08 ^ i14 ^ i03) << 1) | (i06 >>> 31)); // W22
+        b += ((c << 5) | (c >>> 27)) + 0x6ed9eba1 // K23
+          +  (d ^ (e = (e << 30) | (e >>> 2)) ^ a) // Parity(d,e,a)
+          +  (i07 = ((i07 ^= i09 ^ i15 ^ i04) << 1) | (i07 >>> 31)); // W23
+        a += ((b << 5) | (b >>> 27)) + 0x6ed9eba1 // K24
+          +  (c ^ (d = (d << 30) | (d >>> 2)) ^ e) // Parity(c,d,e)
+          +  (i08 = ((i08 ^= i10 ^ i00 ^ i05) << 1) | (i08 >>> 31)); // W24
+        e += ((a << 5) | (a >>> 27)) + 0x6ed9eba1 // K25
+          +  (b ^ (c = (c << 30) | (c >>> 2)) ^ d) // Parity(b,c,d)
+          +  (i09 = ((i09 ^= i11 ^ i01 ^ i06) << 1) | (i09 >>> 31)); // W25
+        d += ((e << 5) | (e >>> 27)) + 0x6ed9eba1 // K26
+          +  (a ^ (b = (b << 30) | (b >>> 2)) ^ c) // Parity(a,b,c)
+          +  (i10 = ((i10 ^= i12 ^ i02 ^ i07) << 1) | (i10 >>> 31)); // W26
+        c += ((d << 5) | (d >>> 27)) + 0x6ed9eba1 // K27
+          +  (e ^ (a = (a << 30) | (a >>> 2)) ^ b) // Parity(e,a,b)
+          +  (i11 = ((i11 ^= i13 ^ i03 ^ i08) << 1) | (i11 >>> 31)); // W27
+        b += ((c << 5) | (c >>> 27)) + 0x6ed9eba1 // K28
+          +  (d ^ (e = (e << 30) | (e >>> 2)) ^ a) // Parity(d,e,a)
+          +  (i12 = ((i12 ^= i14 ^ i04 ^ i09) << 1) | (i12 >>> 31)); // W28
+        a += ((b << 5) | (b >>> 27)) + 0x6ed9eba1 // K29
+          +  (c ^ (d = (d << 30) | (d >>> 2)) ^ e) // Parity(c,d,e)
+          +  (i13 = ((i13 ^= i15 ^ i05 ^ i10) << 1) | (i13 >>> 31)); // W29
+        e += ((a << 5) | (a >>> 27)) + 0x6ed9eba1 // K30
+          +  (b ^ (c = (c << 30) | (c >>> 2)) ^ d) // Parity(b,c,d)
+          +  (i14 = ((i14 ^= i00 ^ i06 ^ i11) << 1) | (i14 >>> 31)); // W30
+        d += ((e << 5) | (e >>> 27)) + 0x6ed9eba1 // K31
+          +  (a ^ (b = (b << 30) | (b >>> 2)) ^ c) // Parity(a,b,c)
+          +  (i15 = ((i15 ^= i01 ^ i07 ^ i12) << 1) | (i15 >>> 31)); // W31
+        /* Third pass, on scheduled input (rounds 32..47). */
+        c += ((d << 5) | (d >>> 27)) + 0x6ed9eba1 // K32
+          +  (e ^ (a = (a << 30) | (a >>> 2)) ^ b) // Parity(e,a,b)
+          +  (i00 = ((i00 ^= i02 ^ i08 ^ i13) << 1) | (i00 >>> 31)); // W32
+        b += ((c << 5) | (c >>> 27)) + 0x6ed9eba1 // K33
+          +  (d ^ (e = (e << 30) | (e >>> 2)) ^ a) // Parity(d,e,a)
+          +  (i01 = ((i01 ^= i03 ^ i09 ^ i14) << 1) | (i01 >>> 31)); // W33
+        a += ((b << 5) | (b >>> 27)) + 0x6ed9eba1 // K34
+          +  (c ^ (d = (d << 30) | (d >>> 2)) ^ e) // Parity(c,d,e)
+          +  (i02 = ((i02 ^= i04 ^ i10 ^ i15) << 1) | (i02 >>> 31)); // W34
+        e += ((a << 5) | (a >>> 27)) + 0x6ed9eba1 // K35
+          +  (b ^ (c = (c << 30) | (c >>> 2)) ^ d) // Parity(b,c,d)
+          +  (i03 = ((i03 ^= i05 ^ i11 ^ i00) << 1) | (i03 >>> 31)); // W35
+        d += ((e << 5) | (e >>> 27)) + 0x6ed9eba1 // K36
+          +  (a ^ (b = (b << 30) | (b >>> 2)) ^ c) // Parity(a,b,c)
+          +  (i04 = ((i04 ^= i06 ^ i12 ^ i01) << 1) | (i04 >>> 31)); // W36
+        c += ((d << 5) | (d >>> 27)) + 0x6ed9eba1 // K37
+          +  (e ^ (a = (a << 30) | (a >>> 2)) ^ b) // Parity(e,a,b)
+          +  (i05 = ((i05 ^= i07 ^ i13 ^ i02) << 1) | (i05 >>> 31)); // W37
+        b += ((c << 5) | (c >>> 27)) + 0x6ed9eba1 // K38
+          +  (d ^ (e = (e << 30) | (e >>> 2)) ^ a) // Parity(d,e,a)
+          +  (i06 = ((i06 ^= i08 ^ i14 ^ i03) << 1) | (i06 >>> 31)); // W38
+        a += ((b << 5) | (b >>> 27)) + 0x6ed9eba1 // K39
+          +  (c ^ (d = (d << 30) | (d >>> 2)) ^ e) // Parity(c,d,e)
+          +  (i07 = ((i07 ^= i09 ^ i15 ^ i04) << 1) | (i07 >>> 31)); // W39
+        /* Use hash schedule function Maj (rounds 40..59):
+         *   Maj(x,y,z) = (x&y) ^ (x&z) ^ (y&z) = (x & y) | ((x | y) & z),
+         * and K40 = .... = K59 = 0x8f1bbcdc. */
+        e += ((a << 5) | (a >>> 27)) + 0x8f1bbcdc // K40
+          +  ((b & (c = (c << 30) | (c >>> 2))) | ((b | c) & d)) // Maj(b,c,d)
+          +  (i08 = ((i08 ^= i10 ^ i00 ^ i05) << 1) | (i08 >>> 31)); // W40
+        d += ((e << 5) | (e >>> 27)) + 0x8f1bbcdc // K41
+          +  ((a & (b = (b << 30) | (b >>> 2))) | ((a | b) & c)) // Maj(a,b,c)
+          +  (i09 = ((i09 ^= i11 ^ i01 ^ i06) << 1) | (i09 >>> 31)); // W41
+        c += ((d << 5) | (d >>> 27)) + 0x8f1bbcdc // K42
+          +  ((e & (a = (a << 30) | (a >>> 2))) | ((e | a) & b)) // Maj(e,a,b)
+          +  (i10 = ((i10 ^= i12 ^ i02 ^ i07) << 1) | (i10 >>> 31)); // W42
+        b += ((c << 5) | (c >>> 27)) + 0x8f1bbcdc // K43
+          +  ((d & (e = (e << 30) | (e >>> 2))) | ((d | e) & a)) // Maj(d,e,a)
+          +  (i11 = ((i11 ^= i13 ^ i03 ^ i08) << 1) | (i11 >>> 31)); // W43
+        a += ((b << 5) | (b >>> 27)) + 0x8f1bbcdc // K44
+          +  ((c & (d = (d << 30) | (d >>> 2))) | ((c | d) & e)) // Maj(c,d,e)
+          +  (i12 = ((i12 ^= i14 ^ i04 ^ i09) << 1) | (i12 >>> 31)); // W44
+        e += ((a << 5) | (a >>> 27)) + 0x8f1bbcdc // K45
+          +  ((b & (c = (c << 30) | (c >>> 2))) | ((b | c) & d)) // Maj(b,c,d)
+          +  (i13 = ((i13 ^= i15 ^ i05 ^ i10) << 1) | (i13 >>> 31)); // W45
+        d += ((e << 5) | (e >>> 27)) + 0x8f1bbcdc // K46
+          +  ((a & (b = (b << 30) | (b >>> 2))) | ((a | b) & c)) // Maj(a,b,c)
+          +  (i14 = ((i14 ^= i00 ^ i06 ^ i11) << 1) | (i14 >>> 31)); // W46
+        c += ((d << 5) | (d >>> 27)) + 0x8f1bbcdc // K47
+          +  ((e & (a = (a << 30) | (a >>> 2))) | ((e | a) & b)) // Maj(e,a,b)
+          +  (i15 = ((i15 ^= i01 ^ i07 ^ i12) << 1) | (i15 >>> 31)); // W47
+        /* Fourth pass, on scheduled input (rounds 48..63). */
+        b += ((c << 5) | (c >>> 27)) + 0x8f1bbcdc // K48
+          +  ((d & (e = (e << 30) | (e >>> 2))) | ((d | e) & a)) // Maj(d,e,a)
+          +  (i00 = ((i00 ^= i02 ^ i08 ^ i13) << 1) | (i00 >>> 31)); // W48
+        a += ((b << 5) | (b >>> 27)) + 0x8f1bbcdc // K49
+          +  ((c & (d = (d << 30) | (d >>> 2))) | ((c | d) & e)) // Maj(c,d,e)
+          +  (i01 = ((i01 ^= i03 ^ i09 ^ i14) << 1) | (i01 >>> 31)); // W49
+        e += ((a << 5) | (a >>> 27)) + 0x8f1bbcdc // K50
+          +  ((b & (c = (c << 30) | (c >>> 2))) | ((b | c) & d)) // Maj(b,c,d)
+          +  (i02 = ((i02 ^= i04 ^ i10 ^ i15) << 1) | (i02 >>> 31)); // W50
+        d += ((e << 5) | (e >>> 27)) + 0x8f1bbcdc // K51
+          +  ((a & (b = (b << 30) | (b >>> 2))) | ((a | b) & c)) // Maj(a,b,c)
+          +  (i03 = ((i03 ^= i05 ^ i11 ^ i00) << 1) | (i03 >>> 31)); // W51
+        c += ((d << 5) | (d >>> 27)) + 0x8f1bbcdc // K52
+          +  ((e & (a = (a << 30) | (a >>> 2))) | ((e | a) & b)) // Maj(e,a,b)
+          +  (i04 = ((i04 ^= i06 ^ i12 ^ i01) << 1) | (i04 >>> 31)); // W52
+        b += ((c << 5) | (c >>> 27)) + 0x8f1bbcdc // K53
+          +  ((d & (e = (e << 30) | (e >>> 2))) | ((d | e) & a)) // Maj(d,e,a)
+          +  (i05 = ((i05 ^= i07 ^ i13 ^ i02) << 1) | (i05 >>> 31)); // W53
+        a += ((b << 5) | (b >>> 27)) + 0x8f1bbcdc // K54
+          +  ((c & (d = (d << 30) | (d >>> 2))) | ((c | d) & e)) // Maj(c,d,e)
+          +  (i06 = ((i06 ^= i08 ^ i14 ^ i03) << 1) | (i06 >>> 31)); // W54
+        e += ((a << 5) | (a >>> 27)) + 0x8f1bbcdc // K55
+          +  ((b & (c = (c << 30) | (c >>> 2))) | ((b | c) & d)) // Maj(b,c,d)
+          +  (i07 = ((i07 ^= i09 ^ i15 ^ i04) << 1) | (i07 >>> 31)); // W55
+        d += ((e << 5) | (e >>> 27)) + 0x8f1bbcdc // K56
+          +  ((a & (b = (b << 30) | (b >>> 2))) | ((a | b) & c)) // Maj(a,b,c)
+          +  (i08 = ((i08 ^= i10 ^ i00 ^ i05) << 1) | (i08 >>> 31)); // W56
+        c += ((d << 5) | (d >>> 27)) + 0x8f1bbcdc // K57
+          +  ((e & (a = (a << 30) | (a >>> 2))) | ((e | a) & b)) // Maj(e,a,b)
+          +  (i09 = ((i09 ^= i11 ^ i01 ^ i06) << 1) | (i09 >>> 31)); // W57
+        b += ((c << 5) | (c >>> 27)) + 0x8f1bbcdc // K58
+          +  ((d & (e = (e << 30) | (e >>> 2))) | ((d | e) & a)) // Maj(d,e,a)
+          +  (i10 = ((i10 ^= i12 ^ i02 ^ i07) << 1) | (i10 >>> 31)); // W58
+        a += ((b << 5) | (b >>> 27)) + 0x8f1bbcdc // K59
+          +  ((c & (d = (d << 30) | (d >>> 2))) | ((c | d) & e)) // Maj(c,d,e)
+          +  (i11 = ((i11 ^= i13 ^ i03 ^ i08) << 1) | (i11 >>> 31)); // W59
+        /* Use hash schedule function Parity (rounds 60..79):
+         *   Parity(x,y,z) = x ^ y ^ z,
+         * and K60 = .... = K79 = 0xca62c1d6. */
+        e += ((a << 5) | (a >>> 27)) + 0xca62c1d6 // K60
+          +  (b ^ (c = (c << 30) | (c >>> 2)) ^ d) // Parity(b,c,d)
+          +  (i12 = ((i12 ^= i14 ^ i04 ^ i09) << 1) | (i12 >>> 31)); // W60
+        d += ((e << 5) | (e >>> 27)) + 0xca62c1d6 // K61
+          +  (a ^ (b = (b << 30) | (b >>> 2)) ^ c) // Parity(a,b,c)
+          +  (i13 = ((i13 ^= i15 ^ i05 ^ i10) << 1) | (i13 >>> 31)); // W61
+        c += ((d << 5) | (d >>> 27)) + 0xca62c1d6 // K62
+          +  (e ^ (a = (a << 30) | (a >>> 2)) ^ b) // Parity(e,a,b)
+          +  (i14 = ((i14 ^= i00 ^ i06 ^ i11) << 1) | (i14 >>> 31)); // W62
+        b += ((c << 5) | (c >>> 27)) + 0xca62c1d6 // K63
+          +  (d ^ (e = (e << 30) | (e >>> 2)) ^ a) // Parity(d,e,a)
+          +  (i15 = ((i15 ^= i01 ^ i07 ^ i12) << 1) | (i15 >>> 31)); // W63
+        /* Fifth pass, on scheduled input (rounds 64..79). */
+        a += ((b << 5) | (b >>> 27)) + 0xca62c1d6 // K64
+          +  (c ^ (d = (d << 30) | (d >>> 2)) ^ e) // Parity(c,d,e)
+          +  (i00 = ((i00 ^= i02 ^ i08 ^ i13) << 1) | (i00 >>> 31)); // W64
+        e += ((a << 5) | (a >>> 27)) + 0xca62c1d6 // K65
+          +  (b ^ (c = (c << 30) | (c >>> 2)) ^ d) // Parity(b,c,d)
+          +  (i01 = ((i01 ^= i03 ^ i09 ^ i14) << 1) | (i01 >>> 31)); // W65
+        d += ((e << 5) | (e >>> 27)) + 0xca62c1d6 // K66
+          +  (a ^ (b = (b << 30) | (b >>> 2)) ^ c) // Parity(a,b,c)
+          +  (i02 = ((i02 ^= i04 ^ i10 ^ i15) << 1) | (i02 >>> 31)); // W66
+        c += ((d << 5) | (d >>> 27)) + 0xca62c1d6 // K67
+          +  (e ^ (a = (a << 30) | (a >>> 2)) ^ b) // Parity(e,a,b)
+          +  (i03 = ((i03 ^= i05 ^ i11 ^ i00) << 1) | (i03 >>> 31)); // W67
+        b += ((c << 5) | (c >>> 27)) + 0xca62c1d6 // K68
+          +  (d ^ (e = (e << 30) | (e >>> 2)) ^ a) // Parity(d,e,a)
+          +  (i04 = ((i04 ^= i06 ^ i12 ^ i01) << 1) | (i04 >>> 31)); // W68
+        a += ((b << 5) | (b >>> 27)) + 0xca62c1d6 // K69
+          +  (c ^ (d = (d << 30) | (d >>> 2)) ^ e) // Parity(c,d,e)
+          +  (i05 = ((i05 ^= i07 ^ i13 ^ i02) << 1) | (i05 >>> 31)); // W69
+        e += ((a << 5) | (a >>> 27)) + 0xca62c1d6 // K70
+          +  (b ^ (c = (c << 30) | (c >>> 2)) ^ d) // Parity(b,c,d)
+          +  (i06 = ((i06 ^= i08 ^ i14 ^ i03) << 1) | (i06 >>> 31)); // W70
+        d += ((e << 5) | (e >>> 27)) + 0xca62c1d6 // K71
+          +  (a ^ (b = (b << 30) | (b >>> 2)) ^ c) // Parity(a,b,c)
+          +  (i07 = ((i07 ^= i09 ^ i15 ^ i04) << 1) | (i07 >>> 31)); // W71
+        c += ((d << 5) | (d >>> 27)) + 0xca62c1d6 // K72
+          +  (e ^ (a = (a << 30) | (a >>> 2)) ^ b) // Parity(e,a,b)
+          +  (i08 = ((i08 ^= i10 ^ i00 ^ i05) << 1) | (i08 >>> 31)); // W72
+        b += ((c << 5) | (c >>> 27)) + 0xca62c1d6 // K73
+          +  (d ^ (e = (e << 30) | (e >>> 2)) ^ a) // Parity(d,e,a)
+          +  (i09 = ((i09 ^= i11 ^ i01 ^ i06) << 1) | (i09 >>> 31)); // W73
+        a += ((b << 5) | (b >>> 27)) + 0xca62c1d6 // K74
+          +  (c ^ (d = (d << 30) | (d >>> 2)) ^ e) // Parity(c,d,e)
+          +  (i10 = ((i10 ^= i12 ^ i02 ^ i07) << 1) | (i10 >>> 31)); // W74
+        e += ((a << 5) | (a >>> 27)) + 0xca62c1d6 // K75
+          +  (b ^ (c = (c << 30) | (c >>> 2)) ^ d) // Parity(b,c,d)
+          +  (i11 = ((i11 ^= i13 ^ i03 ^ i08) << 1) | (i11 >>> 31)); // W75
+        d += ((e << 5) | (e >>> 27)) + 0xca62c1d6 // K76
+          +  (a ^ (b = (b << 30) | (b >>> 2)) ^ c) // Parity(a,b,c)
+          +  (i12 = ((i12 ^= i14 ^ i04 ^ i09) << 1) | (i12 >>> 31)); // W76
+        c += ((d << 5) | (d >>> 27)) + 0xca62c1d6 // K77
+          +  (e ^ (a = (a << 30) | (a >>> 2)) ^ b) // Parity(e,a,b)
+          +  (i13 = ((i13 ^= i15 ^ i05 ^ i10) << 1) | (i13 >>> 31)); // W77
+        /* Terminate the last two rounds of fifth pass,
+         * feeding the final digest on the fly. */
+        hB +=
+        b += ((c << 5) | (c >>> 27)) + 0xca62c1d6 // K78
+          +  (d ^ (e = (e << 30) | (e >>> 2)) ^ a) // Parity(d,e,a)
+          +  (i14 = ((i14 ^= i00 ^ i06 ^ i11) << 1) | (i14 >>> 31)); // W78
+        hA +=
+        a += ((b << 5) | (b >>> 27)) + 0xca62c1d6 // K79
+          +  (c ^ (d = (d << 30) | (d >>> 2)) ^ e) // Parity(c,d,e)
+          +  (i15 = ((i15 ^= i01 ^ i07 ^ i12) << 1) | (i15 >>> 31)); // W79
+        hE += e;
+        hD += d;
+        hC += /* c= */ (c << 30) | (c >>> 2);
+    }
+}
diff --git a/components/security/src/main/java/org/limewire/security/certificate/KeyStoreProviderImpl.java b/components/security/src/main/java/org/limewire/security/certificate/KeyStoreProviderImpl.java
index 1df737c..29e0675 100644
--- a/components/security/src/main/java/org/limewire/security/certificate/KeyStoreProviderImpl.java
+++ b/components/security/src/main/java/org/limewire/security/certificate/KeyStoreProviderImpl.java
@@ -16,8 +16,8 @@ import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.http.HttpResponse;
 import org.apache.http.HttpStatus;
+import org.apache.http.client.HttpClient;
 import org.apache.http.client.methods.HttpGet;
-import org.limewire.http.httpclient.LimeHttpClient;
 import org.limewire.io.IOUtils;
 
 import com.google.inject.Inject;
@@ -32,14 +32,14 @@ import com.google.inject.Singleton;
 class KeyStoreProviderImpl implements KeyStoreProvider {
     private volatile KeyStore keyStore = null;
 
-    private final Provider<LimeHttpClient> httpClient;
+    private final Provider<HttpClient> httpClient;
     private volatile File keyStoreLocation;
     private volatile char[] keyStorePassword;
 
     private final Log LOG = LogFactory.getLog(KeyStoreProviderImpl.class);
 
     @Inject
-    KeyStoreProviderImpl(Provider<LimeHttpClient> httpClient) {
+    KeyStoreProviderImpl(Provider<HttpClient> httpClient) {
         this.httpClient = httpClient;
         this.keyStoreLocation = CertificateTools.getKeyStoreLocation();
         this.keyStorePassword = CertificateTools.getKeyStorePassword();
@@ -87,7 +87,7 @@ class KeyStoreProviderImpl implements KeyStoreProvider {
     }
 
     KeyStore getKeyStoreFromNetwork() throws IOException {
-        LimeHttpClient client = httpClient.get();
+        HttpClient client = httpClient.get();
         HttpGet get = new HttpGet(CertificateTools.getKeyStoreURI());
         
 
@@ -117,7 +117,13 @@ class KeyStoreProviderImpl implements KeyStoreProvider {
                         + response.getStatusLine());
             }
         } finally {
-            client.releaseConnection(response);
+            if(response != null && response.getEntity() != null) {
+                try {
+                    response.getEntity().consumeContent();
+                } catch (IOException e) {
+                    LOG.error(e);
+                }            
+            }
         }
     }
 
diff --git a/components/security/src/test/java/org/limewire/security/SHA1Test.java b/components/security/src/test/java/org/limewire/security/SHA1Test.java
new file mode 100644
index 0000000..b079bdb
--- /dev/null
+++ b/components/security/src/test/java/org/limewire/security/SHA1Test.java
@@ -0,0 +1,184 @@
+/*
+ * @(#)SHA1Test.java   1.9 2004-04-22
+ * This file was freely contributed to the LimeWire project  and is covered
+ * by its existing GPL licence, but it may be used individually as a public
+ * domain implementation of a published algorithm (see below for references).
+ * It was also freely contributed to the Bitzi public domain sources.
+ * @author  Philippe Verdy
+ */
+
+/*
+ * Sun may wish to change the following package name, if integrating this
+ * class in the Sun JCE Security Provider for Java 1.5 (code-named Tiger).
+ */
+package org.limewire.security;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.security.MessageDigest;
+
+import junit.framework.Test;
+
+import org.limewire.util.BaseTestCase;
+import org.limewire.util.TestUtils;
+
+public class SHA1Test extends BaseTestCase {
+    
+    private static final SHA1 hash = new SHA1();
+    
+       
+    public SHA1Test(String name) {
+        super(name);
+    }
+    
+    public static Test suite() {
+        return buildTestSuite(SHA1Test.class);
+    }
+    
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }          
+
+    public void testBasic() throws Exception {
+// http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf
+        tst(1, 1,
+            "abc",
+            "A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D");
+        tst(1, 2,
+            "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
+            "84983E44 1C3BD26e BAAE4AA1 F95129E5 E54670F1");
+        tst(1, 3,
+            1000000, "a",
+            "34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F");
+        // See also http://csrc.ncsl.nist.gov/cryptval/shs/sha1-vectors.zip
+    }
+    
+    public void testRate() throws Exception {
+        final int ITERATIONS = 16000;
+        final int BLOCKSIZE = 65536;
+        byte[] input = new byte[BLOCKSIZE];
+        for (int i = BLOCKSIZE; --i >= 0; )
+            input[i] = (byte)i;
+
+        long t0 = System.currentTimeMillis();
+        for (int i = ITERATIONS; --i >= 0; );
+        long t1 = System.currentTimeMillis();
+        for (int i = ITERATIONS; --i >= 0; )
+            hash.engineUpdate(input, 0, BLOCKSIZE);
+        long t2 = System.currentTimeMillis();
+        hash.engineReset();
+        double rate = 1000.0 * ITERATIONS * BLOCKSIZE / ((t2 - t1) - (t1 - t0));
+                    
+        double limeRate = rate;
+        //System.out.println("Our rate = " +
+        //                    (float)(rate * 8) + " bits/s = " +
+        //                    (float)(rate / (1024 * 1024)) + " Megabytes/s");
+        // Java 1.5 beta-b32c, on Athlon XP 1800+: 47.62 Megabytes/s.
+
+        MessageDigest md = MessageDigest.getInstance("SHA");
+        t0 = System.currentTimeMillis();
+        for (int i = ITERATIONS; --i >= 0; );
+        t1 = System.currentTimeMillis();
+        for (int i = ITERATIONS; --i >= 0; )
+            md.update(input, 0, BLOCKSIZE);
+        t2 = System.currentTimeMillis();
+        md.reset();
+        rate = 1000.0 * ITERATIONS * BLOCKSIZE / ((t2 - t1) - (t1 - t0));
+            //System.out.println("JCE rate = " +
+            //                    (float)(rate * 8) + " bits/s = " +
+            //                    (float)(rate / (1024 * 1024)) + " Megabytes/s");
+        // Java 1.5 beta-b32c, on Athlon XP 1800+: 22.78 Megabytes/s.
+        
+        assertGreaterThan(rate, limeRate);
+    }
+    
+    public void testFiles() throws Exception {
+        String dirString = "org/limewire/security";
+        File testDir = TestUtils.getResourceFile(dirString);
+        assertTrue(testDir.isDirectory());
+        int tested = testDirectory(testDir);
+        assertGreaterThan("didn't test enough", 10, tested);
+    }
+    
+    public int testDirectory(File dir) throws Exception {
+        int tested = 0;
+        File[] files = dir.listFiles();
+        for(int i = 0; i < files.length; i++) {
+            File f = files[i];
+            if(f.isDirectory())
+                tested += testDirectory(f);
+            else if(f.isFile() && f.exists()) {
+                byte[] old = createSHA1(f, true);
+                byte[] now = createSHA1(f, false);
+                assertEquals(old, now);
+                tested++;
+            }
+        }
+        return tested;
+    }
+    
+    
+	private static byte[] createSHA1(final File file, boolean digest) 
+      throws Exception {
+		FileInputStream fis = new FileInputStream(file);   		
+		// we can only calculate SHA1 for now
+		MessageDigest md = null;
+        if(digest)
+            md = MessageDigest.getInstance("SHA");
+        else
+            md = new SHA1();
+        
+        try {
+            byte[] buffer = new byte[16384];
+            int read;
+            while ((read=fis.read(buffer))!=-1)
+                md.update(buffer,0,read);
+        } finally {		
+            fis.close();
+        }
+
+        return md.digest();
+	}
+
+    
+    private static final void tst(final int set, final int vector,
+                                     final String source,
+                                     final String expect) {
+     //   System.out.print("Set " + set + ", vector# " + vector + ": ");
+        byte[] input = new byte[source.length()];
+        for (int i = 0; i < input.length; i++)
+            input[i] = (byte)source.charAt(i);
+        hash.engineUpdate(input, 0, input.length);
+        tstResult(expect);
+    }
+
+    private static final void tst(final int set, final int vector,
+                                     final int times, final String source,
+                                     final String expect) {
+     //   System.out.print("Set " + set + ", vector# " + vector + ": ");
+        byte[] input = new byte[source.length()];
+        for (int i = 0; i < input.length; i++)
+            input[i] = (byte)source.charAt(i);
+        for (int i = 0; i < times; i++)
+            hash.engineUpdate(input, 0, input.length);
+        tstResult(expect);
+    }
+
+    private static final void tstResult(final String expect) {
+        final String result = toHex(hash.engineDigest());
+        assertEquals(expect.toUpperCase(), result);
+    }
+
+    private static final String toHex(final byte[] bytes) {
+        StringBuffer buf = new StringBuffer(bytes.length * 2);
+        for (int i = 0; i < bytes.length; i++) {
+            if ((i & 3) == 0 && i != 0)
+               buf.append(' ');
+            buf.append(HEX.charAt((bytes[i] >> 4) & 0xF))
+               .append(HEX.charAt( bytes[i]       & 0xF));
+        }
+        return buf.toString();
+    }
+
+    private static final String HEX = "0123456789ABCDEF";
+}
diff --git a/components/security/src/test/java/org/limewire/security/certificate/CertificateVerifierTest.java b/components/security/src/test/java/org/limewire/security/certificate/CertificateVerifierTest.java
index dc8b5ff..e21fadd 100644
--- a/components/security/src/test/java/org/limewire/security/certificate/CertificateVerifierTest.java
+++ b/components/security/src/test/java/org/limewire/security/certificate/CertificateVerifierTest.java
@@ -7,8 +7,8 @@ import java.security.cert.Certificate;
 
 import junit.framework.Test;
 
-import org.limewire.http.httpclient.LimeHttpClient;
-import org.limewire.http.httpclient.SimpleLimeHttpClient;
+import org.apache.http.client.HttpClient;
+import org.apache.http.impl.client.DefaultHttpClient;
 import org.limewire.util.BaseTestCase;
 
 import com.google.inject.AbstractModule;
@@ -31,7 +31,7 @@ public class CertificateVerifierTest extends BaseTestCase {
         injector = Guice.createInjector(new LimeWireSecurityCertificateModule(), new AbstractModule() {
             @Override
             protected void configure() {
-                bind(LimeHttpClient.class).to(SimpleLimeHttpClient.class);
+                bind(HttpClient.class).to(DefaultHttpClient.class);
             }
         });
     }
diff --git a/components/security/src/test/java/org/limewire/security/certificate/CipherProviderTest.java b/components/security/src/test/java/org/limewire/security/certificate/CipherProviderTest.java
index 2c2811c..6de1695 100644
--- a/components/security/src/test/java/org/limewire/security/certificate/CipherProviderTest.java
+++ b/components/security/src/test/java/org/limewire/security/certificate/CipherProviderTest.java
@@ -10,8 +10,8 @@ import javax.crypto.KeyGenerator;
 
 import junit.framework.Test;
 
-import org.limewire.http.httpclient.LimeHttpClient;
-import org.limewire.http.httpclient.SimpleLimeHttpClient;
+import org.apache.http.client.HttpClient;
+import org.apache.http.impl.client.DefaultHttpClient;
 import org.limewire.security.LimeWireSecurityModule;
 import org.limewire.security.certificate.CipherProvider.CipherType;
 import org.limewire.security.certificate.CipherProvider.SignatureType;
@@ -94,7 +94,7 @@ public class CipherProviderTest extends BaseTestCase {
         Injector injector = Guice.createInjector(new LimeWireSecurityModule(), new AbstractModule() {
             @Override
             protected void configure() {
-                bind(LimeHttpClient.class).to(SimpleLimeHttpClient.class);
+                bind(HttpClient.class).to(DefaultHttpClient.class);
             }
         });
         cipherProvider = injector.getInstance(CipherProvider.class);
diff --git a/components/security/src/test/java/org/limewire/security/certificate/KeyStoreProviderTest.java b/components/security/src/test/java/org/limewire/security/certificate/KeyStoreProviderTest.java
index d413a71..32fddd3 100644
--- a/components/security/src/test/java/org/limewire/security/certificate/KeyStoreProviderTest.java
+++ b/components/security/src/test/java/org/limewire/security/certificate/KeyStoreProviderTest.java
@@ -11,8 +11,8 @@ import java.security.cert.X509Certificate;
 
 import junit.framework.Test;
 
-import org.limewire.http.httpclient.LimeHttpClient;
-import org.limewire.http.httpclient.SimpleLimeHttpClient;
+import org.apache.http.client.HttpClient;
+import org.apache.http.impl.client.DefaultHttpClient;
 import org.limewire.inject.Providers;
 import org.limewire.util.BaseTestCase;
 
@@ -30,7 +30,7 @@ public class KeyStoreProviderTest extends BaseTestCase {
     }
 
     public void testGetKeyStoreFromNetwork() throws IOException, KeyStoreException {
-        KeyStoreProviderImpl ksp = new KeyStoreProviderImpl(Providers.of((LimeHttpClient)new SimpleLimeHttpClient()));
+        KeyStoreProviderImpl ksp = new KeyStoreProviderImpl(Providers.of((HttpClient)new DefaultHttpClient()));
         KeyStore keystore = ksp.getKeyStoreFromNetwork();
         validateKeyStore(keystore);
     }
@@ -56,7 +56,7 @@ public class KeyStoreProviderTest extends BaseTestCase {
         File location = File.createTempFile("lwunit", "keystore");
         location.deleteOnExit();
 
-        KeyStoreProviderImpl ksp = new KeyStoreProviderImpl(Providers.of((LimeHttpClient)new SimpleLimeHttpClient()));
+        KeyStoreProviderImpl ksp = new KeyStoreProviderImpl(Providers.of((HttpClient)new DefaultHttpClient()));
         ksp.setKeyStoreLocation(location);
         ksp.setKeyStorePassword(getUnitKeyStorePassword());
         KeyStore keystore = ksp.getKeyStoreFromNetwork();
@@ -72,7 +72,7 @@ public class KeyStoreProviderTest extends BaseTestCase {
         location.delete();
         try {
             assertFalse(location.exists());
-            KeyStoreProviderImpl ksp = new KeyStoreProviderImpl(Providers.of((LimeHttpClient)new SimpleLimeHttpClient()));
+            KeyStoreProviderImpl ksp = new KeyStoreProviderImpl(Providers.of((HttpClient)new DefaultHttpClient()));
             ksp.setKeyStoreLocation(location);
             ksp.setKeyStorePassword(getUnitKeyStorePassword());
             assertFalse(ksp.isCached());
diff --git a/components/security/src/test/java/org/limewire/security/certificate/RootCAProviderTest.java b/components/security/src/test/java/org/limewire/security/certificate/RootCAProviderTest.java
index 8acab89..e7b4a05 100644
--- a/components/security/src/test/java/org/limewire/security/certificate/RootCAProviderTest.java
+++ b/components/security/src/test/java/org/limewire/security/certificate/RootCAProviderTest.java
@@ -2,8 +2,8 @@ package org.limewire.security.certificate;
 
 import junit.framework.Test;
 
-import org.limewire.http.httpclient.LimeHttpClient;
-import org.limewire.http.httpclient.SimpleLimeHttpClient;
+import org.apache.http.client.HttpClient;
+import org.apache.http.impl.client.DefaultHttpClient;
 import org.limewire.security.LimeWireSecurityModule;
 import org.limewire.util.BaseTestCase;
 
@@ -27,7 +27,7 @@ public class RootCAProviderTest extends BaseTestCase {
         Injector injector = Guice.createInjector(new LimeWireSecurityModule(), new AbstractModule() {
             @Override
             protected void configure() {
-                bind(LimeHttpClient.class).to(SimpleLimeHttpClient.class);
+                bind(HttpClient.class).to(DefaultHttpClient.class);
             }
         });
         rootCAProvider = injector.getInstance(RootCAProvider.class);
diff --git a/components/xmpp-api/src/main/java/org/limewire/core/api/friend/Friend.java b/components/xmpp-api/src/main/java/org/limewire/core/api/friend/Friend.java
index 63eb5b1..f31d1ed 100755
--- a/components/xmpp-api/src/main/java/org/limewire/core/api/friend/Friend.java
+++ b/components/xmpp-api/src/main/java/org/limewire/core/api/friend/Friend.java
@@ -38,4 +38,6 @@ public interface Friend {
      * permanent or not.
      */
     boolean isAnonymous();
+    
+    Network getNetwork();
 }
diff --git a/components/xmpp-api/src/main/java/org/limewire/core/api/friend/FriendPresence.java b/components/xmpp-api/src/main/java/org/limewire/core/api/friend/FriendPresence.java
index fd8981d..feb2b5a 100644
--- a/components/xmpp-api/src/main/java/org/limewire/core/api/friend/FriendPresence.java
+++ b/components/xmpp-api/src/main/java/org/limewire/core/api/friend/FriendPresence.java
@@ -24,4 +24,5 @@ public interface FriendPresence {
      */
     Address getPresenceAddress();
 
+    byte [] getAuthToken();
 }
diff --git a/components/xmpp-api/src/main/java/org/limewire/core/api/friend/Network.java b/components/xmpp-api/src/main/java/org/limewire/core/api/friend/Network.java
new file mode 100644
index 0000000..d43a06d
--- /dev/null
+++ b/components/xmpp-api/src/main/java/org/limewire/core/api/friend/Network.java
@@ -0,0 +1,6 @@
+package org.limewire.core.api.friend;
+
+public interface Network {
+    public String getMyID();    
+    public String getNetworkName();
+}
diff --git a/components/xmpp-api/src/main/java/org/limewire/xmpp/api/client/LimePresence.java b/components/xmpp-api/src/main/java/org/limewire/xmpp/api/client/LimePresence.java
index ea87091..9e85cee 100644
--- a/components/xmpp-api/src/main/java/org/limewire/xmpp/api/client/LimePresence.java
+++ b/components/xmpp-api/src/main/java/org/limewire/xmpp/api/client/LimePresence.java
@@ -14,8 +14,6 @@ public interface LimePresence extends Presence, FriendPresence {
      */
     public void offerFile(FileMetaData file);
 
-    byte [] getAuthToken();
-    
     /** Returns the containing user. */
     User getUser();
 
diff --git a/components/xmpp-api/src/main/java/org/limewire/xmpp/api/client/User.java b/components/xmpp-api/src/main/java/org/limewire/xmpp/api/client/User.java
index f821e57..54db902 100644
--- a/components/xmpp-api/src/main/java/org/limewire/xmpp/api/client/User.java
+++ b/components/xmpp-api/src/main/java/org/limewire/xmpp/api/client/User.java
@@ -18,14 +18,6 @@ public interface User extends Friend {
     public void addPresenceListener(PresenceListener presenceListener);
     
     /**
-     * Provides an indication of whether the supplied String (assumed to be a Presence jid)
-     * belongs to this user
-     * @param jid
-     * @return true if the the jid belongs to this user, otherwise false
-     */
-    public boolean jidBelongsTo(String jid);
-
-    /**
      * @return an unmodifiable map of all <code>Presence</code>s for this <code>User</code>. 
      * Keys are fully qualified jids of the form <code>"user@domain.com/resourceXYZ"</code>
      */
diff --git a/components/xmpp-api/src/main/java/org/limewire/xmpp/api/client/XMPPConnection.java b/components/xmpp-api/src/main/java/org/limewire/xmpp/api/client/XMPPConnection.java
index 4b1e73d..3eaa88f 100644
--- a/components/xmpp-api/src/main/java/org/limewire/xmpp/api/client/XMPPConnection.java
+++ b/components/xmpp-api/src/main/java/org/limewire/xmpp/api/client/XMPPConnection.java
@@ -39,4 +39,12 @@ public interface XMPPConnection {
      * @throws XMPPException
      */
     public void removeUser(String id) throws XMPPException;
+
+    /**
+     * Returns the user belonging to <code>id</code>. <code>id</code>
+     * is the user's email address.
+     * 
+     * @return null if id is not registered on this connection
+     */
+    public User getUser(String id);
 }
diff --git a/components/xmpp-api/src/main/java/org/limewire/xmpp/api/client/XMPPConnectionConfiguration.java b/components/xmpp-api/src/main/java/org/limewire/xmpp/api/client/XMPPConnectionConfiguration.java
index b735b69..55d3595 100644
--- a/components/xmpp-api/src/main/java/org/limewire/xmpp/api/client/XMPPConnectionConfiguration.java
+++ b/components/xmpp-api/src/main/java/org/limewire/xmpp/api/client/XMPPConnectionConfiguration.java
@@ -1,11 +1,12 @@
 package org.limewire.xmpp.api.client;
 
+import org.limewire.core.api.friend.Network;
 import org.limewire.listener.EventListener;
 
 /**
  * Allows the xmpp service user to provide configuration for xmpp login.
  */
-public interface XMPPConnectionConfiguration {
+public interface XMPPConnectionConfiguration extends Network {
     public boolean isDebugEnabled();
     public String getUsername();
     public void setUsername(String username);
@@ -18,4 +19,5 @@ public interface XMPPConnectionConfiguration {
     public void setAutoLogin(boolean autoLogin);
     public EventListener<RosterEvent> getRosterListener();
     public XMPPErrorListener getErrorListener();
+    public String getResource();
 }
diff --git a/components/xmpp/build.xml b/components/xmpp/build.xml
index e7652a0..a557b32 100644
--- a/components/xmpp/build.xml
+++ b/components/xmpp/build.xml
@@ -11,16 +11,18 @@
     <import file="../common/build.xml"/>
     <import file="../io/build.xml"/>
     <import file="../net/build.xml"/>
+    <import file="../security/build.xml"/>
     <import file="../xmpp-api/build.xml"/>
     
-    <target name="initialize" depends="lw-common.initialize, lw-xmpp-api.initialize, lw-io.initialize, lw-net.initialize" unless="initialized.xmpp">
+    <target name="initialize" depends="lw-common.initialize, lw-xmpp-api.initialize, lw-io.initialize, lw-net.initialize, lw-security.initialize" unless="initialized.xmpp">
         <do.setup-properties component="xmpp">
 			<src-classpath>
                 <pathelement location="${limewire.lib.jars}/commons-codec-1.3.jar"/>
                 <path refid="build.limewire.components.common.buildpath"/>
                 <path refid="build.limewire.components.net.buildpath"/>
-                <path refid="build.limewire.components.xmpp-api.buildpath"/>
-				<pathelement location="${limewire.lib.jars}/smack.jar"/>
+                <path refid="build.limewire.components.security.buildpath"/>
+                <path refid="build.limewire.components.xmpp-api.buildpath"/>
+				<pathelement location="${limewire.lib.jars}/smack.jar"/>
 				<pathelement location="${limewire.lib.jars}/smackx.jar"/>
             </src-classpath>
             <build-tests-classpath>
@@ -36,11 +38,11 @@
 	    <do.clean component="xmpp"/>
 	</target>
     
-    <target name="compile" depends="lw-common.compile, lw-xmpp-api.compile, lw-io.compile, lw-net.compile">
+    <target name="compile" depends="lw-common.compile, lw-xmpp-api.compile, lw-io.compile, lw-net.compile, lw-security.compile">
     	<do.compile component="xmpp"/>
     </target>
 	
-	<target name="compile-src" depends="lw-common.compile-src, lw-xmpp-api.compile-src, lw-io.compile-src, lw-net.compile-src">
+	<target name="compile-src" depends="lw-common.compile-src, lw-xmpp-api.compile-src, lw-io.compile-src, lw-net.compile-src, lw-security.compile-src">
 	    <do.compile-src component="xmpp" excludes="**/server/**"/>
 	</target>
     
diff --git a/components/xmpp/src/main/java/org/limewire/xmpp/client/LimeWireXMPPModule.java b/components/xmpp/src/main/java/org/limewire/xmpp/client/LimeWireXMPPModule.java
index afbb152..e60195d 100644
--- a/components/xmpp/src/main/java/org/limewire/xmpp/client/LimeWireXMPPModule.java
+++ b/components/xmpp/src/main/java/org/limewire/xmpp/client/LimeWireXMPPModule.java
@@ -9,7 +9,10 @@ import org.limewire.xmpp.api.client.LibraryChangedEvent;
 import org.limewire.xmpp.api.client.RosterEvent;
 import org.limewire.xmpp.api.client.XMPPConnectionEvent;
 import org.limewire.xmpp.api.client.XMPPService;
+import org.limewire.xmpp.client.impl.XMPPAddressResolver;
+import org.limewire.xmpp.client.impl.XMPPAddressSerializer;
 import org.limewire.xmpp.client.impl.XMPPServiceImpl;
+import org.limewire.xmpp.client.impl.XMPPAuthenticator;
 
 import com.google.inject.AbstractModule;
 import com.google.inject.TypeLiteral;
@@ -34,5 +37,12 @@ public class LimeWireXMPPModule extends AbstractModule {
         EventMulticaster<XMPPConnectionEvent> connectionMulticaster = new EventMulticasterImpl<XMPPConnectionEvent>();
         bind(new TypeLiteral<EventListener<XMPPConnectionEvent>>(){}).toInstance(connectionMulticaster);
         bind(new TypeLiteral<ListenerSupport<XMPPConnectionEvent>>(){}).toInstance(connectionMulticaster);
+        
+        // bind egearly, so it registers itself with SocketsManager
+        bind(XMPPAddressResolver.class).asEagerSingleton();
+        // dito
+        bind(XMPPAddressSerializer.class).asEagerSingleton();
+        
+        bind(XMPPAuthenticator.class).asEagerSingleton();
     }
 }
diff --git a/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/LimePresenceImpl.java b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/LimePresenceImpl.java
index 034f92d..353fa19 100644
--- a/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/LimePresenceImpl.java
+++ b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/LimePresenceImpl.java
@@ -1,5 +1,7 @@
 package org.limewire.xmpp.client.impl;
 
+import java.util.concurrent.atomic.AtomicReference;
+
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.jivesoftware.smack.PacketCollector;
@@ -26,16 +28,19 @@ public class LimePresenceImpl extends PresenceImpl implements LimePresence {
 
     private static final Log LOG = LogFactory.getLog(LimePresenceImpl.class);
 
-    private Address address;
-    private byte [] authToken;
+    private AtomicReference<Address> address;
+    private AtomicReference<byte []> authToken;
 
     LimePresenceImpl(Presence presence, XMPPConnection connection, User user) {
         super(presence, connection, user);
+        address = new AtomicReference<Address>();
+        authToken = new AtomicReference<byte []>();
     }
 
     LimePresenceImpl(Presence presence, XMPPConnection connection, LimePresence limePresence) {
         super(presence, connection, limePresence.getUser());
-        address = Objects.nonNull(limePresence, "limePresence").getPresenceAddress();
+        address = new AtomicReference<Address>(Objects.nonNull(limePresence, "limePresence").getPresenceAddress());
+        authToken = new AtomicReference<byte []>();
     }
 
     @Override
@@ -45,7 +50,7 @@ public class LimePresenceImpl extends PresenceImpl implements LimePresence {
 
     @Override
     public Address getPresenceAddress() {
-        return address;
+        return address.get();
     }
 
     @Override
@@ -54,15 +59,15 @@ public class LimePresenceImpl extends PresenceImpl implements LimePresence {
     }
 
     public void setPresenceAddress(Address address) {
-        this.address = address;
+        this.address.set(address);
     }
 
     public byte [] getAuthToken() {
-        return authToken;
+        return authToken.get();
     }
 
     public void setAuthToken(byte [] authToken) {
-        this.authToken = authToken;
+        this.authToken.set(authToken);
     }
 
     void subscribeAndWaitForAddress() throws InvalidDataException {
@@ -80,7 +85,7 @@ public class LimePresenceImpl extends PresenceImpl implements LimePresence {
         if (response instanceof ExceptionalAddressIQ) {
             throw new InvalidDataException(((ExceptionalAddressIQ)response).getException());
         }
-        address = response.getAddress();
+        address.set(response.getAddress());
         addressCollector.cancel();
 
         final AuthTokenIQ authTokenIQ = new AuthTokenIQ();
@@ -94,7 +99,7 @@ public class LimePresenceImpl extends PresenceImpl implements LimePresence {
         if (authTokenResponse instanceof AuthTokenIQProvider.ExceptionalAuthTokenIQ) {
             throw new InvalidDataException(((AuthTokenIQProvider.ExceptionalAuthTokenIQ)authTokenResponse).getException());
         }
-        authToken = authTokenResponse.getAuthToken();
+        authToken.set(authTokenResponse.getAuthToken());
         authTokenCollector.cancel();
     }
 
diff --git a/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/UserImpl.java b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/UserImpl.java
index b8fbf6b..48db65f 100644
--- a/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/UserImpl.java
+++ b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/UserImpl.java
@@ -15,6 +15,7 @@ import org.limewire.util.StringUtils;
 import org.limewire.xmpp.api.client.Presence;
 import org.limewire.xmpp.api.client.PresenceListener;
 import org.limewire.xmpp.api.client.User;
+import org.limewire.core.api.friend.Network;
 
 public class UserImpl implements User {
     private static final Log LOG = LogFactory.getLog(UserImpl.class);
@@ -23,9 +24,11 @@ public class UserImpl implements User {
     private AtomicReference<RosterEntry> rosterEntry;
     private final ConcurrentHashMap<String, Presence> presences;
     private final CopyOnWriteArrayList<PresenceListener> presenceListeners;
+    private final Network network;
 
-    UserImpl(String id, RosterEntry rosterEntry) {
+    UserImpl(String id, RosterEntry rosterEntry, Network network) {
         this.id = id;
+        this.network = network;
         this.rosterEntry = new AtomicReference<RosterEntry>(rosterEntry);
         this.presences = new ConcurrentHashMap<String, Presence>(); 
         this.presenceListeners = new CopyOnWriteArrayList<PresenceListener>();
@@ -118,12 +121,11 @@ public class UserImpl implements User {
         firePresenceListeners(updatedPresence);
     }
 
-    @Override
-    public boolean jidBelongsTo(String jid) {
-        return presences.containsKey(jid);
-    }
-    
     Presence getPresence(String jid) {
         return presences.get(jid);
     }
+
+    public Network getNetwork() {
+        return network;
+    }
 }
diff --git a/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPAddress.java b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPAddress.java
new file mode 100644
index 0000000..b909727
--- /dev/null
+++ b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPAddress.java
@@ -0,0 +1,29 @@
+package org.limewire.xmpp.client.impl;
+
+import org.limewire.io.PermanentAddress;
+import org.limewire.util.Objects;
+
+/**
+ * Provides a permanent address for a full jabber id including
+ * its resource. 
+ */
+public class XMPPAddress implements PermanentAddress {
+
+    private final String id;
+
+    /**
+     * 
+     * @param id the full jabber id including resource
+     */
+    public XMPPAddress(String id) {
+        this.id = Objects.nonNull(id, "id");
+    }
+    
+    /**
+     * Returns the full jabber id including resource. 
+     */
+    public String getId() {
+        return id;
+    }
+            
+}
diff --git a/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPAddressResolver.java b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPAddressResolver.java
new file mode 100644
index 0000000..6db4ebe
--- /dev/null
+++ b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPAddressResolver.java
@@ -0,0 +1,101 @@
+package org.limewire.xmpp.client.impl;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map.Entry;
+
+import org.limewire.core.api.friend.FriendPresence;
+import org.limewire.io.Address;
+import org.limewire.logging.Log;
+import org.limewire.logging.LogFactory;
+import org.limewire.net.SocketsManager;
+import org.limewire.net.address.AddressResolutionObserver;
+import org.limewire.net.address.AddressResolver;
+import org.limewire.xmpp.api.client.Presence;
+import org.limewire.xmpp.api.client.User;
+import org.limewire.xmpp.api.client.XMPPConnection;
+import org.limewire.xmpp.api.client.XMPPService;
+
+import com.google.inject.Inject;
+import com.google.inject.Singleton;
+
+@Singleton
+public class XMPPAddressResolver implements AddressResolver {
+
+    private final static Log LOG = LogFactory.getLog(XMPPAddressResolver.class);
+    
+    private final XMPPService xmppService;
+
+    @Inject
+    public XMPPAddressResolver(XMPPService xmppService) {
+        this.xmppService = xmppService;
+    }
+    
+    @Inject
+    public void register(SocketsManager socketsManager) {
+        socketsManager.registerResolver(this);
+    }
+    
+    @Override
+    public boolean canResolve(Address address) {
+        if (address instanceof XMPPAddress) {
+            XMPPAddress friendIdAddress = (XMPPAddress)address;
+            return !getResolvedAddresses(friendIdAddress).isEmpty();
+        }
+        return false;
+    }
+    
+    private List<Address> getResolvedAddresses(XMPPAddress address) {
+        String id = address.getId();
+        List<Address> addresses = new ArrayList<Address>(1);
+        for (XMPPConnection connection : xmppService.getConnections()) {
+            User user = connection.getUser(id);
+            if (user != null) {
+                for (Entry<String, Presence> entry : user.getPresences().entrySet()) {
+                    Address resolvedAddress = getMatchingAddress(address, entry.getKey(), entry.getValue());
+                    if (resolvedAddress != null) {
+                        addresses.add(resolvedAddress);
+                    }
+                }
+            }
+        }
+        return addresses;
+    }
+
+    /**
+     * Returns address of presence if presence is {@link FriendPresence} and the resource
+     * id matches the one in <code>address</code> and the address is available in
+     * the presence.
+     */
+    private Address getMatchingAddress(XMPPAddress address, String resourceId, Presence presence) {
+        if (!(presence instanceof FriendPresence)) {
+            return  null;
+        }
+        String originalId = address.getId();
+        int slash = originalId.indexOf('/');
+        if (slash == -1) {
+            LOG.debugf("no slash in full id: {0}", originalId);
+            return null;
+        }
+        int toOffset = Math.min(originalId.length(), slash + 10);
+        if (originalId.startsWith(resourceId, toOffset)) {
+            return ((FriendPresence)presence).getPresenceAddress();
+        }
+        return null;
+    }
+
+    @Override
+    public void resolve(Address address, int timeout, AddressResolutionObserver observer) {
+        if (address instanceof XMPPAddress) {
+            XMPPAddress xmppAddress = (XMPPAddress)address;
+            List<Address> resolvedAddresses = getResolvedAddresses(xmppAddress);
+            if (resolvedAddresses.isEmpty()) {
+                observer.handleIOException(new IOException("Could not be resolved"));
+            } else {
+                observer.resolved(resolvedAddresses.toArray(new Address[resolvedAddresses.size()]));
+            }
+        }
+    }
+
+}
diff --git a/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPAddressSerializer.java b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPAddressSerializer.java
new file mode 100644
index 0000000..32c30f5
--- /dev/null
+++ b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPAddressSerializer.java
@@ -0,0 +1,44 @@
+package org.limewire.xmpp.client.impl;
+
+import java.io.IOException;
+
+import org.limewire.io.Address;
+import org.limewire.net.address.AddressFactory;
+import org.limewire.net.address.AddressSerializer;
+import org.limewire.util.StringUtils;
+
+import com.google.inject.Singleton;
+
+/**
+ * Serializes and deserializes {@link XMPPAddress} objects.
+ */
+@Singleton
+public class XMPPAddressSerializer implements AddressSerializer {
+
+    @Override
+    public void register(AddressFactory factory) {
+        factory.addSerializer(this);
+    }
+    
+    @Override
+    public Class<? extends Address> getAddressClass() {
+        return XMPPAddress.class;
+    }
+
+    @Override
+    public String getAddressType() {
+        return "xmpp-address";
+    }
+    
+    @Override
+    public Address deserialize(byte[] serializedAddress) throws IOException {
+        return new XMPPAddress(StringUtils.getUTF8String(serializedAddress));
+    }
+
+    @Override
+    public byte[] serialize(Address address) throws IOException {
+        XMPPAddress xmppAddress = (XMPPAddress)address;
+        return StringUtils.toUTF8Bytes(xmppAddress.getId());
+    }
+
+}
diff --git a/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPAuthenticator.java b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPAuthenticator.java
new file mode 100644
index 0000000..9947762
--- /dev/null
+++ b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPAuthenticator.java
@@ -0,0 +1,58 @@
+package org.limewire.xmpp.client.impl;
+
+import java.security.SecureRandom;
+
+import org.apache.commons.codec.binary.Base64;
+import org.apache.http.auth.Credentials;
+import org.limewire.http.auth.Authenticator;
+import org.limewire.http.auth.AuthenticatorRegistry;
+import org.limewire.logging.Log;
+import org.limewire.logging.LogFactory;
+import org.limewire.security.SHA1;
+import org.limewire.util.StringUtils;
+
+import com.google.inject.Inject;
+import com.google.inject.Singleton;
+
+/**
+ * Handles authentication and creation of user passwords for the xmpp component.
+ * 
+ * The class is inherently stateless except for a per session random seed.
+ */
+@Singleton
+public class XMPPAuthenticator implements Authenticator {
+
+    private final static Log LOG = LogFactory.getLog(XMPPAuthenticator.class);
+    
+    /**
+     * Per session random seed.
+     */
+    private final byte[] seed = new SecureRandom().generateSeed(SHA1.HASH_LENGTH);
+    
+    @Override
+    @Inject
+    public void register(AuthenticatorRegistry registry) {
+        registry.addAuthenticator(this);
+    }
+
+    /**
+     * Returns an base 64 encoded auth token for <code>username</code>.
+     * 
+     * @return the ascii-encoded auth token
+     */
+    public String getAuthToken(String username) {
+        SHA1 sha1 = new SHA1();
+        byte[] hash = sha1.digest(StringUtils.toUTF8Bytes(username));
+        for (int i = 0; i < hash.length; i++) {
+            hash[i] = (byte)(hash[i] ^ seed[i]);
+        }
+        sha1.reset();
+        // digest again, to make the seed irreconstructible
+        return StringUtils.getASCIIString(Base64.encodeBase64(sha1.digest(hash)));
+    }
+
+    @Override
+    public boolean authenticate(Credentials credentials) {
+        return credentials.getPassword().equals(getAuthToken(credentials.getUserPrincipal().getName()));
+    }
+}
diff --git a/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPConnectionImpl.java b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPConnectionImpl.java
index 04ce08b..010158d 100644
--- a/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPConnectionImpl.java
+++ b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPConnectionImpl.java
@@ -42,7 +42,7 @@ import org.limewire.xmpp.client.impl.messages.filetransfer.FileTransferIQListene
 import org.limewire.xmpp.client.impl.messages.library.LibraryChangedIQ;
 import org.limewire.xmpp.client.impl.messages.library.LibraryChangedIQListener;
 
-//import com.limegroup.gnutella.BrowseHostReplyHandler;
+
 
 class XMPPConnectionImpl implements org.limewire.xmpp.api.client.XMPPConnection, EventListener<AddressEvent> {
     
@@ -62,18 +62,20 @@ class XMPPConnectionImpl implements org.limewire.xmpp.api.client.XMPPConnection,
     protected AuthTokenIQListener authTokenIQListener;
     protected LibraryChangedIQListener libChangedIQListener;
     protected volatile AddressEvent lastEvent;
+    private final XMPPAuthenticator authenticator;
 
     XMPPConnectionImpl(XMPPConnectionConfiguration configuration,
                        EventListener<RosterEvent> rosterListener,
                        EventListener<FileOfferEvent> fileOfferListener,
                        EventListener<LibraryChangedEvent> libraryChangedEventEventListener,
                        EventListener<XMPPConnectionEvent> connectionListener,
-                       AddressFactory addressFactory) {
+                       AddressFactory addressFactory, XMPPAuthenticator authenticator) {
         this.configuration = configuration;
         this.fileOfferListener = fileOfferListener;
         this.libraryChangedEventEventListener = libraryChangedEventEventListener;
         this.connectionListener = connectionListener;
         this.addressFactory = addressFactory;
+        this.authenticator = authenticator;
         this.rosterListeners = new EventListenerList<RosterEvent>();
         if(configuration.getRosterListener() != null) {
             this.rosterListeners.addListener(configuration.getRosterListener());
@@ -106,8 +108,9 @@ class XMPPConnectionImpl implements org.limewire.xmpp.api.client.XMPPConnection,
                 LOG.info("connecting to " + configuration.getServiceName() + " at " + configuration.getHost() + ":" + configuration.getPort() + "...");
                 connection.connect();
                 LOG.info("connected.");
-                LOG.info("logging in " + configuration.getUsername() + "...");
-                connection.login(configuration.getUsername(), configuration.getPassword());
+                if (LOG.isInfoEnabled())
+                    LOG.infof("logging in " + configuration.getUsername() + " with resource: " + configuration.getResource());
+                connection.login(configuration.getUsername(), configuration.getPassword(), configuration.getResource());
                 LOG.info("logged in.");
                 connectionListener.handleEvent(new XMPPConnectionEvent(configuration.getUsername(), ConnectionEvent.LOGIN));
             } catch (org.jivesoftware.smack.XMPPException e) {
@@ -125,7 +128,9 @@ class XMPPConnectionImpl implements org.limewire.xmpp.api.client.XMPPConnection,
                 addressIQListener = null;
                 fileTransferIQListener = null;
                 authTokenIQListener = null;
-                users.clear();
+                synchronized (users) {
+                    users.clear();
+                }
                 LOG.info("disconnected.");
             }
         }
@@ -190,7 +195,7 @@ class XMPPConnectionImpl implements org.limewire.xmpp.api.client.XMPPConnection,
                     fileTransferIQListener = new FileTransferIQListener(fileOfferListener);
                     connection.addPacketListener(fileTransferIQListener, fileTransferIQListener.getPacketFilter());  
                     
-                    authTokenIQListener = new AuthTokenIQListener(connection);
+                    authTokenIQListener = new AuthTokenIQListener(connection, authenticator);
                     XMPPConnectionImpl.this.rosterListeners.addListener(authTokenIQListener.getRosterListener());
                     connection.addPacketListener(authTokenIQListener, authTokenIQListener.getPacketFilter());
 
@@ -213,7 +218,7 @@ class XMPPConnectionImpl implements org.limewire.xmpp.api.client.XMPPConnection,
                 Roster roster = connection.getRoster();
                 for(String id : addedIds) {             
                     RosterEntry rosterEntry = roster.getEntry(id);
-                    UserImpl user = new UserImpl(id, rosterEntry);
+                    UserImpl user = new UserImpl(id, rosterEntry, configuration);
                     if(LOG.isDebugEnabled()) {
                         LOG.debug("user " + user + " added");
                     }
@@ -232,7 +237,7 @@ class XMPPConnectionImpl implements org.limewire.xmpp.api.client.XMPPConnection,
                     UserImpl user = users.get(id);
                     if(user == null) {
                         // should never happen ?
-                        user = new UserImpl(id, rosterEntry);
+                        user = new UserImpl(id, rosterEntry, configuration);
                         users.put(id, user);
                     } else {
                         user.setRosterEntry(rosterEntry);
@@ -408,4 +413,11 @@ class XMPPConnectionImpl implements org.limewire.xmpp.api.client.XMPPConnection,
             }
         }
     }
+
+    @Override
+    public User getUser(String id) {
+        synchronized (users) { 
+            return users.get(id);
+        }
+    }
 }
diff --git a/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPServiceImpl.java b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPServiceImpl.java
index cdb3008..a9b01b2 100644
--- a/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPServiceImpl.java
+++ b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/XMPPServiceImpl.java
@@ -43,6 +43,7 @@ public class XMPPServiceImpl implements Service, XMPPService, EventListener<Addr
     private XMPPErrorListener errorListener;
     private Provider<EventListener<XMPPConnectionEvent>> connectionListener;
     private AddressEvent lastEvent;
+    private final XMPPAuthenticator authenticator;
 
     @Inject
     XMPPServiceImpl(Provider<List<XMPPConnectionConfiguration>> configurations,
@@ -50,13 +51,14 @@ public class XMPPServiceImpl implements Service, XMPPService, EventListener<Addr
                     Provider<EventListener<FileOfferEvent>> fileOfferListener,
                     Provider<EventListener<LibraryChangedEvent>> libraryChangedListener,
                     Provider<EventListener<XMPPConnectionEvent>> connectionListener,
-                    AddressFactory addressFactory) {
+                    AddressFactory addressFactory, XMPPAuthenticator authenticator) {
         this.configurations = configurations;
         this.rosterListener = rosterListener;
         this.fileOfferListener = fileOfferListener;
         this.libraryChangedListener = libraryChangedListener;
         this.connectionListener = connectionListener;
         this.addressFactory = addressFactory;
+        this.authenticator = authenticator;
         this.connections = new CopyOnWriteArrayList<XMPPConnectionImpl>();
     }
     
@@ -134,7 +136,7 @@ public class XMPPServiceImpl implements Service, XMPPService, EventListener<Addr
     public void addConnectionConfiguration(XMPPConnectionConfiguration configuration) {
         synchronized (this) {
             XMPPConnectionImpl connection = new XMPPConnectionImpl(configuration, rosterListener.get(),
-                    fileOfferListener.get(), libraryChangedListener.get(), connectionListener.get(), addressFactory);
+                    fileOfferListener.get(), libraryChangedListener.get(), connectionListener.get(), addressFactory, authenticator);
             connection.initialize();
             connections.add(connection);
             if(lastEvent != null) {
diff --git a/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/messages/address/AddressIQListener.java b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/messages/address/AddressIQListener.java
index edd8ad5..7b69d0a 100644
--- a/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/messages/address/AddressIQListener.java
+++ b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/messages/address/AddressIQListener.java
@@ -1,5 +1,11 @@
 package org.limewire.xmpp.client.impl.messages.address;
 
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
 import org.jivesoftware.smack.PacketListener;
 import org.jivesoftware.smack.XMPPConnection;
 import org.jivesoftware.smack.filter.PacketFilter;
@@ -14,17 +20,11 @@ import org.limewire.net.address.AddressFactory;
 import org.limewire.xmpp.api.client.LimePresence;
 import org.limewire.xmpp.api.client.Presence;
 import org.limewire.xmpp.api.client.PresenceListener;
-import org.limewire.xmpp.api.client.User;
 import org.limewire.xmpp.api.client.RosterEvent;
+import org.limewire.xmpp.api.client.User;
 import org.limewire.xmpp.client.impl.LimePresenceImpl;
 import org.xmlpull.v1.XmlPullParserException;
 
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-
 public class AddressIQListener implements PacketListener {
     private static final Log LOG = LogFactory.getLog(AddressIQListener.class);
 
@@ -92,10 +92,12 @@ public class AddressIQListener implements PacketListener {
         synchronized (this) {
             LimePresenceImpl presence = limePresences.get(iq.getFrom());
             if(presence != null) {
-                if(LOG.isDebugEnabled()) {
-                    LOG.debug("updating address on presence " + presence.getJID() + " to " + address);
+                if(iq.getAddress() != null) {
+                    if(LOG.isDebugEnabled()) {
+                        LOG.debug("updating address on presence " + presence.getJID() + " to " + iq.getAddress());
+                    }
+                    presence.setPresenceAddress(iq.getAddress());
                 }
-                presence.setPresenceAddress(iq.getAddress());
             }
         }
     }
diff --git a/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/messages/authtoken/AuthTokenIQListener.java b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/messages/authtoken/AuthTokenIQListener.java
index f74fab2..e1e44aa 100644
--- a/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/messages/authtoken/AuthTokenIQListener.java
+++ b/components/xmpp/src/main/java/org/limewire/xmpp/client/impl/messages/authtoken/AuthTokenIQListener.java
@@ -11,6 +11,7 @@ import org.jivesoftware.smack.XMPPConnection;
 import org.jivesoftware.smack.filter.PacketFilter;
 import org.jivesoftware.smack.packet.IQ;
 import org.jivesoftware.smack.packet.Packet;
+import org.jivesoftware.smack.util.StringUtils;
 import org.limewire.listener.EventListener;
 import org.limewire.logging.Log;
 import org.limewire.logging.LogFactory;
@@ -20,21 +21,22 @@ import org.limewire.xmpp.api.client.PresenceListener;
 import org.limewire.xmpp.api.client.RosterEvent;
 import org.limewire.xmpp.api.client.User;
 import org.limewire.xmpp.client.impl.LimePresenceImpl;
+import org.limewire.xmpp.client.impl.XMPPAuthenticator;
 import org.xmlpull.v1.XmlPullParserException;
 
 public class AuthTokenIQListener implements PacketListener {
     private static final Log LOG = LogFactory.getLog(AuthTokenIQListener.class);
 
     private final XMPPConnection connection;
-    //private final AuthTokenProvider provider;
+    private final XMPPAuthenticator userStore;
      
     private final Map<String, LimePresenceImpl> limePresences = new HashMap<String, LimePresenceImpl>();
     private final RosterEventHandler rosterEventHandler;
 
-    public AuthTokenIQListener(XMPPConnection connection
-                             /*, AuthTokenProvider provider*/) {
+    public AuthTokenIQListener(XMPPConnection connection,
+            XMPPAuthenticator authenticator) {
         this.connection = connection;
-        //this.provider = provider;
+        this.userStore = authenticator;
         this.rosterEventHandler = new RosterEventHandler();
     }
 
@@ -77,14 +79,16 @@ public class AuthTokenIQListener implements PacketListener {
         synchronized (this) {
             LimePresenceImpl presence = limePresences.get(iq.getFrom());
             if(presence != null) {
-                if(LOG.isDebugEnabled()) {
-                    try {
-                        LOG.debug("updating auth token on presence " + presence.getJID() + " to " + new String(Base64.encodeBase64(iq.getAuthToken()), "UTF-8"));
-                    } catch (UnsupportedEncodingException e) {
-                        // TODO
+                if(iq.getAuthToken() != null) {
+                    if(LOG.isDebugEnabled()) {
+                        try {
+                            LOG.debug("updating auth token on presence " + presence.getJID() + " to " + new String(Base64.encodeBase64(iq.getAuthToken()), "UTF-8"));
+                        } catch (UnsupportedEncodingException e) {
+                            LOG.error(e.getMessage(), e);
+                        }
                     }
+                    presence.setAuthToken(iq.getAuthToken());
                 }
-                presence.setAuthToken(iq.getAuthToken());
             }
         }
     }
@@ -97,13 +101,17 @@ public class AuthTokenIQListener implements PacketListener {
     }
 
     private void sendResult(AuthTokenIQ packet) {
-        byte [] authToken = packet.getFrom().getBytes(); // provider.getAuthToken(packet.getFrom())
-        AuthTokenIQ queryResult = new AuthTokenIQ(authToken);
-        queryResult.setTo(packet.getFrom());
-        queryResult.setFrom(packet.getTo());
-        queryResult.setPacketID(packet.getPacketID());
-        queryResult.setType(IQ.Type.RESULT);
-        connection.sendPacket(queryResult);
+        try {
+            byte [] authToken = userStore.getAuthToken(StringUtils.parseBareAddress(packet.getFrom())).getBytes("UTF-8");
+            AuthTokenIQ queryResult = new AuthTokenIQ(authToken);
+            queryResult.setTo(packet.getFrom());
+            queryResult.setFrom(packet.getTo());
+            queryResult.setPacketID(packet.getPacketID());
+            queryResult.setType(IQ.Type.RESULT);
+            connection.sendPacket(queryResult);
+        } catch (UnsupportedEncodingException e) {
+            LOG.error(e.getMessage(), e);
+        }        
     }
 
     public PacketFilter getPacketFilter() {
diff --git a/components/xmpp/src/test/java/org/limewire/xmpp/client/XMPPConnectionConfigurationMock.java b/components/xmpp/src/test/java/org/limewire/xmpp/client/XMPPConnectionConfigurationMock.java
index e73892b..0900feb 100644
--- a/components/xmpp/src/test/java/org/limewire/xmpp/client/XMPPConnectionConfigurationMock.java
+++ b/components/xmpp/src/test/java/org/limewire/xmpp/client/XMPPConnectionConfigurationMock.java
@@ -83,4 +83,17 @@ public class XMPPConnectionConfigurationMock implements XMPPConnectionConfigurat
             }
         };
     }
+
+    public String getMyID() {
+        return getUsername();
+    }
+
+    public String getNetworkName() {
+        return getServiceName();
+    }
+
+    @Override
+    public String getResource() {
+        return "LimeWire";
+    }
 }
diff --git a/core/com/limegroup/bittorrent/BTDataImpl.java b/core/com/limegroup/bittorrent/BTDataImpl.java
index a64b580..e5da000 100755
--- a/core/com/limegroup/bittorrent/BTDataImpl.java
+++ b/core/com/limegroup/bittorrent/BTDataImpl.java
@@ -16,6 +16,7 @@ import java.util.Set;
 import org.apache.commons.logging.Log;
 
 import org.limewire.logging.LogFactory;
+import org.limewire.security.SHA1;
 import org.limewire.service.ErrorService;
 import org.limewire.util.BEncoder;
 import org.limewire.util.CommonUtils;
@@ -23,7 +24,6 @@ import org.limewire.util.StringUtils;
 import org.limewire.util.URIUtils;
 
 import com.limegroup.gnutella.Constants;
-import com.limegroup.gnutella.security.SHA1;
 
 /**
  * Contains type safe representations of all understand information
diff --git a/core/com/limegroup/bittorrent/BTMetaInfoImpl.java b/core/com/limegroup/bittorrent/BTMetaInfoImpl.java
index 7c59d1f..312d1ef 100644
--- a/core/com/limegroup/bittorrent/BTMetaInfoImpl.java
+++ b/core/com/limegroup/bittorrent/BTMetaInfoImpl.java
@@ -15,6 +15,7 @@ import java.util.Set;
 import org.limewire.collection.IntervalSet;
 import org.limewire.collection.Range;
 import org.limewire.io.InvalidDataException;
+import org.limewire.security.SHA1;
 import org.limewire.util.URIUtils;
 
 import com.limegroup.bittorrent.disk.BlockRangeMap;
@@ -23,7 +24,6 @@ import com.limegroup.gnutella.URN;
 import com.limegroup.gnutella.downloader.serial.BTDiskManagerMemento;
 import com.limegroup.gnutella.downloader.serial.BTMetaInfoMemento;
 import com.limegroup.gnutella.downloader.serial.BTMetaInfoMementoImpl;
-import com.limegroup.gnutella.security.SHA1;
 
 /**
  * Contains information usually parsed in a .torrent file
diff --git a/core/com/limegroup/gnutella/BrowseHostHandler.java b/core/com/limegroup/gnutella/BrowseHostHandler.java
index 6acc856..961c4a1 100644
--- a/core/com/limegroup/gnutella/BrowseHostHandler.java
+++ b/core/com/limegroup/gnutella/BrowseHostHandler.java
@@ -3,12 +3,10 @@ package com.limegroup.gnutella;
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.net.InetSocketAddress;
 import java.net.Socket;
 import java.net.URISyntaxException;
 import java.net.UnknownHostException;
 import java.util.Locale;
-import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
@@ -18,29 +16,23 @@ import org.apache.http.Header;
 import org.apache.http.HttpException;
 import org.apache.http.HttpResponse;
 import org.apache.http.HttpVersion;
+import org.apache.http.auth.UsernamePasswordCredentials;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.params.HttpProtocolParams;
+import org.apache.http.protocol.HTTP;
 import org.limewire.core.api.browse.BrowseListener;
-import org.limewire.core.settings.ConnectionSettings;
+import org.limewire.core.api.friend.FriendPresence;
 import org.limewire.http.httpclient.SocketWrappingHttpClient;
-import org.limewire.io.Address;
 import org.limewire.io.Connectable;
 import org.limewire.io.ConnectableImpl;
 import org.limewire.io.IOUtils;
-import org.limewire.io.IpPort;
-import org.limewire.io.NetworkInstanceUtils;
 import org.limewire.io.NetworkUtils;
 import org.limewire.net.BlockingConnectObserver;
 import org.limewire.net.SocketsManager;
-import org.limewire.net.SocketsManager.ConnectType;
-import org.limewire.rudp.RUDPUtils;
-import org.limewire.service.ErrorService;
 import org.limewire.util.StringUtils;
 
 import com.google.inject.Provider;
 import com.google.inject.name.Named;
-import com.limegroup.gnutella.downloader.PushDownloadManager;
-import com.limegroup.gnutella.downloader.RemoteFileDescFactory;
 import com.limegroup.gnutella.http.HTTPHeaderName;
 import com.limegroup.gnutella.messages.BadPacketException;
 import com.limegroup.gnutella.messages.Message;
@@ -73,13 +65,9 @@ public class BrowseHostHandler {
 
     private static final long EXPIRE_TIME = 15000; // 15 seconds
 
-    private static final int SPECIAL_INDEX = 0;
-
     /** The GUID to be used for incoming QRs from the Browse Request. */
     private GUID _guid = null;
-    /** The GUID of the servent to send a Push to.  May be null if no push is needed. */
-    private GUID _serventID = null;
-    
+
     /** The total length of the http-reply. */
     private volatile long _replyLength = 0;    
     /** The current length of the reply. */
@@ -88,17 +76,13 @@ public class BrowseHostHandler {
     private volatile int _state = NOT_STARTED;    
     /** The time this state started. */
     private volatile long _stateStarted = 0;
-    
-    private final BrowseHostHandlerManager.BrowseHostCallback browseHostCallback;
+
     private final ActivityCallback activityCallback;
     private final SocketsManager socketsManager;
-    private final Provider<PushDownloadManager> pushDownloadManager;
     private final Provider<ReplyHandler> forMeReplyHandler;
 
     private final MessageFactory messageFactory;
-    private final RemoteFileDescFactory remoteFileDescFactory;
     private final Provider<SocketWrappingHttpClient> clientProvider;
-    private final NetworkInstanceUtils networkInstanceUtils;
     private final NetworkManager networkManager;
 
     private final PushEndpointFactory pushEndpointFactory;
@@ -111,40 +95,31 @@ public class BrowseHostHandler {
      * @param serventID May be null, non-null if I need to push
      * @param clientProvider used to make an HTTP client request over an *incoming* Socket
      */
-    BrowseHostHandler(GUID guid, GUID serventID,
-                      BrowseHostHandlerManager.BrowseHostCallback browseHostCallback,
+    BrowseHostHandler(GUID guid, 
                       ActivityCallback activityCallback, SocketsManager socketsManager,
-                      Provider<PushDownloadManager> pushDownloadManager,
                       @Named("forMeReplyHandler")Provider<ReplyHandler> forMeReplyHandler,
                       MessageFactory messageFactory,
-                      RemoteFileDescFactory remoteFileDescFactory,
                       Provider<SocketWrappingHttpClient> clientProvider, 
-                      NetworkInstanceUtils networkInstanceUtils,
                       NetworkManager networkManager,
                       PushEndpointFactory pushEndpointFactory) {
         _guid = guid;
-        _serventID = serventID;
-        this.browseHostCallback = browseHostCallback;
         this.activityCallback = activityCallback;
         this.socketsManager = socketsManager;
-        this.pushDownloadManager = pushDownloadManager;
         this.forMeReplyHandler = forMeReplyHandler;
         this.messageFactory = messageFactory;
-        this.remoteFileDescFactory = remoteFileDescFactory;
         this.clientProvider = clientProvider;
-        this.networkInstanceUtils = networkInstanceUtils;
         this.networkManager = networkManager;
         this.pushEndpointFactory = pushEndpointFactory;
     }
 
-    public void browseHost(Address address, BrowseListener browseListener) {
+    public void browseHost(FriendPresence friendPresence, BrowseListener browseListener) {
         setState(STARTED);
         setState(CONNECTING);
         BlockingConnectObserver connectObserver = new BlockingConnectObserver();
-        socketsManager.connect(address, (int)EXPIRE_TIME, connectObserver);
+        socketsManager.connect(friendPresence.getPresenceAddress(), (int)EXPIRE_TIME, connectObserver);
         try {
             Socket socket = connectObserver.getSocket(EXPIRE_TIME, TimeUnit.MILLISECONDS);
-            browseHost(socket);
+            browseHost(socket, friendPresence);
             browseListener.browseFinished(true);
             return;
         } catch (IOException ie) {
@@ -162,113 +137,6 @@ public class BrowseHostHandler {
         failed();
     }
     
-    /** 
-     * Browses the files on the specified host and port.
-     *
-     * @param host The IP and port of the host you want to browse, can be null for firewalled endpoint
-     * @param port The port of the host you want to browse.
-     * @param proxies the <tt>Set</tt> of push proxies to try
-     * @param canDoFWTransfer Whether or not this guy can do a firewall
-     * transfer.
-     */
-    public void browseHost(Connectable host, Set<? extends IpPort> proxies,
-                           boolean canDoFWTransfer) {
-        
-        if (host == null) {
-            // if host is null we can't do fwts
-            assert !canDoFWTransfer : "Can't do fwts without host";
-            try {
-                setState(STARTED);
-                browseFirewalledHost(createInvalidHost(), proxies, canDoFWTransfer);
-            } catch (UnknownHostException e) {
-                failed();
-                ErrorService.error(e, "Can't resolve host, should not happen");
-            }
-            return;
-        }
-        
-        // If this wasn't initially resolved, resolve it now...
-        if(host.getInetSocketAddress().isUnresolved()) {
-            try {
-                host = new ConnectableImpl(host.getAddress(), host.getPort(), host.isTLSCapable());
-            } catch(UnknownHostException uhe) {
-                failed();
-                return;
-            }
-        }
-        
-        if(!NetworkUtils.isValidIpPort(host)) {
-            failed();
-            return;
-        }
-        
-        LOG.trace("Starting browse protocol");
-        setState(STARTED);
-        
-        // flow of operation:
-        // 1. check if you need to push.
-        //   a. if so, just send a Push out.
-        //   b. if not, try direct connect.  If it doesn't work, send a push.
-        
-        if (canConnectDirectly(host) || isLocalBrowse(host)) {
-            try {
-                // simply try connecting and getting results....
-                setState(DIRECTLY_CONNECTING);
-                ConnectType type = host.isTLSCapable() ? ConnectType.TLS : ConnectType.PLAIN;
-                if(LOG.isDebugEnabled())
-                    LOG.debug("Attempting direct connection with type: " + type);
-                Socket socket = socketsManager.connect(new InetSocketAddress(host.getAddress(), host.getPort()),
-                                                DIRECT_CONNECT_TIME, type);
-                LOG.trace("Direct connect successful");
-                browseHost(socket);
-
-                // browse was successful
-                return;
-            } catch (IOException e) {
-                LOG.debug("Error during direct transfer", e);                
-            } catch (HttpException e) {
-                LOG.debug("Error during direct transfer", e);
-            } catch (URISyntaxException e) {
-                LOG.debug("Error during direct transfer", e);
-            } catch (InterruptedException e) {
-                LOG.debug("Error during direct transfer", e);
-            }
-        }
-        
-        // try pushing for fun.... (if we have the guid of the servent)
-        // fall back on push if possible
-        browseFirewalledHost(host, proxies, canDoFWTransfer);        
-    }
-    
-    /**
-     * Expects a non-null host, but host can be an invalid one.
-     */
-    private void browseFirewalledHost(Connectable host, Set<? extends IpPort> proxies,
-                           boolean canDoFWTransfer) {
-        
-        LOG.debug("Attempting push connection");
-
-        if ( _serventID == null ) {
-        	LOG.debug("No serventID, failing");
-        	failed();
-        } else {
-        	RemoteFileDesc fakeRFD = 
-        		remoteFileDescFactory.createRemoteFileDesc(host.getAddress(), host.getPort(), SPECIAL_INDEX, "fake",
-                    0, _serventID.bytes(), 0, false, 0, false, null, null, false, true, "", proxies,
-                    -1, canDoFWTransfer ? RUDPUtils.VERSION : 0, host.isTLSCapable()); 
-        	// register with the map so i get notified about a response to my
-        	// Push.
-            browseHostCallback.putInfo(_serventID, new PushRequestDetails(this));
-
-        	LOG.trace("Sending push request");
-        	setState(PUSHING);
-
-        	// send the Push after registering in case you get a response 
-        	// really quickly. 
-        	pushDownloadManager.get().sendPush(fakeRFD);
-        }
-    }
-    
     /**
      * Creates an invalid host for pushes.
      */
@@ -325,10 +193,10 @@ public class BrowseHostHandler {
         activityCallback.browseHostFailed(_guid);
     }
 
-    void browseHost(Socket socket) throws IOException, URISyntaxException, HttpException, InterruptedException {
+    void browseHost(Socket socket, FriendPresence friendPresence) throws IOException, URISyntaxException, HttpException, InterruptedException {
     	try {
             setState(EXCHANGING);
-            HttpResponse response = makeHTTPRequest(socket);
+            HttpResponse response = makeHTTPRequest(socket, friendPresence);
             validateResponse(response);
             readQueryRepliesFromStream(response);
         } finally {
@@ -337,19 +205,27 @@ public class BrowseHostHandler {
     	}
     }
 
-    private HttpResponse makeHTTPRequest(Socket socket) throws IOException, URISyntaxException, HttpException, InterruptedException {
+    private HttpResponse makeHTTPRequest(Socket socket, FriendPresence friendPresence) throws IOException, URISyntaxException, HttpException, InterruptedException {
         SocketWrappingHttpClient client = clientProvider.get();
         client.setSocket(socket);
+        if(!friendPresence.getFriend().isAnonymous()) {
+            String username = friendPresence.getFriend().getNetwork().getMyID();
+            String password = StringUtils.getUTF8String(friendPresence.getAuthToken());
+            client.setCredentials(new UsernamePasswordCredentials(username, password));
+        }
         // TODO
         // hardcoding to "http" should work;
         // socket has already been established
-        HttpGet get = new HttpGet("http://" + NetworkUtils.ip2string(socket.getInetAddress().getAddress()) + ":" + socket.getPort() + "/");
+        HttpGet get = new HttpGet("http://" +
+                NetworkUtils.ip2string(socket.getInetAddress().getAddress()) +
+                ":" + socket.getPort() +
+                getPath(friendPresence));
         HttpProtocolParams.setVersion(client.getParams(), HttpVersion.HTTP_1_1);
         
         get.addHeader(HTTPHeaderName.HOST.create(NetworkUtils.ip2string(socket.getInetAddress().getAddress()) + ":" + socket.getPort()));
         get.addHeader(HTTPHeaderName.USER_AGENT.create(LimeWireUtils.getVendor()));
         get.addHeader(HTTPHeaderName.ACCEPT.create(Constants.QUERYREPLY_MIME_TYPE));
-        get.addHeader(HTTPHeaderName.CONNECTION.create("close"));
+        get.addHeader(HTTPHeaderName.CONNECTION.create(HTTP.CONN_KEEP_ALIVE));
         
         if (!networkManager.acceptedIncomingConnection() && networkManager.canDoFWT()) {
             get.addHeader(HTTPHeaderName.FW_NODE_INFO.create(pushEndpointFactory.createForSelf()));
@@ -358,6 +234,14 @@ public class BrowseHostHandler {
         return client.execute(get);
     }
 
+    private String getPath(FriendPresence friendPresence) {
+        if(friendPresence.getFriend().isAnonymous()) {
+            return "/";
+        } else {
+            return "/friend/browse";  // TODO URLEncode
+        }
+    }
+
     private void validateResponse(HttpResponse response) throws IOException {
         if(response.getStatusLine().getStatusCode() < 200 || response.getStatusLine().getStatusCode() >= 300) {
             throw new IOException("HTTP status code = " + response.getStatusLine().getStatusCode()); // TODO create Exception class containing http status code
@@ -419,33 +303,13 @@ public class BrowseHostHandler {
         }
     }
 
-
-    /**
-	 * Returns true, if browse should be attempted by push download, either
-	 * because it is a private address or was unreachable in the past. Returns
-	 * false, otherwise or if <tt>host</tt> is the local address. 
-	 */
-    private boolean canConnectDirectly(IpPort host) {
-        return !ConnectionSettings.LOCAL_IS_PRIVATE.getValue() 
-        		|| !networkInstanceUtils.isPrivateAddress(host.getAddress())
-        		|| networkInstanceUtils.isMe(host.getAddress(), host.getPort());
-    }
-
-    /**
-     * Returns true, if the user attempts to browse in the local network by
-     * entering a host and port but not providing a <code>_serventID</code>.
-     * This will make a push impossible so a direct connect is attempted
-     * instead.
-     */
-    private boolean isLocalBrowse(IpPort host) {
-        return _serventID == null && networkInstanceUtils.isPrivateAddress(host.getAddress());
-    }
-
 	public static class PushRequestDetails {
+        private FriendPresence friendPresence;
         private BrowseHostHandler bhh;
         private long timeStamp;
         
-        public PushRequestDetails(BrowseHostHandler bhh) {
+        public PushRequestDetails(BrowseHostHandler bhh, FriendPresence friendPresence) {
+            this.friendPresence = friendPresence;
             timeStamp = System.currentTimeMillis();
             this.bhh = bhh;
         }
@@ -457,5 +321,9 @@ public class BrowseHostHandler {
         public BrowseHostHandler getBrowseHostHandler() {
             return bhh;
         }
+        
+        public FriendPresence getFriendPresence() {
+            return friendPresence;
+        }
     }
 }
diff --git a/core/com/limegroup/gnutella/BrowseHostHandlerManagerImpl.java b/core/com/limegroup/gnutella/BrowseHostHandlerManagerImpl.java
index 3a42812..bf30e7b 100755
--- a/core/com/limegroup/gnutella/BrowseHostHandlerManagerImpl.java
+++ b/core/com/limegroup/gnutella/BrowseHostHandlerManagerImpl.java
@@ -18,16 +18,13 @@ import org.limewire.lifecycle.Service;
 import org.limewire.net.SocketsManager;
 import org.limewire.service.ErrorService;
 import org.limewire.http.httpclient.SocketWrappingHttpClient;
-import org.limewire.io.NetworkInstanceUtils;
+import org.limewire.core.api.friend.FriendPresence;
 
 import com.google.inject.Inject;
 import com.google.inject.Provider;
 import com.google.inject.Singleton;
 import com.google.inject.name.Named;
-import com.limegroup.gnutella.BrowseHostHandler.PushRequestDetails;
-import com.limegroup.gnutella.downloader.PushDownloadManager;
 import com.limegroup.gnutella.downloader.PushedSocketHandlerRegistry;
-import com.limegroup.gnutella.downloader.RemoteFileDescFactory;
 import com.limegroup.gnutella.messages.MessageFactory;
 
 @Singleton
@@ -40,14 +37,11 @@ public class BrowseHostHandlerManagerImpl implements BrowseHostHandlerManager, S
 
     private final Provider<ActivityCallback> activityCallback;
     private final SocketsManager socketsManager;
-    private final Provider<PushDownloadManager> pushDownloadManager;
     private final Provider<ReplyHandler> forMeReplyHandler;
     private final ScheduledExecutorService backgroundExecutor;
-    private final RemoteFileDescFactory remoteFileDescFactory;
 
     private final MessageFactory messageFactory;
     private Provider<SocketWrappingHttpClient> clientProvider;
-    private final NetworkInstanceUtils networkInstanceUtils;
 
     private final NetworkManager networkManager;
 
@@ -58,23 +52,17 @@ public class BrowseHostHandlerManagerImpl implements BrowseHostHandlerManager, S
                                         ScheduledExecutorService backgroundExecutor,
                                         Provider<ActivityCallback> activityCallback,
                                         SocketsManager socketsManager,
-                                        Provider<PushDownloadManager> pushDownloadManager,
                                         @Named("forMeReplyHandler")Provider<ReplyHandler> forMeReplyHandler,
                                         MessageFactory messageFactory,
-                                        RemoteFileDescFactory remoteFileDescFactory,
                                         Provider<SocketWrappingHttpClient> clientProvider,
-                                        NetworkInstanceUtils networkInstanceUtils, 
                                         NetworkManager networkManager,
                                         PushEndpointFactory pushEndpointFactory) {
         this.activityCallback = activityCallback;
         this.socketsManager = socketsManager;
-        this.pushDownloadManager = pushDownloadManager;
         this.forMeReplyHandler = forMeReplyHandler;
         this.messageFactory = messageFactory;
         this.backgroundExecutor = backgroundExecutor;
-        this.remoteFileDescFactory = remoteFileDescFactory;
         this.clientProvider = clientProvider;
-        this.networkInstanceUtils = networkInstanceUtils;
         this.networkManager = networkManager;
         this.pushEndpointFactory = pushEndpointFactory;
     }
@@ -110,18 +98,8 @@ public class BrowseHostHandlerManagerImpl implements BrowseHostHandlerManager, S
      *      com.limegroup.gnutella.GUID, com.limegroup.gnutella.GUID)
      */
     public BrowseHostHandler createBrowseHostHandler(GUID guid, GUID serventID) {
-        return new BrowseHostHandler(guid, serventID, 
-                    new BrowseHostCallback() {
-                        public void putInfo(GUID serventId, PushRequestDetails details) {
-                            synchronized(_pushedHosts) {
-                                // TODO this can only handle one push request at a time?
-                                // TODO second request overwrites first?
-                                _pushedHosts.put(serventId, details);
-                            }                
-                        }
-                    },
-                activityCallback.get(), socketsManager, pushDownloadManager,
-                forMeReplyHandler, messageFactory, remoteFileDescFactory, clientProvider, networkInstanceUtils,
+        return new BrowseHostHandler(guid, activityCallback.get(), socketsManager,
+                forMeReplyHandler, messageFactory, clientProvider, 
                 networkManager, pushEndpointFactory);
     }
 
@@ -139,10 +117,11 @@ public class BrowseHostHandlerManagerImpl implements BrowseHostHandlerManager, S
         }
         if (prd != null) {
             final BrowseHostHandler browseHostHandler = prd.getBrowseHostHandler();
+            final FriendPresence friendPresence = prd.getFriendPresence();
             ThreadExecutor.startThread(new Runnable() {
                 public void run() {
                     try {
-                        browseHostHandler.browseHost(socket);
+                        browseHostHandler.browseHost(socket, friendPresence);
                     } catch (IOException e) {
                         LOG.debug("error while push transfer", e);
                         browseHostHandler.failed();
@@ -192,13 +171,8 @@ public class BrowseHostHandlerManagerImpl implements BrowseHostHandlerManager, S
 
     @Override
     public BrowseHostHandler createBrowseHostHandler(GUID browseGuid) {
-        return new BrowseHostHandler(browseGuid, null, 
-                new BrowseHostCallback() {
-                    public void putInfo(GUID serventId, PushRequestDetails details) {
-                    }
-                },
-                activityCallback.get(), socketsManager, pushDownloadManager,
-                forMeReplyHandler, messageFactory, remoteFileDescFactory, clientProvider, networkInstanceUtils,
+        return new BrowseHostHandler(browseGuid, activityCallback.get(), socketsManager,
+                forMeReplyHandler, messageFactory, clientProvider,
                 networkManager, pushEndpointFactory);
     }
 
diff --git a/core/com/limegroup/gnutella/HTTPAcceptor.java b/core/com/limegroup/gnutella/HTTPAcceptor.java
index c9992f3..03bf481 100644
--- a/core/com/limegroup/gnutella/HTTPAcceptor.java
+++ b/core/com/limegroup/gnutella/HTTPAcceptor.java
@@ -21,6 +21,7 @@ import org.apache.http.protocol.HttpContext;
 import org.limewire.core.settings.SharingSettings;
 import org.limewire.http.BasicHttpAcceptor;
 import org.limewire.http.HttpAcceptorListener;
+import org.limewire.http.auth.RequestAuthenticator;
 import org.limewire.http.reactor.HttpIOSession;
 import org.limewire.nio.NIODispatcher;
 import org.limewire.statistic.Statistic;
@@ -46,8 +47,12 @@ public class HTTPAcceptor extends BasicHttpAcceptor {
     private final NHttpRequestHandler notFoundHandler;
 
     @Inject
-    public HTTPAcceptor(TcpBandwidthStatistics tcpBandwidthStatistics) {
-        super(createDefaultParams(LimeWireUtils.getHttpServer(), Constants.TIMEOUT), SUPPORTED_METHODS);
+    public HTTPAcceptor(TcpBandwidthStatistics tcpBandwidthStatistics,
+                        RequestAuthenticator requestAuthenticator) {
+        super(createDefaultParams(LimeWireUtils.getHttpServer(),
+                Constants.TIMEOUT),
+                requestAuthenticator,
+                SUPPORTED_METHODS);
 
         this.notFoundHandler = new SimpleNHttpRequestHandler() {
             public ConsumingNHttpEntity entityRequest(HttpEntityEnclosingRequest request,
diff --git a/core/com/limegroup/gnutella/HTTPUploadManager.java b/core/com/limegroup/gnutella/HTTPUploadManager.java
index 89f02c1..f8fcf1e 100644
--- a/core/com/limegroup/gnutella/HTTPUploadManager.java
+++ b/core/com/limegroup/gnutella/HTTPUploadManager.java
@@ -46,6 +46,7 @@ import com.limegroup.gnutella.uploader.HTTPUploader;
 import com.limegroup.gnutella.uploader.HttpRequestHandlerFactory;
 import com.limegroup.gnutella.uploader.UploadSlotManager;
 import com.limegroup.gnutella.uploader.UploadType;
+import com.limegroup.gnutella.uploader.authentication.GnutellaFileListProvider;
 
 /**
  * Manages {@link HTTPUploader} objects that are created by
@@ -197,13 +198,17 @@ public class HTTPUploadManager implements FileLocker, BandwidthTracker,
     private final Provider<HTTPAcceptor> httpAcceptor;
     
     private final TcpBandwidthStatistics tcpBandwidthStatistics;
+
+    private final Provider<GnutellaFileListProvider> gnutellaFileListProvider;
     
     @Inject
     public HTTPUploadManager(UploadSlotManager slotManager,
             HttpRequestHandlerFactory httpRequestHandlerFactory,
             Provider<ContentManager> contentManager, Provider<HTTPAcceptor> httpAcceptor,
             Provider<FileManager> fileManager, Provider<ActivityCallback> activityCallback,
-            TcpBandwidthStatistics tcpBandwidthStatistics) {
+            TcpBandwidthStatistics tcpBandwidthStatistics,
+            Provider<GnutellaFileListProvider> gnutellaFileListProvider) {
+        this.gnutellaFileListProvider = gnutellaFileListProvider;
         this.slotManager = Objects.nonNull(slotManager, "slotManager");
         this.httpRequestHandlerFactory = httpRequestHandlerFactory;
         this.contentManager = contentManager;
@@ -241,7 +246,7 @@ public class HTTPUploadManager implements FileLocker, BandwidthTracker,
         httpAcceptor.get().addAcceptorListener(responseListener);
 
         // browse
-        httpAcceptor.get().registerHandler("/", httpRequestHandlerFactory.createBrowseRequestHandler());
+        httpAcceptor.get().registerHandler("/", httpRequestHandlerFactory.createBrowseRequestHandler(gnutellaFileListProvider.get(), false));
 
         // push-proxy requests
         NHttpRequestHandler pushProxyHandler = httpRequestHandlerFactory.createPushProxyRequestHandler();
@@ -249,7 +254,7 @@ public class HTTPUploadManager implements FileLocker, BandwidthTracker,
         httpAcceptor.get().registerHandler("/gnet/push-proxy", pushProxyHandler);
 
         // uploads
-        FileRequestHandler fileRequestHandler = httpRequestHandlerFactory.createFileRequestHandler();
+        FileRequestHandler fileRequestHandler = httpRequestHandlerFactory.createFileRequestHandler(gnutellaFileListProvider.get(), false);
         httpAcceptor.get().registerHandler("/get*", fileRequestHandler);
         httpAcceptor.get().registerHandler("/uri-res/*", fileRequestHandler);
         
diff --git a/core/com/limegroup/gnutella/SearchServices.java b/core/com/limegroup/gnutella/SearchServices.java
index 69fb3c7..edcd003 100755
--- a/core/com/limegroup/gnutella/SearchServices.java
+++ b/core/com/limegroup/gnutella/SearchServices.java
@@ -3,6 +3,7 @@ package com.limegroup.gnutella;
 import java.util.Set;
 
 import org.limewire.core.api.browse.BrowseListener;
+import org.limewire.core.api.friend.FriendPresence;
 import org.limewire.io.Address;
 import org.limewire.io.Connectable;
 import org.limewire.io.IpPort;
@@ -10,21 +11,6 @@ import org.limewire.util.MediaType;
 
 public interface SearchServices {
 
-    /**
-     * Browses the passed host
-     * @param host The host to browse
-     * @param port The port at which to browse
-     * @param guid The guid to be used for the query replies received 
-     * while browsing host
-     * @param serventID The guid of the client to browse from.  I need this in
-     * case I need to push....
-     * @param proxies the list of PushProxies we can use - may be null.
-     * @param canDoFWTransfer true if the remote host supports fw transfer
-     */
-    public BrowseHostHandler doAsynchronousBrowseHost(final Connectable host,
-            GUID guid, GUID serventID, final Set<? extends IpPort> proxies,
-            final boolean canDoFWTransfer);
-
     /** 
      * Returns true if the given response for the query with the given guid is a
      * result of the Madragore worm (8KB files of form "x.exe").  Returns false
@@ -123,6 +109,6 @@ public interface SearchServices {
      * Initiates a non-blocking browse of <code>address</code> with
      * session guid <code>browseGuid</code>.
      */
-    public BrowseHostHandler doAsynchronousBrowseHost(Address address, GUID browseGuid, BrowseListener browseListener);
+    public BrowseHostHandler doAsynchronousBrowseHost(FriendPresence friendPresence, GUID browseGuid, BrowseListener browseListener);
 
 }
\ No newline at end of file
diff --git a/core/com/limegroup/gnutella/SearchServicesImpl.java b/core/com/limegroup/gnutella/SearchServicesImpl.java
index c6f3273..d00ff4c 100755
--- a/core/com/limegroup/gnutella/SearchServicesImpl.java
+++ b/core/com/limegroup/gnutella/SearchServicesImpl.java
@@ -4,9 +4,9 @@ import java.util.Set;
 
 import org.limewire.concurrent.ThreadExecutor;
 import org.limewire.core.api.browse.BrowseListener;
+import org.limewire.core.api.friend.FriendPresence;
 import org.limewire.core.settings.FilterSettings;
 import org.limewire.core.settings.MessageSettings;
-import org.limewire.io.Address;
 import org.limewire.io.Connectable;
 import org.limewire.io.IpPort;
 import org.limewire.util.DebugRunnable;
@@ -67,22 +67,6 @@ public class SearchServicesImpl implements SearchServices {
     }
 
     /* (non-Javadoc)
-     * @see com.limegroup.gnutella.SearchServices#doAsynchronousBrowseHost(org.limewire.io.Connectable, com.limegroup.gnutella.GUID, com.limegroup.gnutella.GUID, java.util.Set, boolean)
-     */
-    public BrowseHostHandler doAsynchronousBrowseHost(
-      final Connectable host, GUID guid, GUID serventID, 
-      final Set<? extends IpPort> proxies, final boolean canDoFWTransfer) {
-        final BrowseHostHandler handler = browseHostHandlerManager.createBrowseHostHandler(guid, serventID);
-        ThreadExecutor.startThread(new DebugRunnable(new Runnable() {
-            public void run() {
-                handler.browseHost(host, proxies, canDoFWTransfer);
-            }
-        }), "BrowseHoster" );
-        
-        return handler;
-    }
-
-    /* (non-Javadoc)
      * @see com.limegroup.gnutella.SearchServices#isMandragoreWorm(byte[], com.limegroup.gnutella.Response)
      */
     public boolean isMandragoreWorm(byte[] guid, Response response) {
@@ -216,11 +200,11 @@ public class SearchServicesImpl implements SearchServices {
     }
 
     @Override
-    public BrowseHostHandler doAsynchronousBrowseHost(final Address address, GUID guid, final BrowseListener browseListener) {
+    public BrowseHostHandler doAsynchronousBrowseHost(final FriendPresence friendPresence, GUID guid, final BrowseListener browseListener) {
         final BrowseHostHandler handler = browseHostHandlerManager.createBrowseHostHandler(guid);
         ThreadExecutor.startThread(new DebugRunnable(new Runnable() {
             public void run() {
-                handler.browseHost(address, browseListener);
+                handler.browseHost(friendPresence, browseListener);
             }
         }), "BrowseHoster" );
         return handler;
diff --git a/core/com/limegroup/gnutella/URN.java b/core/com/limegroup/gnutella/URN.java
index 84630e5..f30cff0 100644
--- a/core/com/limegroup/gnutella/URN.java
+++ b/core/com/limegroup/gnutella/URN.java
@@ -21,13 +21,13 @@ import java.util.concurrent.atomic.AtomicInteger;
 
 import org.limewire.core.settings.SharingSettings;
 import org.limewire.io.IOUtils;
+import org.limewire.security.SHA1;
 import org.limewire.util.Base32;
 import org.limewire.util.SystemUtils;
 
 import com.limegroup.gnutella.http.HTTPConstants;
 import com.limegroup.gnutella.http.HTTPHeaderValue;
 import com.limegroup.gnutella.security.MerkleTree;
-import com.limegroup.gnutella.security.SHA1;
 import com.limegroup.gnutella.security.Tiger;
 
 /**
diff --git a/core/com/limegroup/gnutella/browser/LocalHTTPAcceptor.java b/core/com/limegroup/gnutella/browser/LocalHTTPAcceptor.java
index eb5bd04..e33b8e7 100644
--- a/core/com/limegroup/gnutella/browser/LocalHTTPAcceptor.java
+++ b/core/com/limegroup/gnutella/browser/LocalHTTPAcceptor.java
@@ -16,6 +16,7 @@ import org.apache.http.nio.protocol.SimpleNHttpRequestHandler;
 import org.apache.http.protocol.HttpContext;
 import org.limewire.concurrent.ExecutorsHelper;
 import org.limewire.http.BasicHttpAcceptor;
+import org.limewire.http.auth.RequestAuthenticator;
 
 import com.google.inject.Inject;
 import com.google.inject.Singleton;
@@ -53,8 +54,10 @@ public class LocalHTTPAcceptor extends BasicHttpAcceptor {
     private final ExternalControl externalControl;
 
     @Inject
-    public LocalHTTPAcceptor(ExternalControl externalControl) {
-        super(createDefaultParams(LimeWireUtils.getHttpServer(), Constants.TIMEOUT), SUPPORTED_METHODS);
+    public LocalHTTPAcceptor(ExternalControl externalControl,
+                        RequestAuthenticator requestAuthenticator) {
+        super(createDefaultParams(LimeWireUtils.getHttpServer(), Constants.TIMEOUT),
+                requestAuthenticator, SUPPORTED_METHODS);
         this.externalControl = externalControl;
         
         registerHandler("magnet:", new MagnetCommandRequestHandler());
diff --git a/core/com/limegroup/gnutella/downloader/RemoteFileDescImpl.java b/core/com/limegroup/gnutella/downloader/RemoteFileDescImpl.java
index 99f46fe..9c30ec4 100644
--- a/core/com/limegroup/gnutella/downloader/RemoteFileDescImpl.java
+++ b/core/com/limegroup/gnutella/downloader/RemoteFileDescImpl.java
@@ -763,6 +763,7 @@ class RemoteFileDescImpl implements RemoteFileDesc {
                 }
             }
 
+            // TODO 
             address = new FirewalledAddress(publicPrivateAddress, publicPrivateAddress, new GUID(getClientGUID()), proxies, _pushAddr
                     .getFWTVersion());
         }
diff --git a/core/com/limegroup/gnutella/http/HTTPHeaderName.java b/core/com/limegroup/gnutella/http/HTTPHeaderName.java
index d08acaa..62e5862 100644
--- a/core/com/limegroup/gnutella/http/HTTPHeaderName.java
+++ b/core/com/limegroup/gnutella/http/HTTPHeaderName.java
@@ -3,6 +3,7 @@ package com.limegroup.gnutella.http;
 import java.util.Locale;
 
 import org.apache.http.Header;
+import org.apache.http.auth.AUTH;
 import org.apache.http.message.BasicHeader;
 
 /** All HTTPHeaderNames. */
@@ -137,7 +138,10 @@ public enum HTTPHeaderName {
     TRANSFER_ENCODING("Transfer-Encoding"),
     
     /** The firwalled push proxy info of this client */
-    FW_NODE_INFO("X-FW-Node-Info");
+    FW_NODE_INFO("X-FW-Node-Info"),
+    
+    /** Header name for basic access authentication. */
+    AUTHORIZATION(AUTH.WWW_AUTH_RESP);
     
     /**
      * Constant for the HTTP header name as a string.
diff --git a/core/com/limegroup/gnutella/security/SHA1.java b/core/com/limegroup/gnutella/security/SHA1.java
deleted file mode 100644
index 9c966e8..0000000
--- a/core/com/limegroup/gnutella/security/SHA1.java
+++ /dev/null
@@ -1,707 +0,0 @@
-/* @(#)SHA1.java	1.11 2004-04-26
- * This file was freely contributed to the LimeWire project and is covered
- * by its existing GPL licence, but it may be used individually as a public
- * domain implementation of a published algorithm (see below for references).
- * It was also freely contributed to the Bitzi public domain sources.
- * @author  Philippe Verdy
- */
-
-/* Sun may wish to change the following package name, if integrating this
- * class in the Sun JCE Security Provider for Java 1.5 (code-named Tiger).
- *
- * You can include it in your own Security Provider by inserting
- * this property in your Provider derived class:
- * put("MessageDigest.SHA-1", "com.limegroup.gnutella.security.SHA1");
- */
- 
-package com.limegroup.gnutella.security;
-
-import java.security.DigestException;
-import java.security.MessageDigest;
-
-//--+---+1--+---+--2+---+---+3--+---+--4+---+---+5--+---+--6+---+---+7--+---+--
-//34567890123456789012345678901234567890123456789012345678901234567890123456789
-
-/**
- * <p>The FIPS PUB 180-2 standard specifies four secure hash algorithms (SHA-1,
- * SHA-256, SHA-384 and SHA-512) for computing a condensed representation of
- * electronic data (message).  When a message of any length < 2^^64 bits (for
- * SHA-1 and SHA-256) or < 2^^128 bits (for SHA-384 and SHA-512) is input to
- * an algorithm, the result is an output called a message digest.  The message
- * digests range in length from 160 to 512 bits, depending on the algorithm.
- * Secure hash algorithms are typically used with other cryptographic
- * algorithms, such as digital signature algorithms and keyed-hash message
- * authentication codes, or in the generation of random numbers (bits).</p>
- *
- * <p>The four hash algorithms specified in this "SHS" standard are called
- * secure because, for a given algorithm, it is computationally infeasible
- * 1) to find a message that corresponds to a given message digest, or 2)
- * to find two different messages that produce the same message digest.  Any
- * change to a message will, with a very high probability, result in a
- * different message digest.  This will result in a verification failure when
- * the secure hash algorithm is used with a digital signature algorithm or a
- * keyed-hash message authentication algorithm.</p>
- *
- * <p>A "SHS change notice" adds a SHA-224 algorithm for interoperability,
- * which, like SHA-1 and SHA-256, operates on 512-bit blocks and 32-bit words,
- * but truncates the final digest and uses distinct initialization values.</p>
- *
- * <p><b>References:</b></p>
- * <ol>
- *   <li> NIST FIPS PUB 180-2, "Secure Hash Signature Standard (SHS) with
- *      change notice", National Institute of Standards and Technology (NIST),
- *      2002 August 1, and U.S. Department of Commerce, August 26.<br>
- *      <a href="http://csrc.ncsl.nist.gov/CryptoToolkit/Hash.html">
- *      http://csrc.ncsl.nist.gov/CryptoToolkit/Hash.html</a>
- *   <li> NIST FIPS PUB 180-1, "Secure Hash Standard",
- *      U.S. Department of Commerce, May 1993.<br>
- *      <a href="http://www.itl.nist.gov/div897/pubs/fip180-1.htm">
- *      http://www.itl.nist.gov/div897/pubs/fip180-1.htm</a></li>
- *   <li> Bruce Schneier, "Section 18.7 Secure Hash Algorithm (SHA)",
- *      <cite>Applied Cryptography, 2nd edition</cite>, <br>
- *      John Wiley &amp; Sons, 1996</li>
- * </ol>
- */
-public final class SHA1 extends MessageDigest implements Cloneable {
-
-    /**
-     * This implementation returns a fixed-size digest.
-     */
-    private static final int HASH_LENGTH = 20; // bytes == 160 bits
-
-    /**
-     * Private context for incomplete blocks and padding bytes.
-     * INVARIANT: padding must be in 0..63.
-     * When the padding reaches 64, a new block is computed, and
-     * the 56 last bytes are kept in the padding history.
-     */
-    private byte[] pad;
-    private int padding;
-
-    /**
-     * Private contextual byte count, sent in the next block,
-     * after the ending padding block.
-     */
-    private long bytes;
-
-    /**
-     * Private context that contains the current digest key.
-     */
-    private int hA, hB, hC, hD, hE;
-
-    /**
-     * Creates a SHA1 object with default initial state.
-     */
-    public SHA1() {
-        super("SHA-1");
-        pad = new byte[64];
-        init();
-    }
-
-    /**
-     * Clones this object.
-     */
-    @Override
-    public SHA1 clone() throws CloneNotSupportedException  {
-        SHA1 that = (SHA1)super.clone();
-        that.pad = this.pad.clone();
-        return that;
-    }
-
-    /**
-     * Returns the digest length in bytes.
-     *
-     * Can be used to allocate your own output buffer when
-     * computing multiple digests.
-     *
-     * Overrides the protected abstract method of
-     * <code>java.security.MessageDigestSpi</code>.
-     * @return the digest length in bytes.
-     */
-    @Override
-    public int engineGetDigestLength() {
-        return HASH_LENGTH;
-    }
-
-    /**
-     * Reset athen initialize the digest context.
-     *
-     * Overrides the protected abstract method of
-     * <code>java.security.MessageDigestSpi</code>.
-     */
-    @Override
-    protected void engineReset() {
-        int i = 60;
-        do {
-           pad[i    ] = (byte)0x00;
-           pad[i + 1] = (byte)0x00;
-           pad[i + 2] = (byte)0x00;
-           pad[i + 3] = (byte)0x00;
-        } while ((i -= 4) >= 0);
-        padding = 0;
-        bytes = 0;
-        init();
-    }
-
-    /**
-     * Initialize the digest context.
-     */
-    protected void init() {
-        hA = 0x67452301;
-        hB = 0xefcdab89;
-        hC = 0x98badcfe;
-        hD = 0x10325476;
-        hE = 0xc3d2e1f0;
-    }
-
-    /**
-     * Updates the digest using the specified byte.
-     * Requires internal buffering, and may be slow.
-     *
-     * Overrides the protected abstract method of
-     * java.security.MessageDigestSpi.
-     * @param input  the byte to use for the update.
-     */
-    @Override
-    public void engineUpdate(byte input) {
-        bytes++;
-        if (padding < 63) {
-            pad[padding++] = input;
-            return;
-        }
-        pad[63] = input;
-        computeBlock(pad, 0);
-        padding = 0;
-    }
-
-    /**
-     * Updates the digest using the specified array of bytes,
-     * starting at the specified offset.
-     *
-     * Input length can be any size. May require internal buffering,
-     * if input blocks are not multiple of 64 bytes.
-     *
-     * Overrides the protected abstract method of
-     * java.security.MessageDigestSpi.
-     * @param input  the array of bytes to use for the update.
-     * @param offset  the offset to start from in the array of bytes.
-     * @param length  the number of bytes to use, starting at offset.
-     */
-    @Override
-    public void engineUpdate(byte[] input, int offset, int len) {
-        if (offset >= 0 && len >= 0 && offset + len <= input.length) {
-            bytes += len;
-            /* Terminate the previous block. */
-            int padlen = 64 - padding;
-            if (padding > 0 && len >= padlen) {
-                System.arraycopy(input, offset, pad, padding, padlen);
-                computeBlock(pad, 0);
-                padding = 0;
-                offset += padlen;
-                len -= padlen;
-            }
-            /* Loop on large sets of complete blocks. */
-            while (len >= 512) {
-                computeBlock(input, offset);
-                computeBlock(input, offset + 64);
-                computeBlock(input, offset + 128);
-                computeBlock(input, offset + 192);
-                computeBlock(input, offset + 256);
-                computeBlock(input, offset + 320);
-                computeBlock(input, offset + 384);
-                computeBlock(input, offset + 448);
-                offset += 512;
-                len -= 512;
-            }
-            /* Loop on remaining complete blocks. */
-            while (len >= 64) {
-                computeBlock(input, offset);
-                offset += 64;
-                len -= 64;
-            }
-            /* remaining bytes kept for next block. */
-            if (len > 0) {
-                System.arraycopy(input, offset, pad, padding, len);
-                padding += len;
-            }
-            return;
-        }
-        throw new ArrayIndexOutOfBoundsException(offset);
-    }
-
-    /**
-     * Completes the hash computation by performing final operations
-     * such as padding. Computes the final hash and returns the final
-     * value as a byte[20] array. Once engineDigest has been called,
-     * the engine will be automatically reset as specified in the
-     * JavaSecurity MessageDigest specification.
-     *
-     * For faster operations with multiple digests, allocate your own
-     * array and use engineDigest(byte[], int offset, int len).
-     *
-     * Overrides the protected abstract method of
-     * java.security.MessageDigestSpi.
-     * @return the length of the digest stored in the output buffer.
-     */
-    @Override
-    public byte[] engineDigest() {
-        try {
-            final byte hashvalue[] = new byte[HASH_LENGTH];
-            engineDigest(hashvalue, 0, HASH_LENGTH);
-            return hashvalue;
-        } catch (DigestException e) {
-            return null;
-        }
-    }
-
-    /**
-     * Completes the hash computation by performing final operations
-     * such as padding. Once engineDigest has been called, the engine
-     * will be automatically reset (see engineReset).
-     *
-     * Overrides the protected abstract method of
-     * java.security.MessageDigestSpi.
-     * @param hashvalue  the output buffer in which to store the digest.
-     * @param offset  offset to start from in the output buffer
-     * @param len  number of bytes within buf allotted for the digest.
-     *             Both this default implementation and the SUN provider
-     *             do not return partial digests.  The presence of this
-     *             parameter is solely for consistency in our API's.
-     *             If the value of this parameter is less than the
-     *             actual digest length, the method will throw a
-     *             DigestException.  This parameter is ignored if its
-     *             value is greater than or equal to the actual digest
-     *             length.
-     * @return  the length of the digest stored in the output buffer.
-     */
-    @Override
-    public int engineDigest(byte[] hashvalue, int offset, final int len)
-            throws DigestException {
-        if (len >= HASH_LENGTH) {
-            if (hashvalue.length - offset >= HASH_LENGTH) {
-                /* Flush the trailing bytes, adding padding bytes into last
-                 * blocks. */
-                int i;
-                /* Add padding null bytes but replace the last 8 padding bytes
-                 * by the little-endian 64-bit digested message bit-length. */
-                pad[i = padding] = (byte)0x80; /* required 1st padding byte */
-                /* Check if 8 bytes available in pad to store the total
-                 * message size */
-                switch (i) { /* INVARIANT: i must be in [0..63] */
-                case 52: pad[53] = (byte)0x00; /* no break; falls thru */
-                case 53: pad[54] = (byte)0x00; /* no break; falls thru */
-                case 54: pad[55] = (byte)0x00; /* no break; falls thru */
-                case 55: break;
-                case 56: pad[57] = (byte)0x00; /* no break; falls thru */
-                case 57: pad[58] = (byte)0x00; /* no break; falls thru */
-                case 58: pad[59] = (byte)0x00; /* no break; falls thru */
-                case 59: pad[60] = (byte)0x00; /* no break; falls thru */
-                case 60: pad[61] = (byte)0x00; /* no break; falls thru */
-                case 61: pad[62] = (byte)0x00; /* no break; falls thru */
-                case 62: pad[63] = (byte)0x00; /* no break; falls thru */
-                case 63:
-                    computeBlock(pad, 0);
-                    /* Clear the 56 first bytes of pad[]. */
-                    i = 52;
-                    do {
-                        pad[i    ] = (byte)0x00;
-                        pad[i + 1] = (byte)0x00;
-                        pad[i + 2] = (byte)0x00;
-                        pad[i + 3] = (byte)0x00;
-                    } while ((i -= 4) >= 0);
-                    break;
-                default:
-                    /* Clear the rest of 56 first bytes of pad[]. */
-                    switch (i & 3) {
-                    case 3: i++;
-                            break;
-                    case 2: pad[(i += 2) - 1] = (byte)0x00;
-                            break;
-                    case 1: pad[(i += 3) - 2] = (byte)0x00;
-                            pad[ i       - 1] = (byte)0x00;
-                            break;
-                    case 0: pad[(i += 4) - 3] = (byte)0x00;
-                            pad[ i       - 2] = (byte)0x00;
-                            pad[ i       - 1] = (byte)0x00;
-                    }
-                    do {
-                        pad[i    ] = (byte)0x00;
-                        pad[i + 1] = (byte)0x00;
-                        pad[i + 2] = (byte)0x00;
-                        pad[i + 3] = (byte)0x00;
-                    } while ((i += 4) < 56);
-                }
-                /* Convert the message size from bytes to big-endian bits. */
-                pad[56] = (byte)((i = (int)(bytes >>> 29)) >> 24);
-                pad[57] = (byte)(i >>> 16);
-                pad[58] = (byte)(i >>> 8);
-                pad[59] = (byte)i;
-                pad[60] = (byte)((i = (int)bytes << 3) >> 24);
-                pad[61] = (byte)(i >>> 16);
-                pad[62] = (byte)(i >>> 8);
-                pad[63] = (byte)i;
-                computeBlock(pad, 0);
-                /* Return the computed digest in big-endian byte order. */
-                hashvalue[offset     ] = (byte)((i = hA) >>> 24);
-                hashvalue[offset +  1] = (byte)(i >>> 16);
-                hashvalue[offset +  2] = (byte)(i >>> 8);
-                hashvalue[offset +  3] = (byte)i;
-                hashvalue[offset +  4] = (byte)((i = hB) >>> 24);
-                hashvalue[offset += 5] = (byte)(i >>> 16);
-                hashvalue[offset +  1] = (byte)(i >>> 8);
-                hashvalue[offset +  2] = (byte)i;
-                hashvalue[offset +  3] = (byte)((i = hC) >>> 24);
-                hashvalue[offset +  4] = (byte)(i >>> 16);
-                hashvalue[offset += 5] = (byte)(i >>> 8);
-                hashvalue[offset +  1] = (byte)i;
-                hashvalue[offset +  2] = (byte)((i = hD) >>> 24);
-                hashvalue[offset +  3] = (byte)(i >>> 16);
-                hashvalue[offset +  4] = (byte)(i >>> 8);
-                hashvalue[offset += 5] = (byte)i;
-                hashvalue[offset +  1] = (byte)((i = hE) >>> 24);
-                hashvalue[offset +  2] = (byte)(i >>> 16);
-                hashvalue[offset +  3] = (byte)(i >>> 8);
-                hashvalue[offset +  4] = (byte)i;
-                engineReset(); /* clear the evidence */
-                return HASH_LENGTH;
-            }
-            throw new DigestException(
-                "insufficient space in output buffer to store the digest");
-        }
-        throw new DigestException("partial digests not returned");
-    }
-
-    /**
-     * Updates the digest using the specified array of bytes,
-     * starting at the specified offset, but an implied length
-     * of exactly 64 bytes.
-     *
-     * Requires no internal buffering, but assumes a fixed input size,
-     * in which the required padding bytes may have been added.
-     *
-     * @param input  the array of bytes to use for the update.
-     * @param offset  the offset to start from in the array of bytes.
-     */
-    private void computeBlock(final byte[] input, int offset) {
-        /* Local temporary work variables for intermediate digests. */
-        int a, b, c, d, e;
-        /* Cache the input block into the local working set of 32-bit
-         * values, in big-endian byte order. Be careful when
-         * widening bytes or integers due to sign extension! */
-        int i00, i01, i02, i03, i04, i05, i06, i07,
-            i08, i09, i10, i11, i12, i13, i14, i15;
-        /* Use hash schedule function Ch (rounds 0..19):
-         *   Ch(x,y,z) = (x & y) ^ (~x & z) = (x & (y ^ z)) ^ z,
-         * and K00 = .... = K19 = 0x5a827999. */
-        /* First pass, on big endian input (rounds 0..15). */
-        e =  hE
-          +  (((a = hA) << 5) | (a >>> 27)) + 0x5a827999 // K00
-          +  (((b = hB) & ((c = hC)      ^ (d = hD))) ^ d) // Ch(b,c,d)
-          +  (i00 =  input[offset     ] << 24
-                  | (input[offset +  1] & 0xff) << 16
-                  | (input[offset +  2] & 0xff) << 8
-                  | (input[offset +  3] & 0xff)); // W00
-        d += ((e << 5) | (e >>> 27)) + 0x5a827999 // K01
-          +  ((a & ((b = (b << 30) | (b >>> 2)) ^ c)) ^ c) // Ch(a,b,c)
-          +  (i01 =  input[offset +  4] << 24
-                  | (input[offset += 5] & 0xff) << 16
-                  | (input[offset +  1] & 0xff) << 8
-                  | (input[offset +  2] & 0xff)); // W01
-        c += ((d << 5) | (d >>> 27)) + 0x5a827999 // K02
-          +  ((e & ((a = (a << 30) | (a >>> 2)) ^ b)) ^ b) // Ch(e,a,b)
-          +  (i02 =  input[offset +  3] << 24
-                  | (input[offset +  4] & 0xff) << 16
-                  | (input[offset += 5] & 0xff) << 8
-                  | (input[offset +  1] & 0xff)); // W02
-        b += ((c << 5) | (c >>> 27)) + 0x5a827999 // K03
-          +  ((d & ((e = (e << 30) | (e >>> 2)) ^ a)) ^ a) // Ch(d,e,a)
-          +  (i03 =  input[offset +  2] << 24
-                  | (input[offset +  3] & 0xff) << 16
-                  | (input[offset +  4] & 0xff) << 8
-                  | (input[offset += 5] & 0xff)); // W03
-        a += ((b << 5) | (b >>> 27)) + 0x5a827999 // K04
-          +  ((c & ((d = (d << 30) | (d >>> 2)) ^ e)) ^ e) // Ch(c,d,e)
-          +  (i04 =  input[offset +  1] << 24
-                  | (input[offset +  2] & 0xff) << 16
-                  | (input[offset +  3] & 0xff) << 8
-                  | (input[offset +  4] & 0xff)); // W04
-        e += ((a << 5) | (a >>> 27)) + 0x5a827999 // K05
-          +  ((b & ((c = (c << 30) | (c >>> 2)) ^ d)) ^ d) // Ch(b,c,d)
-          +  (i05 =  input[offset += 5] << 24
-                  | (input[offset +  1] & 0xff) << 16
-                  | (input[offset +  2] & 0xff) << 8
-                  | (input[offset +  3] & 0xff)); // W05
-        d += ((e << 5) | (e >>> 27)) + 0x5a827999 // K06
-          +  ((a & ((b = (b << 30) | (b >>> 2)) ^ c)) ^ c) // Ch(a,b,c)
-          +  (i06 =  input[offset +  4] << 24
-                  | (input[offset += 5] & 0xff) << 16
-                  | (input[offset +  1] & 0xff) << 8
-                  | (input[offset +  2] & 0xff)); // W06
-        c += ((d << 5) | (d >>> 27)) + 0x5a827999 // K07
-          +  ((e & ((a = (a << 30) | (a >>> 2)) ^ b)) ^ b) // Ch(e,a,b)
-          +  (i07 =  input[offset +  3] << 24
-                  | (input[offset +  4] & 0xff) << 16
-                  | (input[offset += 5] & 0xff) << 8
-                  | (input[offset +  1] & 0xff)); // W07
-        b += ((c << 5) | (c >>> 27)) + 0x5a827999 // K08
-          +  ((d & ((e = (e << 30) | (e >>> 2)) ^ a)) ^ a) // Ch(d,e,a)
-          +  (i08 =  input[offset +  2] << 24
-                  | (input[offset +  3] & 0xff) << 16
-                  | (input[offset +  4] & 0xff) << 8
-                  | (input[offset += 5] & 0xff)); // W08
-        a += ((b << 5) | (b >>> 27)) + 0x5a827999 // K09
-          +  ((c & ((d = (d << 30) | (d >>> 2)) ^ e)) ^ e) // Ch(c,d,e)
-          +  (i09 =  input[offset +  1] << 24
-                  | (input[offset +  2] & 0xff) << 16
-                  | (input[offset +  3] & 0xff) << 8
-                  | (input[offset +  4] & 0xff)); // W09
-        e += ((a << 5) | (a >>> 27)) + 0x5a827999 // K10
-          +  ((b & ((c = (c << 30) | (c >>> 2)) ^ d)) ^ d) // Ch(b,c,d)
-          +  (i10 =  input[offset += 5] << 24
-                  | (input[offset +  1] & 0xff) << 16
-                  | (input[offset +  2] & 0xff) << 8
-                  | (input[offset +  3] & 0xff)); // W10
-        d += ((e << 5) | (e >>> 27)) + 0x5a827999 // K11
-          +  ((a & ((b = (b << 30) | (b >>> 2)) ^ c)) ^ c) // Ch(a,b,c)
-          +  (i11 =  input[offset +  4] << 24
-                  | (input[offset += 5] & 0xff) << 16
-                  | (input[offset +  1] & 0xff) << 8
-                  | (input[offset +  2] & 0xff)); // W11
-        c += ((d << 5) | (d >>> 27)) + 0x5a827999 // K12
-          +  ((e & ((a = (a << 30) | (a >>> 2)) ^ b)) ^ b) // Ch(e,a,b)
-          +  (i12 =  input[offset +  3] << 24
-                  | (input[offset +  4] & 0xff) << 16
-                  | (input[offset += 5] & 0xff) << 8
-                  | (input[offset +  1] & 0xff)); // W12
-        b += ((c << 5) | (c >>> 27)) + 0x5a827999 // K13
-          +  ((d & ((e = (e << 30) | (e >>> 2)) ^ a)) ^ a) // Ch(d,e,a)
-          +  (i13 =  input[offset +  2] << 24
-                  | (input[offset +  3] & 0xff) << 16
-                  | (input[offset +  4] & 0xff) << 8
-                  | (input[offset += 5] & 0xff)); // W13
-        a += ((b << 5) | (b >>> 27)) + 0x5a827999 // K14
-          +  ((c & ((d = (d << 30) | (d >>> 2)) ^ e)) ^ e) // Ch(c,d,e)
-          +  (i14 =  input[offset +  1] << 24
-                  | (input[offset +  2] & 0xff) << 16
-                  | (input[offset +  3] & 0xff) << 8
-                  | (input[offset +  4] & 0xff)); // W14
-        e += ((a << 5) | (a >>> 27)) + 0x5a827999 // K15
-          +  ((b & ((c = (c << 30) | (c >>> 2)) ^ d)) ^ d) // Ch(b,c,d)
-          +  (i15 =  input[offset += 5] << 24
-                  | (input[offset +  1] & 0xff) << 16
-                  | (input[offset +  2] & 0xff) << 8
-                  | (input[offset +  3] & 0xff)); // W15
-        /* Second pass, on scheduled input (rounds 16..31). */
-        d += ((e << 5) | (e >>> 27)) + 0x5a827999 // K16
-          +  ((a & ((b = (b << 30) | (b >>> 2)) ^ c)) ^ c) // Ch(a,b,c)
-          +  (i00 = ((i00 ^= i02 ^ i08 ^ i13) << 1) | (i00 >>> 31)); // W16
-        c += ((d << 5) | (d >>> 27)) + 0x5a827999 // K17
-          +  ((e & ((a = (a << 30) | (a >>> 2)) ^ b)) ^ b) // Ch(e,a,b)
-          +  (i01 = ((i01 ^= i03 ^ i09 ^ i14) << 1) | (i01 >>> 31)); // W17
-        b += ((c << 5) | (c >>> 27)) + 0x5a827999 // K18
-          +  ((d & ((e = (e << 30) | (e >>> 2)) ^ a)) ^ a) // Ch(d,e,a)
-          +  (i02 = ((i02 ^= i04 ^ i10 ^ i15) << 1) | (i02 >>> 31)); // W18
-        a += ((b << 5) | (b >>> 27)) + 0x5a827999 // K19
-          +  ((c & ((d = (d << 30) | (d >>> 2)) ^ e)) ^ e) // Ch(c,d,e)
-          +  (i03 = ((i03 ^= i05 ^ i11 ^ i00) << 1) | (i03 >>> 31)); // W19
-        /* Use hash schedule function Parity (rounds 20..39):
-         *   Parity(x,y,z) = x ^ y ^ z,
-         * and K20 = .... = K39 = 0x6ed9eba1. */
-        e += ((a << 5) | (a >>> 27)) + 0x6ed9eba1 // K20
-          +  (b ^ (c = (c << 30) | (c >>> 2)) ^ d) // Parity(b,c,d)
-          +  (i04 = ((i04 ^= i06 ^ i12 ^ i01) << 1) | (i04 >>> 31)); // W20
-        d += ((e << 5) | (e >>> 27)) + 0x6ed9eba1 // K21
-          +  (a ^ (b = (b << 30) | (b >>> 2)) ^ c) // Parity(a,b,c)
-          +  (i05 = ((i05 ^= i07 ^ i13 ^ i02) << 1) | (i05 >>> 31)); // W21
-        c += ((d << 5) | (d >>> 27)) + 0x6ed9eba1 // K22
-          +  (e ^ (a = (a << 30) | (a >>> 2)) ^ b) // Parity(e,a,b)
-          +  (i06 = ((i06 ^= i08 ^ i14 ^ i03) << 1) | (i06 >>> 31)); // W22
-        b += ((c << 5) | (c >>> 27)) + 0x6ed9eba1 // K23
-          +  (d ^ (e = (e << 30) | (e >>> 2)) ^ a) // Parity(d,e,a)
-          +  (i07 = ((i07 ^= i09 ^ i15 ^ i04) << 1) | (i07 >>> 31)); // W23
-        a += ((b << 5) | (b >>> 27)) + 0x6ed9eba1 // K24
-          +  (c ^ (d = (d << 30) | (d >>> 2)) ^ e) // Parity(c,d,e)
-          +  (i08 = ((i08 ^= i10 ^ i00 ^ i05) << 1) | (i08 >>> 31)); // W24
-        e += ((a << 5) | (a >>> 27)) + 0x6ed9eba1 // K25
-          +  (b ^ (c = (c << 30) | (c >>> 2)) ^ d) // Parity(b,c,d)
-          +  (i09 = ((i09 ^= i11 ^ i01 ^ i06) << 1) | (i09 >>> 31)); // W25
-        d += ((e << 5) | (e >>> 27)) + 0x6ed9eba1 // K26
-          +  (a ^ (b = (b << 30) | (b >>> 2)) ^ c) // Parity(a,b,c)
-          +  (i10 = ((i10 ^= i12 ^ i02 ^ i07) << 1) | (i10 >>> 31)); // W26
-        c += ((d << 5) | (d >>> 27)) + 0x6ed9eba1 // K27
-          +  (e ^ (a = (a << 30) | (a >>> 2)) ^ b) // Parity(e,a,b)
-          +  (i11 = ((i11 ^= i13 ^ i03 ^ i08) << 1) | (i11 >>> 31)); // W27
-        b += ((c << 5) | (c >>> 27)) + 0x6ed9eba1 // K28
-          +  (d ^ (e = (e << 30) | (e >>> 2)) ^ a) // Parity(d,e,a)
-          +  (i12 = ((i12 ^= i14 ^ i04 ^ i09) << 1) | (i12 >>> 31)); // W28
-        a += ((b << 5) | (b >>> 27)) + 0x6ed9eba1 // K29
-          +  (c ^ (d = (d << 30) | (d >>> 2)) ^ e) // Parity(c,d,e)
-          +  (i13 = ((i13 ^= i15 ^ i05 ^ i10) << 1) | (i13 >>> 31)); // W29
-        e += ((a << 5) | (a >>> 27)) + 0x6ed9eba1 // K30
-          +  (b ^ (c = (c << 30) | (c >>> 2)) ^ d) // Parity(b,c,d)
-          +  (i14 = ((i14 ^= i00 ^ i06 ^ i11) << 1) | (i14 >>> 31)); // W30
-        d += ((e << 5) | (e >>> 27)) + 0x6ed9eba1 // K31
-          +  (a ^ (b = (b << 30) | (b >>> 2)) ^ c) // Parity(a,b,c)
-          +  (i15 = ((i15 ^= i01 ^ i07 ^ i12) << 1) | (i15 >>> 31)); // W31
-        /* Third pass, on scheduled input (rounds 32..47). */
-        c += ((d << 5) | (d >>> 27)) + 0x6ed9eba1 // K32
-          +  (e ^ (a = (a << 30) | (a >>> 2)) ^ b) // Parity(e,a,b)
-          +  (i00 = ((i00 ^= i02 ^ i08 ^ i13) << 1) | (i00 >>> 31)); // W32
-        b += ((c << 5) | (c >>> 27)) + 0x6ed9eba1 // K33
-          +  (d ^ (e = (e << 30) | (e >>> 2)) ^ a) // Parity(d,e,a)
-          +  (i01 = ((i01 ^= i03 ^ i09 ^ i14) << 1) | (i01 >>> 31)); // W33
-        a += ((b << 5) | (b >>> 27)) + 0x6ed9eba1 // K34
-          +  (c ^ (d = (d << 30) | (d >>> 2)) ^ e) // Parity(c,d,e)
-          +  (i02 = ((i02 ^= i04 ^ i10 ^ i15) << 1) | (i02 >>> 31)); // W34
-        e += ((a << 5) | (a >>> 27)) + 0x6ed9eba1 // K35
-          +  (b ^ (c = (c << 30) | (c >>> 2)) ^ d) // Parity(b,c,d)
-          +  (i03 = ((i03 ^= i05 ^ i11 ^ i00) << 1) | (i03 >>> 31)); // W35
-        d += ((e << 5) | (e >>> 27)) + 0x6ed9eba1 // K36
-          +  (a ^ (b = (b << 30) | (b >>> 2)) ^ c) // Parity(a,b,c)
-          +  (i04 = ((i04 ^= i06 ^ i12 ^ i01) << 1) | (i04 >>> 31)); // W36
-        c += ((d << 5) | (d >>> 27)) + 0x6ed9eba1 // K37
-          +  (e ^ (a = (a << 30) | (a >>> 2)) ^ b) // Parity(e,a,b)
-          +  (i05 = ((i05 ^= i07 ^ i13 ^ i02) << 1) | (i05 >>> 31)); // W37
-        b += ((c << 5) | (c >>> 27)) + 0x6ed9eba1 // K38
-          +  (d ^ (e = (e << 30) | (e >>> 2)) ^ a) // Parity(d,e,a)
-          +  (i06 = ((i06 ^= i08 ^ i14 ^ i03) << 1) | (i06 >>> 31)); // W38
-        a += ((b << 5) | (b >>> 27)) + 0x6ed9eba1 // K39
-          +  (c ^ (d = (d << 30) | (d >>> 2)) ^ e) // Parity(c,d,e)
-          +  (i07 = ((i07 ^= i09 ^ i15 ^ i04) << 1) | (i07 >>> 31)); // W39
-        /* Use hash schedule function Maj (rounds 40..59):
-         *   Maj(x,y,z) = (x&y) ^ (x&z) ^ (y&z) = (x & y) | ((x | y) & z),
-         * and K40 = .... = K59 = 0x8f1bbcdc. */
-        e += ((a << 5) | (a >>> 27)) + 0x8f1bbcdc // K40
-          +  ((b & (c = (c << 30) | (c >>> 2))) | ((b | c) & d)) // Maj(b,c,d)
-          +  (i08 = ((i08 ^= i10 ^ i00 ^ i05) << 1) | (i08 >>> 31)); // W40
-        d += ((e << 5) | (e >>> 27)) + 0x8f1bbcdc // K41
-          +  ((a & (b = (b << 30) | (b >>> 2))) | ((a | b) & c)) // Maj(a,b,c)
-          +  (i09 = ((i09 ^= i11 ^ i01 ^ i06) << 1) | (i09 >>> 31)); // W41
-        c += ((d << 5) | (d >>> 27)) + 0x8f1bbcdc // K42
-          +  ((e & (a = (a << 30) | (a >>> 2))) | ((e | a) & b)) // Maj(e,a,b)
-          +  (i10 = ((i10 ^= i12 ^ i02 ^ i07) << 1) | (i10 >>> 31)); // W42
-        b += ((c << 5) | (c >>> 27)) + 0x8f1bbcdc // K43
-          +  ((d & (e = (e << 30) | (e >>> 2))) | ((d | e) & a)) // Maj(d,e,a)
-          +  (i11 = ((i11 ^= i13 ^ i03 ^ i08) << 1) | (i11 >>> 31)); // W43
-        a += ((b << 5) | (b >>> 27)) + 0x8f1bbcdc // K44
-          +  ((c & (d = (d << 30) | (d >>> 2))) | ((c | d) & e)) // Maj(c,d,e)
-          +  (i12 = ((i12 ^= i14 ^ i04 ^ i09) << 1) | (i12 >>> 31)); // W44
-        e += ((a << 5) | (a >>> 27)) + 0x8f1bbcdc // K45
-          +  ((b & (c = (c << 30) | (c >>> 2))) | ((b | c) & d)) // Maj(b,c,d)
-          +  (i13 = ((i13 ^= i15 ^ i05 ^ i10) << 1) | (i13 >>> 31)); // W45
-        d += ((e << 5) | (e >>> 27)) + 0x8f1bbcdc // K46
-          +  ((a & (b = (b << 30) | (b >>> 2))) | ((a | b) & c)) // Maj(a,b,c)
-          +  (i14 = ((i14 ^= i00 ^ i06 ^ i11) << 1) | (i14 >>> 31)); // W46
-        c += ((d << 5) | (d >>> 27)) + 0x8f1bbcdc // K47
-          +  ((e & (a = (a << 30) | (a >>> 2))) | ((e | a) & b)) // Maj(e,a,b)
-          +  (i15 = ((i15 ^= i01 ^ i07 ^ i12) << 1) | (i15 >>> 31)); // W47
-        /* Fourth pass, on scheduled input (rounds 48..63). */
-        b += ((c << 5) | (c >>> 27)) + 0x8f1bbcdc // K48
-          +  ((d & (e = (e << 30) | (e >>> 2))) | ((d | e) & a)) // Maj(d,e,a)
-          +  (i00 = ((i00 ^= i02 ^ i08 ^ i13) << 1) | (i00 >>> 31)); // W48
-        a += ((b << 5) | (b >>> 27)) + 0x8f1bbcdc // K49
-          +  ((c & (d = (d << 30) | (d >>> 2))) | ((c | d) & e)) // Maj(c,d,e)
-          +  (i01 = ((i01 ^= i03 ^ i09 ^ i14) << 1) | (i01 >>> 31)); // W49
-        e += ((a << 5) | (a >>> 27)) + 0x8f1bbcdc // K50
-          +  ((b & (c = (c << 30) | (c >>> 2))) | ((b | c) & d)) // Maj(b,c,d)
-          +  (i02 = ((i02 ^= i04 ^ i10 ^ i15) << 1) | (i02 >>> 31)); // W50
-        d += ((e << 5) | (e >>> 27)) + 0x8f1bbcdc // K51
-          +  ((a & (b = (b << 30) | (b >>> 2))) | ((a | b) & c)) // Maj(a,b,c)
-          +  (i03 = ((i03 ^= i05 ^ i11 ^ i00) << 1) | (i03 >>> 31)); // W51
-        c += ((d << 5) | (d >>> 27)) + 0x8f1bbcdc // K52
-          +  ((e & (a = (a << 30) | (a >>> 2))) | ((e | a) & b)) // Maj(e,a,b)
-          +  (i04 = ((i04 ^= i06 ^ i12 ^ i01) << 1) | (i04 >>> 31)); // W52
-        b += ((c << 5) | (c >>> 27)) + 0x8f1bbcdc // K53
-          +  ((d & (e = (e << 30) | (e >>> 2))) | ((d | e) & a)) // Maj(d,e,a)
-          +  (i05 = ((i05 ^= i07 ^ i13 ^ i02) << 1) | (i05 >>> 31)); // W53
-        a += ((b << 5) | (b >>> 27)) + 0x8f1bbcdc // K54
-          +  ((c & (d = (d << 30) | (d >>> 2))) | ((c | d) & e)) // Maj(c,d,e)
-          +  (i06 = ((i06 ^= i08 ^ i14 ^ i03) << 1) | (i06 >>> 31)); // W54
-        e += ((a << 5) | (a >>> 27)) + 0x8f1bbcdc // K55
-          +  ((b & (c = (c << 30) | (c >>> 2))) | ((b | c) & d)) // Maj(b,c,d)
-          +  (i07 = ((i07 ^= i09 ^ i15 ^ i04) << 1) | (i07 >>> 31)); // W55
-        d += ((e << 5) | (e >>> 27)) + 0x8f1bbcdc // K56
-          +  ((a & (b = (b << 30) | (b >>> 2))) | ((a | b) & c)) // Maj(a,b,c)
-          +  (i08 = ((i08 ^= i10 ^ i00 ^ i05) << 1) | (i08 >>> 31)); // W56
-        c += ((d << 5) | (d >>> 27)) + 0x8f1bbcdc // K57
-          +  ((e & (a = (a << 30) | (a >>> 2))) | ((e | a) & b)) // Maj(e,a,b)
-          +  (i09 = ((i09 ^= i11 ^ i01 ^ i06) << 1) | (i09 >>> 31)); // W57
-        b += ((c << 5) | (c >>> 27)) + 0x8f1bbcdc // K58
-          +  ((d & (e = (e << 30) | (e >>> 2))) | ((d | e) & a)) // Maj(d,e,a)
-          +  (i10 = ((i10 ^= i12 ^ i02 ^ i07) << 1) | (i10 >>> 31)); // W58
-        a += ((b << 5) | (b >>> 27)) + 0x8f1bbcdc // K59
-          +  ((c & (d = (d << 30) | (d >>> 2))) | ((c | d) & e)) // Maj(c,d,e)
-          +  (i11 = ((i11 ^= i13 ^ i03 ^ i08) << 1) | (i11 >>> 31)); // W59
-        /* Use hash schedule function Parity (rounds 60..79):
-         *   Parity(x,y,z) = x ^ y ^ z,
-         * and K60 = .... = K79 = 0xca62c1d6. */
-        e += ((a << 5) | (a >>> 27)) + 0xca62c1d6 // K60
-          +  (b ^ (c = (c << 30) | (c >>> 2)) ^ d) // Parity(b,c,d)
-          +  (i12 = ((i12 ^= i14 ^ i04 ^ i09) << 1) | (i12 >>> 31)); // W60
-        d += ((e << 5) | (e >>> 27)) + 0xca62c1d6 // K61
-          +  (a ^ (b = (b << 30) | (b >>> 2)) ^ c) // Parity(a,b,c)
-          +  (i13 = ((i13 ^= i15 ^ i05 ^ i10) << 1) | (i13 >>> 31)); // W61
-        c += ((d << 5) | (d >>> 27)) + 0xca62c1d6 // K62
-          +  (e ^ (a = (a << 30) | (a >>> 2)) ^ b) // Parity(e,a,b)
-          +  (i14 = ((i14 ^= i00 ^ i06 ^ i11) << 1) | (i14 >>> 31)); // W62
-        b += ((c << 5) | (c >>> 27)) + 0xca62c1d6 // K63
-          +  (d ^ (e = (e << 30) | (e >>> 2)) ^ a) // Parity(d,e,a)
-          +  (i15 = ((i15 ^= i01 ^ i07 ^ i12) << 1) | (i15 >>> 31)); // W63
-        /* Fifth pass, on scheduled input (rounds 64..79). */
-        a += ((b << 5) | (b >>> 27)) + 0xca62c1d6 // K64
-          +  (c ^ (d = (d << 30) | (d >>> 2)) ^ e) // Parity(c,d,e)
-          +  (i00 = ((i00 ^= i02 ^ i08 ^ i13) << 1) | (i00 >>> 31)); // W64
-        e += ((a << 5) | (a >>> 27)) + 0xca62c1d6 // K65
-          +  (b ^ (c = (c << 30) | (c >>> 2)) ^ d) // Parity(b,c,d)
-          +  (i01 = ((i01 ^= i03 ^ i09 ^ i14) << 1) | (i01 >>> 31)); // W65
-        d += ((e << 5) | (e >>> 27)) + 0xca62c1d6 // K66
-          +  (a ^ (b = (b << 30) | (b >>> 2)) ^ c) // Parity(a,b,c)
-          +  (i02 = ((i02 ^= i04 ^ i10 ^ i15) << 1) | (i02 >>> 31)); // W66
-        c += ((d << 5) | (d >>> 27)) + 0xca62c1d6 // K67
-          +  (e ^ (a = (a << 30) | (a >>> 2)) ^ b) // Parity(e,a,b)
-          +  (i03 = ((i03 ^= i05 ^ i11 ^ i00) << 1) | (i03 >>> 31)); // W67
-        b += ((c << 5) | (c >>> 27)) + 0xca62c1d6 // K68
-          +  (d ^ (e = (e << 30) | (e >>> 2)) ^ a) // Parity(d,e,a)
-          +  (i04 = ((i04 ^= i06 ^ i12 ^ i01) << 1) | (i04 >>> 31)); // W68
-        a += ((b << 5) | (b >>> 27)) + 0xca62c1d6 // K69
-          +  (c ^ (d = (d << 30) | (d >>> 2)) ^ e) // Parity(c,d,e)
-          +  (i05 = ((i05 ^= i07 ^ i13 ^ i02) << 1) | (i05 >>> 31)); // W69
-        e += ((a << 5) | (a >>> 27)) + 0xca62c1d6 // K70
-          +  (b ^ (c = (c << 30) | (c >>> 2)) ^ d) // Parity(b,c,d)
-          +  (i06 = ((i06 ^= i08 ^ i14 ^ i03) << 1) | (i06 >>> 31)); // W70
-        d += ((e << 5) | (e >>> 27)) + 0xca62c1d6 // K71
-          +  (a ^ (b = (b << 30) | (b >>> 2)) ^ c) // Parity(a,b,c)
-          +  (i07 = ((i07 ^= i09 ^ i15 ^ i04) << 1) | (i07 >>> 31)); // W71
-        c += ((d << 5) | (d >>> 27)) + 0xca62c1d6 // K72
-          +  (e ^ (a = (a << 30) | (a >>> 2)) ^ b) // Parity(e,a,b)
-          +  (i08 = ((i08 ^= i10 ^ i00 ^ i05) << 1) | (i08 >>> 31)); // W72
-        b += ((c << 5) | (c >>> 27)) + 0xca62c1d6 // K73
-          +  (d ^ (e = (e << 30) | (e >>> 2)) ^ a) // Parity(d,e,a)
-          +  (i09 = ((i09 ^= i11 ^ i01 ^ i06) << 1) | (i09 >>> 31)); // W73
-        a += ((b << 5) | (b >>> 27)) + 0xca62c1d6 // K74
-          +  (c ^ (d = (d << 30) | (d >>> 2)) ^ e) // Parity(c,d,e)
-          +  (i10 = ((i10 ^= i12 ^ i02 ^ i07) << 1) | (i10 >>> 31)); // W74
-        e += ((a << 5) | (a >>> 27)) + 0xca62c1d6 // K75
-          +  (b ^ (c = (c << 30) | (c >>> 2)) ^ d) // Parity(b,c,d)
-          +  (i11 = ((i11 ^= i13 ^ i03 ^ i08) << 1) | (i11 >>> 31)); // W75
-        d += ((e << 5) | (e >>> 27)) + 0xca62c1d6 // K76
-          +  (a ^ (b = (b << 30) | (b >>> 2)) ^ c) // Parity(a,b,c)
-          +  (i12 = ((i12 ^= i14 ^ i04 ^ i09) << 1) | (i12 >>> 31)); // W76
-        c += ((d << 5) | (d >>> 27)) + 0xca62c1d6 // K77
-          +  (e ^ (a = (a << 30) | (a >>> 2)) ^ b) // Parity(e,a,b)
-          +  (i13 = ((i13 ^= i15 ^ i05 ^ i10) << 1) | (i13 >>> 31)); // W77
-        /* Terminate the last two rounds of fifth pass,
-         * feeding the final digest on the fly. */
-        hB +=
-        b += ((c << 5) | (c >>> 27)) + 0xca62c1d6 // K78
-          +  (d ^ (e = (e << 30) | (e >>> 2)) ^ a) // Parity(d,e,a)
-          +  (i14 = ((i14 ^= i00 ^ i06 ^ i11) << 1) | (i14 >>> 31)); // W78
-        hA +=
-        a += ((b << 5) | (b >>> 27)) + 0xca62c1d6 // K79
-          +  (c ^ (d = (d << 30) | (d >>> 2)) ^ e) // Parity(c,d,e)
-          +  (i15 = ((i15 ^= i01 ^ i07 ^ i12) << 1) | (i15 >>> 31)); // W79
-        hE += e;
-        hD += d;
-        hC += /* c= */ (c << 30) | (c >>> 2);
-    }
-}
diff --git a/core/com/limegroup/gnutella/uploader/BrowseRequestHandler.java b/core/com/limegroup/gnutella/uploader/BrowseRequestHandler.java
new file mode 100644
index 0000000..b1bda8e
--- /dev/null
+++ b/core/com/limegroup/gnutella/uploader/BrowseRequestHandler.java
@@ -0,0 +1,205 @@
+package com.limegroup.gnutella.uploader;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.HttpEntityEnclosingRequest;
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.nio.ContentEncoder;
+import org.apache.http.nio.ContentEncoderChannel;
+import org.apache.http.nio.IOControl;
+import org.apache.http.nio.entity.ConsumingNHttpEntity;
+import org.apache.http.nio.protocol.SimpleNHttpRequestHandler;
+import org.apache.http.protocol.HttpContext;
+import org.limewire.http.HttpCoreUtils;
+import org.limewire.http.entity.AbstractProducingNHttpEntity;
+import org.limewire.nio.channel.NoInterestWritableByteChannel;
+
+import com.google.inject.Provider;
+import com.limegroup.gnutella.Constants;
+import com.limegroup.gnutella.FileDesc;
+import com.limegroup.gnutella.FileList;
+import com.limegroup.gnutella.GUID;
+import com.limegroup.gnutella.Response;
+import com.limegroup.gnutella.ResponseFactory;
+import com.limegroup.gnutella.Uploader.UploadStatus;
+import com.limegroup.gnutella.connection.BasicQueue;
+import com.limegroup.gnutella.connection.ConnectionStats;
+import com.limegroup.gnutella.connection.MessageWriter;
+import com.limegroup.gnutella.connection.SentMessageHandler;
+import com.limegroup.gnutella.http.HTTPHeaderName;
+import com.limegroup.gnutella.messages.Message;
+import com.limegroup.gnutella.messages.OutgoingQueryReplyFactory;
+import com.limegroup.gnutella.messages.QueryReply;
+import com.limegroup.gnutella.uploader.authentication.HttpRequestFileListProvider;
+
+/**
+ * Responds to Gnutella browse requests by returning a list of all shared files.
+ * Only supports the application/x-gnutella-packets mime-type, browsing through
+ * HTML is not supported.
+ */
+public class BrowseRequestHandler extends SimpleNHttpRequestHandler {
+
+    private static final Log LOG = LogFactory.getLog(BrowseRequestHandler.class);
+    
+    private final HTTPUploadSessionManager sessionManager;
+    private final Provider<ResponseFactory> responseFactory;
+    private final OutgoingQueryReplyFactory outgoingQueryReplyFactory;
+    /**
+     * This is set to true as default while old clients still don't send 
+     * the request header correctly. Will be set to false in the future.
+     */
+    private boolean requestorCanDoFWT = true;
+
+    private final HttpRequestFileListProvider browseRequestFileListProvider;
+
+    BrowseRequestHandler(HTTPUploadSessionManager sessionManager,
+            Provider<ResponseFactory> responseFactory,
+            OutgoingQueryReplyFactory outgoingQueryReplyFactory,
+            HttpRequestFileListProvider browseRequestFileListProvider) {
+        this.sessionManager = sessionManager;
+        this.responseFactory = responseFactory;
+        this.outgoingQueryReplyFactory = outgoingQueryReplyFactory;
+        this.browseRequestFileListProvider = browseRequestFileListProvider;
+    }
+    
+    public ConsumingNHttpEntity entityRequest(HttpEntityEnclosingRequest request,
+            HttpContext context) throws HttpException, IOException {
+        return null;
+    }
+
+    @Override
+    public void handle(HttpRequest request, HttpResponse response,
+            HttpContext context) throws HttpException, IOException {
+        
+        HTTPUploader uploader = sessionManager.getOrCreateUploader(request,
+                context, UploadType.BROWSE_HOST, "Browse-File");
+        uploader.setState(UploadStatus.BROWSE_HOST);
+        
+        if (request.getHeaders(HTTPHeaderName.FW_NODE_INFO.name()).length > 0) {
+            requestorCanDoFWT = true;
+        }
+        
+        try {
+            FileList fileList = browseRequestFileListProvider.getFileList(request, context);
+            if (!HttpCoreUtils.hasHeaderListValue(request, "Accept", Constants.QUERYREPLY_MIME_TYPE)) {
+                if (LOG.isDebugEnabled())
+                    LOG.debug("Browse request is missing Accept header");
+                
+                response.setStatusCode(HttpStatus.SC_NOT_ACCEPTABLE);
+            } else {
+                response.setEntity(new BrowseResponseEntity(uploader, fileList));
+                response.setStatusCode(HttpStatus.SC_OK);
+            }
+        } catch (com.limegroup.gnutella.uploader.HttpException he) {
+            response.setStatusCode(he.getErrorCode());
+            response.setReasonPhrase(he.getMessage());
+        }
+        
+        sessionManager.sendResponse(uploader, response);
+    }
+
+    public class BrowseResponseEntity extends AbstractProducingNHttpEntity {
+
+        private static final int RESPONSES_PER_REPLY = 10;
+        
+        private static final int MAX_PENDING_REPLIES = 5;
+
+        private final HTTPUploader uploader;
+
+        private Iterator<FileDesc> iterator;
+        
+        private MessageWriter sender;
+        
+        private volatile int pendingMessageCount = 0;
+
+        private GUID sessionGUID = new GUID();
+
+        public BrowseResponseEntity(HTTPUploader uploader, FileList files) {
+            this.uploader = uploader;
+            // getting all file descs creates a copy, so we can thread-safely iterate
+            // not ideal memorywise though
+            iterator = files.getAllFileDescs().iterator();
+
+            // XXX LW can't handle chunked responses: CORE-199
+            //setChunked(true);
+            
+            setContentType(Constants.QUERYREPLY_MIME_TYPE);
+        }
+
+        @Override
+        public long getContentLength() {
+            return -1;
+        }
+        
+        @Override
+        public void initialize(ContentEncoder contentEncoder, IOControl ioctrl) throws IOException {
+            SentMessageHandler sentMessageHandler = new SentMessageHandler() {
+                public void processSentMessage(Message m) {
+                    uploader.addAmountUploaded(m.getTotalLength());
+                    pendingMessageCount--;
+                }                
+            };
+            
+            sender = new MessageWriter(new ConnectionStats(), new BasicQueue(), sentMessageHandler);
+            sender.setWriteChannel(new NoInterestWritableByteChannel(new ContentEncoderChannel(
+                    contentEncoder)));
+        }
+        
+        @Override
+        public boolean writeContent(ContentEncoder contentEncoder, IOControl ioctrl) throws IOException {
+            addMessages();
+            
+            boolean more = sender.handleWrite();
+            assert more || pendingMessageCount == 0;
+            
+            activateTimeout();
+            return more || iterator.hasNext();
+        }
+        
+        /**
+         * Adds a query reply with {@link #RESPONSES_PER_REPLY} responses to the
+         * message queue.
+         */
+        private void addMessages() {
+            if (pendingMessageCount >= MAX_PENDING_REPLIES) {
+                return;
+            }
+            
+            List<Response> responses = new ArrayList<Response>(RESPONSES_PER_REPLY); 
+            for (int i = 0; iterator.hasNext() && i < RESPONSES_PER_REPLY; i++) {
+                responses.add(responseFactory.get().createResponse(iterator.next()));
+            }
+            
+            Iterable<QueryReply> it = outgoingQueryReplyFactory.createReplies(responses.toArray(new Response[0]),
+                    10, null, sessionGUID.bytes(), (byte)1, false, requestorCanDoFWT);
+            
+            for (QueryReply queryReply : it) {
+                sender.send(queryReply);
+                pendingMessageCount++;
+            }
+        }
+
+        public void finish() {
+            deactivateTimeout();
+            sender = null;
+        }
+
+        @Override
+        public void timeout() {
+            if (LOG.isDebugEnabled())
+                LOG.debug("Browse request timed out");
+
+            uploader.stop();
+        }
+        
+    }
+
+}
diff --git a/core/com/limegroup/gnutella/uploader/BrowseRequestHandlerFactory.java b/core/com/limegroup/gnutella/uploader/BrowseRequestHandlerFactory.java
new file mode 100644
index 0000000..3bc16ab
--- /dev/null
+++ b/core/com/limegroup/gnutella/uploader/BrowseRequestHandlerFactory.java
@@ -0,0 +1,46 @@
+package com.limegroup.gnutella.uploader;
+
+import org.limewire.http.auth.Protected;
+
+import com.google.inject.Inject;
+import com.google.inject.Provider;
+import com.google.inject.Singleton;
+import com.limegroup.gnutella.ResponseFactory;
+import com.limegroup.gnutella.messages.OutgoingQueryReplyFactory;
+import com.limegroup.gnutella.uploader.authentication.HttpRequestFileListProvider;
+
+@Singleton
+public class BrowseRequestHandlerFactory {
+
+    private final HTTPUploadSessionManager sessionManager;
+    private final Provider<ResponseFactory> responseFactory;
+    private final OutgoingQueryReplyFactory outgoingQueryReplyFactory;
+
+    @Inject
+    public BrowseRequestHandlerFactory(HTTPUploadSessionManager sessionManager,
+            Provider<ResponseFactory> responseFactory,
+            OutgoingQueryReplyFactory outgoingQueryReplyFactory) {
+        this.sessionManager = sessionManager;
+        this.responseFactory = responseFactory;
+        this.outgoingQueryReplyFactory = outgoingQueryReplyFactory;
+    }
+    
+    public BrowseRequestHandler createBrowseRequestHandler(HttpRequestFileListProvider browseRequestFileListProvider,
+                                                           boolean requiresAuthentication) {
+        if(!requiresAuthentication) {
+            return new BrowseRequestHandler(sessionManager, responseFactory, outgoingQueryReplyFactory,
+                    browseRequestFileListProvider);
+        } else {
+            return new ProtectedBrowseRequestHandler(sessionManager, responseFactory, outgoingQueryReplyFactory,
+                    browseRequestFileListProvider);
+        }
+    }
+    
+    @Protected 
+    class ProtectedBrowseRequestHandler extends BrowseRequestHandler {
+        ProtectedBrowseRequestHandler(HTTPUploadSessionManager sessionManager, Provider<ResponseFactory> responseFactory, OutgoingQueryReplyFactory outgoingQueryReplyFactory, HttpRequestFileListProvider browseRequestFileListProvider) {
+            super(sessionManager, responseFactory, outgoingQueryReplyFactory, browseRequestFileListProvider);
+        }
+    }
+
+}
diff --git a/core/com/limegroup/gnutella/uploader/FileRequestHandler.java b/core/com/limegroup/gnutella/uploader/FileRequestHandler.java
new file mode 100644
index 0000000..280350c
--- /dev/null
+++ b/core/com/limegroup/gnutella/uploader/FileRequestHandler.java
@@ -0,0 +1,530 @@
+package com.limegroup.gnutella.uploader;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Locale;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.HttpEntityEnclosingRequest;
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.nio.entity.ConsumingNHttpEntity;
+import org.apache.http.nio.protocol.SimpleNHttpRequestHandler;
+import org.apache.http.protocol.HTTP;
+import org.apache.http.protocol.HttpContext;
+import org.limewire.core.settings.SharingSettings;
+import org.limewire.http.BasicHeaderProcessor;
+import org.limewire.http.MalformedHeaderException;
+import org.limewire.http.RangeHeaderInterceptor;
+import org.limewire.http.RangeHeaderInterceptor.Range;
+
+import com.google.inject.Provider;
+import com.limegroup.gnutella.CreationTimeCache;
+import com.limegroup.gnutella.DownloadManager;
+import com.limegroup.gnutella.FileDesc;
+import com.limegroup.gnutella.FileManager;
+import com.limegroup.gnutella.IncompleteFileDesc;
+import com.limegroup.gnutella.PushEndpointFactory;
+import com.limegroup.gnutella.URN;
+import com.limegroup.gnutella.Uploader.UploadStatus;
+import com.limegroup.gnutella.altlocs.AltLocManager;
+import com.limegroup.gnutella.altlocs.AlternateLocationFactory;
+import com.limegroup.gnutella.http.AltLocHeaderInterceptor;
+import com.limegroup.gnutella.http.FWNodeInfoInterceptor;
+import com.limegroup.gnutella.http.FeatureHeaderInterceptor;
+import com.limegroup.gnutella.http.HTTPHeaderName;
+import com.limegroup.gnutella.http.HTTPUtils;
+import com.limegroup.gnutella.http.ProblemReadingHeaderException;
+import com.limegroup.gnutella.http.UserAgentHeaderInterceptor;
+import com.limegroup.gnutella.library.SharingUtils;
+import com.limegroup.gnutella.tigertree.HashTree;
+import com.limegroup.gnutella.tigertree.HashTreeCache;
+import com.limegroup.gnutella.tigertree.HashTreeWriteHandler;
+import com.limegroup.gnutella.tigertree.HashTreeWriteHandlerFactory;
+import com.limegroup.gnutella.uploader.FileRequestParser.FileRequest;
+import com.limegroup.gnutella.uploader.HTTPUploadSessionManager.QueueStatus;
+import com.limegroup.gnutella.uploader.authentication.HttpRequestFileListProvider;
+
+/**
+ * Handles upload requests for files and THEX trees.
+ * 
+ * @see FileResponseEntity
+ * @see THEXResponseEntity
+ */
+public class FileRequestHandler extends SimpleNHttpRequestHandler {
+
+    private static final Log LOG = LogFactory.getLog(FileRequestHandler.class);
+
+    /**
+     * Constant for the amount of time to wait before retrying if we are not
+     * actively downloading this file. (1 hour)
+     * <p>
+     * The value is meant to be used only as a suggestion to when newer ranges
+     * may be available if we do not have any ranges that the downloader may
+     * want.
+     */
+    private static final String INACTIVE_RETRY_AFTER = "" + (60 * 60);
+
+    private final HTTPUploadSessionManager sessionManager;
+
+    private final FileManager fileManager;
+
+    private final HTTPHeaderUtils httpHeaderUtils;
+
+    private final HttpRequestHandlerFactory httpRequestHandlerFactory;
+
+    private final Provider<CreationTimeCache> creationTimeCache;
+
+    private final FileResponseEntityFactory fileResponseEntityFactory;
+
+    private final AltLocManager altLocManager;
+
+    private final AlternateLocationFactory alternateLocationFactory;
+
+    private final Provider<DownloadManager> downloadManager;
+
+    private final Provider<HashTreeCache> tigerTreeCache;
+
+    private final PushEndpointFactory pushEndpointFactory;
+
+    private final HashTreeWriteHandlerFactory tigerWriteHandlerFactory;
+
+    private final HttpRequestFileListProvider fileListProvider;
+
+    FileRequestHandler(HTTPUploadSessionManager sessionManager, FileManager fileManager,
+            HTTPHeaderUtils httpHeaderUtils, HttpRequestHandlerFactory httpRequestHandlerFactory,
+            Provider<CreationTimeCache> creationTimeCache,
+            FileResponseEntityFactory fileResponseEntityFactory, AltLocManager altLocManager,
+            AlternateLocationFactory alternateLocationFactory,
+            Provider<DownloadManager> downloadManager, Provider<HashTreeCache> tigerTreeCache,
+            PushEndpointFactory pushEndpointFactory,
+            HashTreeWriteHandlerFactory tigerWriteHandlerFactory, 
+            HttpRequestFileListProvider fileListProvider) {
+        this.sessionManager = sessionManager;
+        this.fileManager = fileManager;
+        this.httpHeaderUtils = httpHeaderUtils;
+        this.httpRequestHandlerFactory = httpRequestHandlerFactory;
+        this.creationTimeCache = creationTimeCache;
+        this.fileResponseEntityFactory = fileResponseEntityFactory;
+        this.altLocManager = altLocManager;
+        this.alternateLocationFactory = alternateLocationFactory;
+        this.downloadManager = downloadManager;
+        this.tigerTreeCache = tigerTreeCache;
+        this.pushEndpointFactory = pushEndpointFactory;
+        this.tigerWriteHandlerFactory = tigerWriteHandlerFactory;
+        this.fileListProvider = fileListProvider;
+    }
+    
+    public ConsumingNHttpEntity entityRequest(HttpEntityEnclosingRequest request,
+            HttpContext context) throws HttpException, IOException {
+        return null;
+    }
+
+    @Override
+    public void handle(HttpRequest request, HttpResponse response, HttpContext context)
+            throws HttpException, IOException {
+        if (LOG.isDebugEnabled())
+            LOG.debug("Handling upload request: " + request.getRequestLine().getUri());
+
+        FileRequest fileRequest = null;
+        HTTPUploader uploader = null;
+
+        // parse request
+        try {
+            String uri = request.getRequestLine().getUri();
+            if (FileRequestParser.isURNGet(uri)) {
+                fileRequest = FileRequestParser.parseURNGet(fileManager, uri);
+                if (fileRequest == null) {
+                    uploader = sessionManager.getOrCreateUploader(request, context,
+                            UploadType.INVALID_URN, "Invalid URN query");
+                    uploader.setState(UploadStatus.FILE_NOT_FOUND);
+                    response.setStatusCode(HttpStatus.SC_NOT_FOUND);
+                }
+            } else {
+                fileRequest = FileRequestParser.parseTraditionalGet(uri);
+                assert fileRequest != null;
+            }
+        } catch (IOException e) {
+            uploader = sessionManager.getOrCreateUploader(request, context,
+                    UploadType.MALFORMED_REQUEST, "Malformed Request");
+            handleMalformedRequest(response, uploader);
+        }
+
+        // process request
+        if (fileRequest != null) {
+            FileDesc fd = getFileDesc(fileRequest, request, context);
+            if (fd != null) {
+                uploader = findFileAndProcessHeaders(request, response, context, fileRequest, fd);
+            } else {
+                uploader = sessionManager.getOrCreateUploader(request, context,
+                        UploadType.SHARED_FILE, fileRequest.filename);
+                uploader.setState(UploadStatus.FILE_NOT_FOUND);
+                response.setStatusCode(HttpStatus.SC_NOT_FOUND);
+            }
+        }
+
+        assert uploader != null;
+
+        sessionManager.sendResponse(uploader, response);
+    }
+
+    /**
+     * Looks up file in {@link FileManager} and processes request headers.
+     */
+    private HTTPUploader findFileAndProcessHeaders(HttpRequest request, HttpResponse response,
+            HttpContext context, FileRequest fileRequest, FileDesc fd) throws IOException,
+            HttpException {
+        // create uploader
+        UploadType type = (SharingUtils.isForcedShare(fd)) ? UploadType.FORCED_SHARE
+                : UploadType.SHARED_FILE;
+        HTTPUploader uploader = sessionManager.getOrCreateUploader(request, context, type, fd
+                .getFileName());
+        uploader.setFileDesc(fd);
+
+        // process headers
+        BasicHeaderProcessor processor = new BasicHeaderProcessor();
+        RangeHeaderInterceptor rangeHeaderInterceptor = new RangeHeaderInterceptor();
+        processor.addInterceptor(rangeHeaderInterceptor);
+        processor.addInterceptor(new FeatureHeaderInterceptor(uploader));
+        processor.addInterceptor(new AltLocHeaderInterceptor(uploader, altLocManager,
+                alternateLocationFactory));
+        processor.addInterceptor(new FWNodeInfoInterceptor(uploader, pushEndpointFactory));
+        if (!uploader.getFileName().toUpperCase(Locale.US).startsWith("LIMEWIRE")) {
+            processor.addInterceptor(new UserAgentHeaderInterceptor(uploader));
+        }
+        try {
+            processor.process(request, context);
+        } catch (ProblemReadingHeaderException e) {
+            handleMalformedRequest(response, uploader);
+            return uploader;
+        } catch (MalformedHeaderException e) {
+            handleMalformedRequest(response, uploader);
+            return uploader;
+        }
+
+        if (UserAgentHeaderInterceptor.isFreeloader(uploader.getUserAgent())) {
+            sessionManager.handleFreeLoader(request, response, context, uploader);
+            return uploader;
+        }
+
+        if (!validateHeaders(uploader, fileRequest.isThexRequest())) {
+            uploader.setState(UploadStatus.FILE_NOT_FOUND);
+            response.setStatusCode(HttpStatus.SC_NOT_FOUND);
+            return uploader;
+        }
+
+        if (!fileRequest.isThexRequest()) {
+            if (rangeHeaderInterceptor.hasRequestedRanges()) {
+                Range[] ranges = rangeHeaderInterceptor.getRequestedRanges();
+                if (ranges.length > 1) {
+                    handleInvalidRange(response, uploader, fd);
+                    return uploader;
+                }
+
+                uploader.setUploadBegin(ranges[0].getStartOffset(uploader.getFileSize()));
+                uploader.setUploadEnd(ranges[0].getEndOffset(uploader.getFileSize()) + 1);
+                uploader.setContainedRangeRequest(true);
+            }
+
+            if (!uploader.validateRange()) {
+                handleInvalidRange(response, uploader, fd);
+                return uploader;
+            }
+        }
+
+        // start upload
+        if (fileRequest.isThexRequest()) {
+            handleTHEXRequest(request, response, context, uploader, fd);
+        } else {
+            handleFileUpload(context, request, response, uploader, fd);
+        }
+
+        return uploader;
+    }
+
+    private void handleMalformedRequest(HttpResponse response, HTTPUploader uploader) {
+        uploader.setState(UploadStatus.MALFORMED_REQUEST);
+        response.setStatusCode(HttpStatus.SC_BAD_REQUEST);
+        response.setReasonPhrase("Malformed Request");
+    }
+
+    /**
+     * Enqueues <code>request</code> and handles <code>uploader</code> in
+     * respect to the returned queue status.
+     */
+    private void handleFileUpload(HttpContext context, HttpRequest request, HttpResponse response,
+            HTTPUploader uploader, FileDesc fd) throws IOException, HttpException {
+        if (!uploader.getSession().isAccepted()) {
+            QueueStatus queued = sessionManager.enqueue(context, request);
+            switch (queued) {
+            case REJECTED:
+                httpRequestHandlerFactory.createLimitReachedRequestHandler(uploader).handle(
+                        request, response, context);
+                break;
+            case BANNED:
+                uploader.setState(UploadStatus.BANNED_GREEDY);
+                response.setStatusCode(HttpStatus.SC_FORBIDDEN);
+                response.setReasonPhrase("Banned");
+                break;
+            case QUEUED:
+                handleQueued(context, request, response, uploader, fd);
+                break;
+            case ACCEPTED:
+                sessionManager.addAcceptedUploader(uploader, context);
+                break;
+            case BYPASS: // ignore
+            }
+        }
+
+        if (uploader.getSession().canUpload()) {
+            handleAccept(context, request, response, uploader, fd);
+        }
+    }
+
+    /**
+     * Processes an accepted file upload by adding headers and setting the
+     * entity.
+     */
+    protected void handleAccept(HttpContext context, HttpRequest request, HttpResponse response,
+            HTTPUploader uploader, FileDesc fd) throws IOException, HttpException {
+
+        assert fd != null;
+
+        response.addHeader(HTTPHeaderName.DATE.create(HTTPUtils.getDateValue()));
+        response.addHeader(HTTPHeaderName.CONTENT_DISPOSITION.create("attachment; filename=\""
+                + HTTPUtils.encode(uploader.getFileName(), "US-ASCII") + "\""));
+
+        if (uploader.containedRangeRequest()) {
+            // uploadEnd is an EXCLUSIVE index internally, but HTTP uses an
+            // INCLUSIVE index.
+            String value = "bytes " + uploader.getUploadBegin() + "-"
+                    + (uploader.getUploadEnd() - 1) + "/" + uploader.getFileSize();
+            response.addHeader(HTTPHeaderName.CONTENT_RANGE.create(value));
+        }
+
+        httpHeaderUtils.addAltLocationsHeader(response, uploader.getAltLocTracker(), altLocManager);
+        httpHeaderUtils.addRangeHeader(response, uploader, fd);
+        httpHeaderUtils.addProxyHeader(response);
+
+        URN urn = fd.getSHA1Urn();
+        if (uploader.isFirstReply()) {
+            // write the creation time if this is the first reply.
+            // if this is just a continuation, we don't need to send
+            // this information again.
+            // it's possible t do that because we don't use the same
+            // uploader for different files
+            if (creationTimeCache.get().getCreationTime(urn) != null) {
+                response.addHeader(HTTPHeaderName.CREATION_TIME.create(creationTimeCache.get()
+                        .getCreationTime(urn).toString()));
+            }
+        }
+
+        // write x-features header once because the downloader is
+        // supposed to cache that information anyway
+        if (uploader.isFirstReply()) {
+            httpHeaderUtils.addFeatures(response);
+        }
+
+        // write X-Thex-URI header with root hash if we have already
+        // calculated the tigertree
+        HashTree tree = tigerTreeCache.get().getHashTree(fd);
+        if (tree != null) {
+            response.addHeader(HTTPHeaderName.THEX_URI.create(tree));
+        }
+
+        response.setEntity(fileResponseEntityFactory.createFileResponseEntity(uploader, fd
+                .getFile()));
+        uploader.setState(UploadStatus.UPLOADING);
+
+        if (uploader.isPartial()) {
+            response.setStatusCode(HttpStatus.SC_PARTIAL_CONTENT);
+        } else {
+            response.setStatusCode(HttpStatus.SC_OK);
+        }
+    }
+
+    /**
+     * Processes an accepted THEX tree upload by adding headers and setting the
+     * entity.
+     */
+    private void handleTHEXRequest(HttpRequest request, HttpResponse response, HttpContext context,
+            HTTPUploader uploader, FileDesc fd) throws HttpException, IOException {
+        // reset the poll interval to allow subsequent requests right away
+        uploader.getSession().updatePollTime(QueueStatus.BYPASS);
+
+        // do not count THEX transfers towards the total amount
+        uploader.setIgnoreTotalAmountUploaded(true);
+
+        HashTree tree = tigerTreeCache.get().getHashTree(fd);
+        if (tree == null) {
+            // tree was requested before hashing completed
+            uploader.setState(UploadStatus.FILE_NOT_FOUND);
+            response.setStatusCode(HttpStatus.SC_NOT_FOUND);
+            return;
+        }
+
+        HashTreeWriteHandler tigerWriteHandler = tigerWriteHandlerFactory
+                .createTigerWriteHandler(tree);
+
+        // XXX reset range to size of THEX tree
+        int outputLength = tigerWriteHandler.getOutputLength();
+        uploader.setFileSize(outputLength);
+        uploader.setUploadBegin(0);
+        uploader.setUploadEnd(outputLength);
+
+        // see CORE-174
+        // response.addHeader(HTTPHeaderName.GNUTELLA_CONTENT_URN.create(fd.getSHA1Urn()));
+
+        uploader.setState(UploadStatus.THEX_REQUEST);
+        response.setEntity(new THEXResponseEntity(uploader, tigerWriteHandler, uploader
+                .getFileSize()));
+        response.setStatusCode(HttpStatus.SC_OK);
+    }
+
+    /**
+     * Processes a request for an invalid range.
+     */
+    private void handleInvalidRange(HttpResponse response, HTTPUploader uploader, FileDesc fd) {
+        httpHeaderUtils.addAltLocationsHeader(response, uploader.getAltLocTracker(), altLocManager);
+        httpHeaderUtils.addRangeHeader(response, uploader, fd);
+        httpHeaderUtils.addProxyHeader(response);
+
+        if (fd instanceof IncompleteFileDesc) {
+            if (!downloadManager.get().isActivelyDownloading(fd.getSHA1Urn())) {
+                response.addHeader(HTTPHeaderName.RETRY_AFTER.create(INACTIVE_RETRY_AFTER));
+            }
+        }
+
+        uploader.setState(UploadStatus.UNAVAILABLE_RANGE);
+        response.setStatusCode(HttpStatus.SC_REQUESTED_RANGE_NOT_SATISFIABLE);
+        response.setReasonPhrase("Requested Range Unavailable");
+    }
+
+    /**
+     * Processes a queued file upload by adding headers.
+     */
+    private void handleQueued(HttpContext context, HttpRequest request, HttpResponse response,
+            HTTPUploader uploader, FileDesc fd) throws IOException, HttpException {
+        // if not queued, this should never be the state
+        int position = uploader.getSession().positionInQueue();
+        assert (position != -1);
+
+        String value = "position=" + (position + 1) + ", pollMin="
+                + (HTTPUploadSession.MIN_POLL_TIME / 1000) + /* mS to S */
+                ", pollMax=" + (HTTPUploadSession.MAX_POLL_TIME / 1000) /*
+                                                                         * mS to
+                                                                         * S
+                                                                         */;
+        response.addHeader(HTTPHeaderName.QUEUE.create(value));
+
+        httpHeaderUtils.addAltLocationsHeader(response, uploader.getAltLocTracker(), altLocManager);
+        httpHeaderUtils.addRangeHeader(response, uploader, fd);
+
+        if (uploader.isFirstReply()) {
+            httpHeaderUtils.addFeatures(response);
+        }
+
+        // write X-Thex-URI header with root hash if we have already
+        // calculated the tigertree
+        HashTree tree = tigerTreeCache.get().getHashTree(fd);
+        if (tree != null) {
+            response.addHeader(HTTPHeaderName.THEX_URI.create(tree));
+        }
+
+        response.setHeader(HTTP.CONN_DIRECTIVE, HTTP.CONN_KEEP_ALIVE);
+
+        uploader.setState(UploadStatus.QUEUED);
+        response.setStatusCode(HttpStatus.SC_SERVICE_UNAVAILABLE);
+    }
+
+    /**
+     * Returns the description for the file requested by <code>request</code>.
+     * 
+     * @return null, if <code>request</code> does not map to a file
+     */
+    private FileDesc getFileDesc(FileRequest request, HttpRequest httpRequest, HttpContext context) throws IOException, HttpException {
+        FileDesc fd = null;
+
+        int index = request.index;
+
+        if(!fileManager.isValidIndex(index))
+       	    return null;
+
+        // first verify the file index
+        fd = fileManager.get(index);
+        // TODO incomplete file list should NOT be used in conjunction with friend file lists?
+        // TODO move into GnutellaFileListProvider?
+        if(fd == null || (!fileListProvider.getFileList(httpRequest, context).contains(fd) 
+        			&& !fileManager.getIncompleteFileList().contains(fd)) ){
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Invalid index in request does not map to file descriptor: " + request);
+            }
+            return null;
+        }
+
+        if (!request.filename.equals(fd.getFileName())) {
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Invalid file name in request: " + request + ", expected: "
+                        + fd.getFileName());
+            }
+            return null;
+        }
+
+        return fd;
+    }
+
+    private boolean validateHeaders(HTTPUploader uploader, boolean thexRequest) {
+        final FileDesc fd = uploader.getFileDesc();
+        assert fd != null;
+
+        // If it's the wrong URN, File Not Found it.
+        URN urn = uploader.getRequestedURN();
+        if (urn != null && !fd.containsUrn(urn)) {
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Invalid content urn: " + uploader);
+            }
+            return false;
+        }
+
+        // handling THEX Requests
+        if (thexRequest && tigerTreeCache.get().getHashTree(fd) == null) {
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Requested thex tree is not available: " + uploader);
+            }
+            return false;
+        }
+
+        // special handling for incomplete files
+        if (fd instanceof IncompleteFileDesc) {
+            // Check to see if we're allowing PFSP.
+            if (!SharingSettings.ALLOW_PARTIAL_SHARING.getValue()) {
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug("Sharing of partial files is diabled: " + uploader);
+                }
+                return false;
+            }
+
+            // cannot service THEX requests for partial files
+            if (thexRequest) {
+                return false;
+            }
+        } else {
+            // check if fd is up-to-date
+            File file = fd.getFile();
+            if (file.lastModified() != fd.lastModified()) {
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug("File has changed on disk, resharing: " + file);
+                }
+                fileManager.removeFile(file);
+                fileManager.addSharedFile(file);
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+}
diff --git a/core/com/limegroup/gnutella/uploader/FileRequestHandlerFactoryImpl.java b/core/com/limegroup/gnutella/uploader/FileRequestHandlerFactoryImpl.java
new file mode 100644
index 0000000..c17447d
--- /dev/null
+++ b/core/com/limegroup/gnutella/uploader/FileRequestHandlerFactoryImpl.java
@@ -0,0 +1,89 @@
+package com.limegroup.gnutella.uploader;
+
+import org.limewire.http.auth.Protected;
+
+import com.google.inject.Inject;
+import com.google.inject.Provider;
+import com.google.inject.Singleton;
+import com.limegroup.gnutella.CreationTimeCache;
+import com.limegroup.gnutella.DownloadManager;
+import com.limegroup.gnutella.FileManager;
+import com.limegroup.gnutella.PushEndpointFactory;
+import com.limegroup.gnutella.altlocs.AltLocManager;
+import com.limegroup.gnutella.altlocs.AlternateLocationFactory;
+import com.limegroup.gnutella.tigertree.HashTreeCache;
+import com.limegroup.gnutella.tigertree.HashTreeWriteHandlerFactory;
+import com.limegroup.gnutella.uploader.authentication.HttpRequestFileListProvider;
+
+@Singleton
+public class FileRequestHandlerFactoryImpl {
+    
+    private final HTTPUploadSessionManager sessionManager;
+
+    private final FileManager fileManager;
+
+    private final HTTPHeaderUtils httpHeaderUtils;
+
+    private final HttpRequestHandlerFactory httpRequestHandlerFactory;
+
+    private final Provider<CreationTimeCache> creationTimeCache;
+
+    private final FileResponseEntityFactory fileResponseEntityFactory;
+
+    private final AltLocManager altLocManager;
+
+    private final AlternateLocationFactory alternateLocationFactory;
+
+    private final Provider<DownloadManager> downloadManager;
+
+    private final Provider<HashTreeCache> tigerTreeCache;
+
+    private final PushEndpointFactory pushEndpointFactory;
+
+    private final HashTreeWriteHandlerFactory tigerWriteHandlerFactory;
+    
+    @Inject
+    public FileRequestHandlerFactoryImpl(HTTPUploadSessionManager sessionManager, FileManager fileManager,
+            HTTPHeaderUtils httpHeaderUtils, HttpRequestHandlerFactory httpRequestHandlerFactory,
+            Provider<CreationTimeCache> creationTimeCache,
+            FileResponseEntityFactory fileResponseEntityFactory, AltLocManager altLocManager,
+            AlternateLocationFactory alternateLocationFactory,
+            Provider<DownloadManager> downloadManager, Provider<HashTreeCache> tigerTreeCache,
+            PushEndpointFactory pushEndpointFactory,
+            HashTreeWriteHandlerFactory tigerWriteHandlerFactory) {
+        this.sessionManager = sessionManager;
+        this.fileManager = fileManager;
+        this.httpHeaderUtils = httpHeaderUtils;
+        this.httpRequestHandlerFactory = httpRequestHandlerFactory;
+        this.creationTimeCache = creationTimeCache;
+        this.fileResponseEntityFactory = fileResponseEntityFactory;
+        this.altLocManager = altLocManager;
+        this.alternateLocationFactory = alternateLocationFactory;
+        this.downloadManager = downloadManager;
+        this.tigerTreeCache = tigerTreeCache;
+        this.pushEndpointFactory = pushEndpointFactory;
+        this.tigerWriteHandlerFactory = tigerWriteHandlerFactory;
+    }
+    
+    public FileRequestHandler createFileRequestHandler(HttpRequestFileListProvider fileListProvider, boolean requiresAuthentication) {
+        if(!requiresAuthentication) {
+            return new FileRequestHandler(sessionManager, fileManager, httpHeaderUtils,
+                    httpRequestHandlerFactory, creationTimeCache, fileResponseEntityFactory,
+                    altLocManager, alternateLocationFactory, downloadManager, tigerTreeCache,
+                    pushEndpointFactory, tigerWriteHandlerFactory, fileListProvider);
+        } else {
+            return new ProtectedFileRequestHandler(sessionManager, fileManager, httpHeaderUtils,
+                    httpRequestHandlerFactory, creationTimeCache, fileResponseEntityFactory,
+                    altLocManager, alternateLocationFactory, downloadManager, tigerTreeCache,
+                    pushEndpointFactory, tigerWriteHandlerFactory, fileListProvider);
+        }
+    }
+    
+    @Protected
+    class ProtectedFileRequestHandler extends FileRequestHandler {
+        ProtectedFileRequestHandler(HTTPUploadSessionManager sessionManager, FileManager fileManager, HTTPHeaderUtils httpHeaderUtils, HttpRequestHandlerFactory httpRequestHandlerFactory, Provider<CreationTimeCache> creationTimeCache, FileResponseEntityFactory fileResponseEntityFactory, AltLocManager altLocManager, AlternateLocationFactory alternateLocationFactory, Provider<DownloadManager> downloadManager, Provider<HashTreeCache> tigerTreeCache, PushEndpointFactory pushEndpointFactory, HashTreeWriteHandlerFactory tigerWriteHandlerFactory, HttpRequestFileListProvider fileListProvider) {
+            super(sessionManager, fileManager, httpHeaderUtils, httpRequestHandlerFactory, creationTimeCache, fileResponseEntityFactory, altLocManager, alternateLocationFactory, downloadManager, tigerTreeCache, pushEndpointFactory, tigerWriteHandlerFactory, fileListProvider);
+        }
+    }
+
+}
diff --git a/core/com/limegroup/gnutella/uploader/FileRequestParser.java b/core/com/limegroup/gnutella/uploader/FileRequestParser.java
new file mode 100644
index 0000000..3a11e7c
--- /dev/null
+++ b/core/com/limegroup/gnutella/uploader/FileRequestParser.java
@@ -0,0 +1,154 @@
+package com.limegroup.gnutella.uploader;
+
+import java.io.IOException;
+import java.util.Locale;
+
+import com.limegroup.gnutella.FileDesc;
+import com.limegroup.gnutella.FileManager;
+import com.limegroup.gnutella.URN;
+import com.limegroup.gnutella.http.HTTPConstants;
+import com.limegroup.gnutella.util.URLDecoder;
+
+/**
+ * Provides methods for parsing Gnutella request URIs.
+ */
+class FileRequestParser {
+
+    /** The type of the requested resource. */
+    enum RequestType {
+        /** Indicates a request for a file transfer. */ 
+        FILE, 
+        /** Indicates a request for a THEX tree. */ 
+        THEX 
+    }; 
+    
+    /**
+     * Returns whether or not the get request for the specified line is a URN
+     * request.
+     * 
+     * @param requestLine the <tt>String</tt> to parse to check whether it's
+     *        following the URN request syntax as specified in HUGE v. 0.93
+     * @return <tt>true</tt> if the request is a valid URN request,
+     *         <tt>false</tt> otherwise
+     */
+    public static boolean isURNGet(final String requestLine) {
+        // check if the string between the first pair of slashes is "uri-res"
+        int slash1Index = requestLine.indexOf("/");
+        int slash2Index = requestLine.indexOf("/", slash1Index + 1);
+        if ((slash1Index == -1) || (slash2Index == -1)) {
+            return false;
+        }
+        String idString = requestLine.substring(slash1Index + 1, slash2Index);
+        return idString.equalsIgnoreCase("uri-res");
+        
+        // much simpler implementation:
+        // return requestLine.startsWith("/uri-res/");
+    }
+
+    /**
+     * Parses a Gnutella GET request.
+     * 
+     * @param uri the requested URI
+     * @return information about the requested file
+     * @throws IOException if the request is malformed
+     */
+    public static FileRequest parseTraditionalGet(final String uri)
+            throws IOException {
+        try {
+            int index = -1;
+    
+            // file information part: /get/0/sample.txt
+            String fileName = null;
+    
+            int g = uri.indexOf("/get/");
+    
+            // find the next "/" after the "/get/", the number in between is the
+            // index
+            int d = uri.indexOf("/", (g + 5));
+    
+            // get the index
+            String str_index = uri.substring((g + 5), d);
+            index = java.lang.Integer.parseInt(str_index);
+            // get the filename, which should be right after
+            // the "/", and before the next " ".
+            try {
+                fileName = URLDecoder.decode(uri.substring(d + 1));
+            } catch (IllegalArgumentException e) {
+                fileName = uri.substring(d + 1);
+            }
+    
+            return new FileRequest(index, fileName);
+        } catch (NumberFormatException e) {
+            throw new IOException();
+        } catch (IndexOutOfBoundsException e) {
+            throw new IOException();
+        }
+    }
+
+    /**
+     * Parses a URN request.
+     * 
+     * @param uri the <tt>String</tt> instance containing the get request
+     * @return information about the requested file, <code>null</code> if the
+     *         request type is invalid or the URN does not map to a valid file
+     * @throws IOException thrown if the request is malformed
+     */
+    public static FileRequest parseURNGet(final FileManager fileManager, final String uri) throws IOException {
+        URN urn = URN.createSHA1UrnFromHttpRequest(uri + " HTTP/1.1");
+    
+        // Parse the service identifier, whether N2R, N2X or something
+        // we cannot satisfy. URI scheme names are not case-sensitive.
+        RequestType requestType;
+        String requestUpper = uri.toUpperCase(Locale.US);
+        if (requestUpper.indexOf(HTTPConstants.NAME_TO_THEX) > 0) {
+            requestType = RequestType.THEX;
+        } else if (requestUpper.indexOf(HTTPConstants.NAME_TO_RESOURCE) > 0) {
+            requestType = RequestType.FILE;
+        } else {
+            return null;
+        }
+    
+        FileDesc desc = fileManager.getFileDesc(urn);
+        if(desc == null || (!fileManager.getGnutellaSharedFileList().contains(desc) 
+        			&& !fileManager.getIncompleteFileList().contains(desc))) {
+            return null;
+        }
+    
+        return new FileRequest(desc.getIndex(), desc.getFileName(), requestType);
+    }
+
+    /** Record for storing information about a file request. */
+    static class FileRequest {
+
+        /** Requested filename. */
+        String filename;
+        
+        /** Requested index. */
+        int index;
+    
+        /** Type of the requested resource. */ 
+        RequestType requestType;
+    
+        public FileRequest(int index, String filename, RequestType requestType) {
+            this.index = index;
+            this.filename = filename;
+            this.requestType = requestType;
+        }
+    
+        public FileRequest(int index, String filename) {
+            this(index, filename, RequestType.FILE);
+        }
+    
+        public boolean isThexRequest() {
+            return this.requestType == RequestType.THEX;
+        }
+        
+        @Override
+        public String toString() {
+            return getClass().getName() + " [index=" + index + ",filename=" + filename + ",type=" + requestType + "]";
+        }
+        
+    }
+
+    
+}
diff --git a/core/com/limegroup/gnutella/uploader/HttpException.java b/core/com/limegroup/gnutella/uploader/HttpException.java
new file mode 100644
index 0000000..3b64a42
--- /dev/null
+++ b/core/com/limegroup/gnutella/uploader/HttpException.java
@@ -0,0 +1,18 @@
+package com.limegroup.gnutella.uploader;
+
+import java.io.IOException;
+
+public class HttpException extends IOException {
+
+    private final int errorCode;
+
+    public HttpException(String message, int errorCode) {
+        super(message);
+        this.errorCode = errorCode;
+    }
+    
+    public int getErrorCode() {
+        return errorCode;
+    }
+    
+}
diff --git a/core/com/limegroup/gnutella/uploader/HttpRequestHandlerFactory.java b/core/com/limegroup/gnutella/uploader/HttpRequestHandlerFactory.java
index e66127d..fdb41a1 100755
--- a/core/com/limegroup/gnutella/uploader/HttpRequestHandlerFactory.java
+++ b/core/com/limegroup/gnutella/uploader/HttpRequestHandlerFactory.java
@@ -1,10 +1,12 @@
 package com.limegroup.gnutella.uploader;
 
-public interface HttpRequestHandlerFactory {
+import com.limegroup.gnutella.uploader.authentication.HttpRequestFileListProvider;
 
-    public FileRequestHandler createFileRequestHandler();
+public interface HttpRequestHandlerFactory {
 
-    public BrowseRequestHandler createBrowseRequestHandler();
+    public FileRequestHandler createFileRequestHandler(HttpRequestFileListProvider fileRequestFileListProvider, boolean requiresAuthentication);
+    
+    public BrowseRequestHandler createBrowseRequestHandler(HttpRequestFileListProvider browseRequestFileListProvider, boolean requiresAuthentication);
 
     public FreeLoaderRequestHandler createFreeLoaderRequestHandler();
 
diff --git a/core/com/limegroup/gnutella/uploader/HttpRequestHandlerFactoryImpl.java b/core/com/limegroup/gnutella/uploader/HttpRequestHandlerFactoryImpl.java
index d8e579c..23129c5 100755
--- a/core/com/limegroup/gnutella/uploader/HttpRequestHandlerFactoryImpl.java
+++ b/core/com/limegroup/gnutella/uploader/HttpRequestHandlerFactoryImpl.java
@@ -4,32 +4,33 @@ import com.google.inject.Inject;
 import com.google.inject.Provider;
 import com.google.inject.Singleton;
 import com.limegroup.gnutella.altlocs.AltLocManager;
+import com.limegroup.gnutella.uploader.authentication.HttpRequestFileListProvider;
 
 @Singleton
 public class HttpRequestHandlerFactoryImpl implements HttpRequestHandlerFactory {
     
-    private final Provider<FileRequestHandler> fileRequestHandlerProvider;
-    private final Provider<BrowseRequestHandler> browseRequestHandlerProvider;
+    private final Provider<FileRequestHandlerFactoryImpl> fileRequestHandlerProvider;
     private final Provider<FreeLoaderRequestHandler> freeLoaderRequestHandlerProvider;
     private final Provider<HttpPushRequestHandler> pushProxyRequestHandlerProvider;
     
     private final HTTPHeaderUtils httpHeaderUtils;
     private final AltLocManager altLocManager;
+    private final Provider<BrowseRequestHandlerFactory> browseRequestHandlerFactory;
     
     @Inject
     public HttpRequestHandlerFactoryImpl(
-            Provider<FileRequestHandler> fileRequestHandlerProvider,
-            Provider<BrowseRequestHandler> browseRequestHandlerProvider,
+            Provider<FileRequestHandlerFactoryImpl> fileRequestHandlerProvider,
             Provider<FreeLoaderRequestHandler> freeLoaderRequestHandlerProvider,
             Provider<HttpPushRequestHandler> pushProxyRequestHandlerProvider,
             HTTPHeaderUtils httpHeaderUtils,
-            AltLocManager altLocManager) {
+            AltLocManager altLocManager,
+            Provider<BrowseRequestHandlerFactory> browseRequestHandlerFactory) {
         this.fileRequestHandlerProvider = fileRequestHandlerProvider;
-        this.browseRequestHandlerProvider = browseRequestHandlerProvider;
         this.freeLoaderRequestHandlerProvider = freeLoaderRequestHandlerProvider;
         this.pushProxyRequestHandlerProvider = pushProxyRequestHandlerProvider;
         this.httpHeaderUtils = httpHeaderUtils;
         this.altLocManager = altLocManager;
+        this.browseRequestHandlerFactory = browseRequestHandlerFactory;
     }
 
     /*
@@ -37,15 +38,16 @@ public class HttpRequestHandlerFactoryImpl implements HttpRequestHandlerFactory
      * 
      * @see com.limegroup.gnutella.uploader.HttpRequestHandlerFactory#createFileRequestHandler()
      */
-    public FileRequestHandler createFileRequestHandler() {
-        return fileRequestHandlerProvider.get();
+    public FileRequestHandler createFileRequestHandler(HttpRequestFileListProvider provider, boolean requiresAuthentication) {
+        return fileRequestHandlerProvider.get().createFileRequestHandler(provider, requiresAuthentication);
     }
 
     /* (non-Javadoc)
      * @see com.limegroup.gnutella.uploader.HttpRequestHandlerFactory#createBrowseRequestHandler()
      */
-    public BrowseRequestHandler createBrowseRequestHandler() {
-        return browseRequestHandlerProvider.get();
+    @Override
+    public BrowseRequestHandler createBrowseRequestHandler(HttpRequestFileListProvider browseRequestFileListProvider, boolean requiresAuthentication) {
+        return browseRequestHandlerFactory.get().createBrowseRequestHandler(browseRequestFileListProvider, requiresAuthentication);
     }
 
     /* (non-Javadoc)
diff --git a/core/com/limegroup/gnutella/uploader/UploadSlotManager.java b/core/com/limegroup/gnutella/uploader/UploadSlotManager.java
index d70631d..83da766 100755
--- a/core/com/limegroup/gnutella/uploader/UploadSlotManager.java
+++ b/core/com/limegroup/gnutella/uploader/UploadSlotManager.java
@@ -53,7 +53,7 @@ public interface UploadSlotManager extends BandwidthTracker {
 	public float getAverageBandwidth();
 
 	/**
-	 * Cancels the request issued by this UploadSlotListener
+	 * Cancels the request issued by the upload slot user.
 	 */
 	public void cancelRequest(UploadSlotUser user);
 
diff --git a/core/com/limegroup/gnutella/uploader/authentication/GnutellaFileListProvider.java b/core/com/limegroup/gnutella/uploader/authentication/GnutellaFileListProvider.java
new file mode 100644
index 0000000..cef3bbf
--- /dev/null
+++ b/core/com/limegroup/gnutella/uploader/authentication/GnutellaFileListProvider.java
@@ -0,0 +1,27 @@
+package com.limegroup.gnutella.uploader.authentication;
+
+import java.io.IOException;
+
+import org.apache.http.HttpRequest;
+import org.apache.http.protocol.HttpContext;
+
+import com.limegroup.gnutella.FileManager;
+import com.limegroup.gnutella.FileList;
+import com.limegroup.gnutella.uploader.HttpException;
+import com.google.inject.Inject;
+
+public class GnutellaFileListProvider implements HttpRequestFileListProvider {
+
+    private final FileManager fileManager;
+
+    @Inject
+    public GnutellaFileListProvider(FileManager fileManager) {
+        this.fileManager = fileManager;
+    }
+
+    @Override
+    public FileList getFileList(HttpRequest request, HttpContext httpContext)
+            throws HttpException, IOException, org.apache.http.HttpException {
+        return fileManager.getGnutellaSharedFileList();
+    }
+}
diff --git a/core/com/limegroup/gnutella/uploader/authentication/HttpRequestFileListProvider.java b/core/com/limegroup/gnutella/uploader/authentication/HttpRequestFileListProvider.java
new file mode 100644
index 0000000..3017a5a
--- /dev/null
+++ b/core/com/limegroup/gnutella/uploader/authentication/HttpRequestFileListProvider.java
@@ -0,0 +1,14 @@
+package com.limegroup.gnutella.uploader.authentication;
+
+import java.io.IOException;
+
+import org.apache.http.HttpRequest;
+import org.apache.http.protocol.HttpContext;
+
+import com.limegroup.gnutella.FileList;
+import com.limegroup.gnutella.uploader.HttpException;
+
+public interface HttpRequestFileListProvider {
+
+    FileList getFileList(HttpRequest request, HttpContext httpContext) throws HttpException, IOException, org.apache.http.HttpException;
+}
diff --git a/gui/com/limegroup/gnutella/gui/search/PromotionSearchResult.java b/gui/com/limegroup/gnutella/gui/search/PromotionSearchResult.java
index 565565a..620a950 100644
--- a/gui/com/limegroup/gnutella/gui/search/PromotionSearchResult.java
+++ b/gui/com/limegroup/gnutella/gui/search/PromotionSearchResult.java
@@ -12,6 +12,7 @@ import javax.swing.JPopupMenu;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.limewire.core.settings.SpeedConstants;
+import org.limewire.security.SHA1;
 import org.limewire.util.Base32;
 
 import com.limegroup.gnutella.GUID;
@@ -22,7 +23,6 @@ import com.limegroup.gnutella.gui.I18n;
 import com.limegroup.gnutella.gui.tables.Linkable;
 import com.limegroup.gnutella.gui.themes.ThemeFileHandler;
 import com.limegroup.gnutella.gui.util.PopupUtils;
-import com.limegroup.gnutella.security.SHA1;
 import com.limegroup.gnutella.util.EncodingUtils;
 import com.limegroup.gnutella.util.LimeWireUtils;
 import com.limegroup.gnutella.xml.LimeXMLDocument;
@@ -73,9 +73,9 @@ public class PromotionSearchResult extends AbstractSearchResult implements Linka
             if (urnString.length() > 20) urnString = urnString.substring(0,20);
             tmpUrn = URN.createSHA1UrnFromBytes(urnString.getBytes());
         } catch (UnsupportedEncodingException e) {
-            LOG.error(e);
+            throw new RuntimeException(e);
         } catch (IOException e) {
-            LOG.error(e);
+            LOG.error("exception", e);
         }
         this.urn = tmpUrn;
     }
diff --git a/gui/com/limegroup/gnutella/gui/search/SearchMediator.java b/gui/com/limegroup/gnutella/gui/search/SearchMediator.java
index 8efbd6a..29226b3 100644
--- a/gui/com/limegroup/gnutella/gui/search/SearchMediator.java
+++ b/gui/com/limegroup/gnutella/gui/search/SearchMediator.java
@@ -307,12 +307,12 @@ public final class SearchMediator {
         // Update the GUID
         final GUID guid = new GUID(GUID.makeGuid());
         in.setGUID(guid);
-        BrowseHostHandler bhh =
-            GuiCoreMediator.getSearchServices().doAsynchronousBrowseHost(host, guid, 
-                                                   new GUID(GUID.makeGuid()), 
-                                                   null, false);
-                                         
-        in.setBrowseHostHandler(bhh);
+//        BrowseHostHandler bhh =
+//            GuiCoreMediator.getSearchServices().doAsynchronousBrowseHost(host, guid, 
+//                                                   new GUID(GUID.makeGuid()), 
+//                                                   null, false);
+//                                         
+//        in.setBrowseHostHandler(bhh);
         INPUT_MANAGER.panelReset(in);
     }
     
@@ -340,11 +340,11 @@ public final class SearchMediator {
         String title = host != null ? host.getAddress() + ":" + host.getPort() : I18n.tr("Firewalled Host"); 
         ResultPanel rp =  addBrowseHostTab(guid, title);
         // Do the actual browse host
-        BrowseHostHandler bhh = GuiCoreMediator.getSearchServices().doAsynchronousBrowseHost(
-                                    host, guid, serventID, proxies,
-                                    canDoFWTransfer);
-        
-        rp.setBrowseHostHandler(bhh);
+//        BrowseHostHandler bhh = GuiCoreMediator.getSearchServices().doAsynchronousBrowseHost(
+//                                    host, guid, serventID, proxies,
+//                                    canDoFWTransfer);
+//        
+//        rp.setBrowseHostHandler(bhh);
     }
 
     /**
diff --git a/private-components/mock-core/src/main/java/org/limewire/core/impl/browse/MockBrowseFactory.java b/private-components/mock-core/src/main/java/org/limewire/core/impl/browse/MockBrowseFactory.java
index 56c3906..7754045 100755
--- a/private-components/mock-core/src/main/java/org/limewire/core/impl/browse/MockBrowseFactory.java
+++ b/private-components/mock-core/src/main/java/org/limewire/core/impl/browse/MockBrowseFactory.java
@@ -2,12 +2,12 @@ package org.limewire.core.impl.browse;
 
 import org.limewire.core.api.browse.Browse;
 import org.limewire.core.api.browse.BrowseFactory;
-import org.limewire.io.Address;
+import org.limewire.core.api.friend.FriendPresence;
 
 class MockBrowseFactory implements BrowseFactory {
 
     @Override
-    public Browse createBrowse(Address address) {
+    public Browse createBrowse(FriendPresence friendPresence) {
         // TODO Auto-generated method stub
         return null;
     }
diff --git a/private-components/mock-core/src/main/java/org/limewire/core/impl/download/MockDownloadListManager.java b/private-components/mock-core/src/main/java/org/limewire/core/impl/download/MockDownloadListManager.java
index f03313b..2d980a2 100644
--- a/private-components/mock-core/src/main/java/org/limewire/core/impl/download/MockDownloadListManager.java
+++ b/private-components/mock-core/src/main/java/org/limewire/core/impl/download/MockDownloadListManager.java
@@ -6,15 +6,15 @@ import java.util.List;
 
 import org.limewire.core.api.Category;
 import org.limewire.core.api.download.DownloadItem;
+import org.limewire.core.api.download.DownloadItem.ErrorState;
 import org.limewire.core.api.download.DownloadListManager;
 import org.limewire.core.api.download.DownloadState;
 import org.limewire.core.api.download.SaveLocationException;
-import org.limewire.core.api.download.DownloadItem.ErrorState;
+import org.limewire.core.api.friend.FriendPresence;
 import org.limewire.core.api.library.RemoteFileItem;
 import org.limewire.core.api.search.Search;
 import org.limewire.core.api.search.SearchResult;
 import org.limewire.xmpp.api.client.FileMetaData;
-import org.limewire.xmpp.api.client.LimePresence;
 
 import ca.odell.glazedlists.BasicEventList;
 import ca.odell.glazedlists.EventList;
@@ -67,7 +67,7 @@ public class MockDownloadListManager implements DownloadListManager {
 	}
 
     @Override
-    public DownloadItem addDownload(LimePresence presence, FileMetaData file) {
+    public DownloadItem addDownload(FriendPresence presence, FileMetaData file) {
         return new MockDownloadItem("download from 1 source", 0,
                 DownloadState.DOWNLOADING, Category.IMAGE);
     }
diff --git a/private-components/mock-core/src/main/java/org/limewire/core/impl/xmpp/MockXMPPConnection.java b/private-components/mock-core/src/main/java/org/limewire/core/impl/xmpp/MockXMPPConnection.java
index b3b5bba..5e04676 100644
--- a/private-components/mock-core/src/main/java/org/limewire/core/impl/xmpp/MockXMPPConnection.java
+++ b/private-components/mock-core/src/main/java/org/limewire/core/impl/xmpp/MockXMPPConnection.java
@@ -1,5 +1,6 @@
 package org.limewire.core.impl.xmpp;
 
+import org.limewire.xmpp.api.client.User;
 import org.limewire.xmpp.api.client.XMPPConnection;
 import org.limewire.xmpp.api.client.XMPPConnectionConfiguration;
 import org.limewire.xmpp.api.client.XMPPException;
@@ -44,4 +45,9 @@ public class MockXMPPConnection implements XMPPConnection {
     public void removeUser(String id) throws XMPPException {
         
     }
+
+    @Override
+    public User getUser(String id) {
+        return null;
+    }
 }
diff --git a/private-components/swingui/src/main/java/org/limewire/ui/swing/friends/ChatFriend.java b/private-components/swingui/src/main/java/org/limewire/ui/swing/friends/ChatFriend.java
index 8da103d..d26b8df 100644
--- a/private-components/swingui/src/main/java/org/limewire/ui/swing/friends/ChatFriend.java
+++ b/private-components/swingui/src/main/java/org/limewire/ui/swing/friends/ChatFriend.java
@@ -27,8 +27,6 @@ public interface ChatFriend {
     
     Mode getMode();
     
-    boolean jidBelongsTo(String jid);
-    
     boolean isChatting();
     
     boolean isActiveConversation();
diff --git a/private-components/swingui/src/main/java/org/limewire/ui/swing/friends/ChatFriendImpl.java b/private-components/swingui/src/main/java/org/limewire/ui/swing/friends/ChatFriendImpl.java
index 7fee7ab..2d4620e 100644
--- a/private-components/swingui/src/main/java/org/limewire/ui/swing/friends/ChatFriendImpl.java
+++ b/private-components/swingui/src/main/java/org/limewire/ui/swing/friends/ChatFriendImpl.java
@@ -144,11 +144,6 @@ public class ChatFriendImpl extends AbstractBean implements ChatFriend {
         firePropertyChange("receivingUnviewedMessages", oldHasUnviewedMessages, hasMessages);
     }
 
-    @Override
-    public boolean jidBelongsTo(String jid) {
-        return presence.get().getUser().jidBelongsTo(jid);
-    }
-
     public Presence getPresence() {
         return presence.get();
     }
diff --git a/private-components/swingui/src/main/java/org/limewire/ui/swing/friends/XMPPEventHandler.java b/private-components/swingui/src/main/java/org/limewire/ui/swing/friends/XMPPEventHandler.java
index 218cb98..98c6afa 100644
--- a/private-components/swingui/src/main/java/org/limewire/ui/swing/friends/XMPPEventHandler.java
+++ b/private-components/swingui/src/main/java/org/limewire/ui/swing/friends/XMPPEventHandler.java
@@ -40,10 +40,6 @@ public class XMPPEventHandler {
                     configuration.setPassword(password);
                     connection.login();
                     configuration.setAutoLogin(autologin);
-                    if (!autologin) {
-                        configuration.setUsername("");
-                        configuration.setPassword("");
-                    }
                 }
             }
         }
diff --git a/private-components/swingui/src/main/java/org/limewire/ui/swing/library/sharing/LibrarySharePanel.java b/private-components/swingui/src/main/java/org/limewire/ui/swing/library/sharing/LibrarySharePanel.java
index 72b8aea..0e5c3e4 100644
--- a/private-components/swingui/src/main/java/org/limewire/ui/swing/library/sharing/LibrarySharePanel.java
+++ b/private-components/swingui/src/main/java/org/limewire/ui/swing/library/sharing/LibrarySharePanel.java
@@ -47,6 +47,7 @@ import org.jdesktop.swingx.painter.AbstractLayoutPainter.VerticalAlignment;
 import org.limewire.collection.glazedlists.GlazedListsFactory;
 import org.limewire.core.api.Category;
 import org.limewire.core.api.friend.Friend;
+import org.limewire.core.api.friend.Network;
 import org.limewire.core.api.library.FileItem;
 import org.limewire.core.api.library.LocalFileItem;
 import org.limewire.core.api.library.LocalFileList;
@@ -705,6 +706,10 @@ public class LibrarySharePanel extends JXPanel implements RegisteringEventListen
         public void setName(String name) {
             
         }
+
+        public Network getNetwork() {
+            return null;
+        }
     }
  
 }
diff --git a/private-components/swingui/src/test/java/org/limewire/ui/swing/friends/MockChatFriend.java b/private-components/swingui/src/test/java/org/limewire/ui/swing/friends/MockChatFriend.java
index 6105aa9..d3cfc4f 100644
--- a/private-components/swingui/src/test/java/org/limewire/ui/swing/friends/MockChatFriend.java
+++ b/private-components/swingui/src/test/java/org/limewire/ui/swing/friends/MockChatFriend.java
@@ -3,6 +3,7 @@ package org.limewire.ui.swing.friends;
 import java.beans.PropertyChangeListener;
 
 import org.limewire.core.api.friend.Friend;
+import org.limewire.core.api.friend.Network;
 import org.limewire.xmpp.api.client.MessageReader;
 import org.limewire.xmpp.api.client.MessageWriter;
 import org.limewire.xmpp.api.client.Presence;
@@ -44,6 +45,10 @@ class MockChatFriend implements ChatFriend {
             public boolean isAnonymous() {
                 return false;
             }
+
+            public Network getNetwork() {
+                return null;
+            }
         };
     }
 
@@ -131,11 +136,6 @@ class MockChatFriend implements ChatFriend {
         this.receivingUnviewedMessages = hasMessages;
     }
 
-    @Override
-    public boolean jidBelongsTo(String jid) {
-        return false;
-    }
-
     public Presence getPresence() {
         return null;
     }
diff --git a/private-components/swingui/src/test/java/org/limewire/ui/swing/friends/MockUser.java b/private-components/swingui/src/test/java/org/limewire/ui/swing/friends/MockUser.java
index d3cffc1..2b292b6 100644
--- a/private-components/swingui/src/test/java/org/limewire/ui/swing/friends/MockUser.java
+++ b/private-components/swingui/src/test/java/org/limewire/ui/swing/friends/MockUser.java
@@ -6,6 +6,7 @@ import java.util.Map;
 import org.limewire.xmpp.api.client.Presence;
 import org.limewire.xmpp.api.client.PresenceListener;
 import org.limewire.xmpp.api.client.User;
+import org.limewire.core.api.friend.Network;
 
 public class MockUser implements User {
     private String id;
@@ -43,12 +44,6 @@ public class MockUser implements User {
     }
 
     @Override
-    public boolean jidBelongsTo(String jid) {
-        // TODO Auto-generated method stub
-        return false;
-    }
-
-    @Override
     public Map<String, Presence> getPresences() {
         return new HashMap<String, Presence>();
     }
@@ -56,4 +51,16 @@ public class MockUser implements User {
     public void setName(String name) {
         this.name = name;
     }
+
+    public Network getNetwork() {
+        return new Network() {
+            public String getMyID() {
+                return "";
+            }
+
+            public String getNetworkName() {
+                return "mock-network";
+            }
+        };
+    }
 }
diff --git a/tests/com/limegroup/gnutella/ClientSideBrowseHostTest.java b/tests/com/limegroup/gnutella/ClientSideBrowseHostTest.java
index 1805c1d..8280642 100644
--- a/tests/com/limegroup/gnutella/ClientSideBrowseHostTest.java
+++ b/tests/com/limegroup/gnutella/ClientSideBrowseHostTest.java
@@ -21,7 +21,13 @@ import junit.framework.Test;
 import org.limewire.io.IpPort;
 import org.limewire.io.IpPortImpl;
 import org.limewire.io.IpPortSet;
+import org.limewire.io.Address;
 import org.limewire.util.Base32;
+import org.limewire.core.api.friend.Friend;
+import org.limewire.core.api.friend.Network;
+import org.limewire.core.api.friend.FriendPresence;
+import org.limewire.core.api.browse.BrowseListener;
+import org.limewire.core.api.search.SearchResult;
 
 import com.google.inject.AbstractModule;
 import com.google.inject.Injector;
@@ -120,9 +126,15 @@ public class ClientSideBrowseHostTest extends ClientSideTestCase {
 
             // tell the leaf to browse host the file, should result in direct HTTP
             // request
-            searchServices.doAsynchronousBrowseHost(callback.getRFD(),
-                    new GUID(GUID.makeGuid()), new GUID(clientGUID),
-                    null, false);
+            searchServices.doAsynchronousBrowseHost(new MockFriendPresence(), new GUID(GUID.makeGuid()), new BrowseListener() {
+                public void handleBrowseResult(SearchResult searchResult) {
+                    //To change body of implemented methods use File | Settings | File Templates.
+                }
+
+                public void browseFinished(boolean success) {
+                    //To change body of implemented methods use File | Settings | File Templates.
+                }
+            });
 
             // wait for the incoming HTTP request
             Socket httpSock = ss.accept();
@@ -187,9 +199,15 @@ public class ClientSideBrowseHostTest extends ClientSideTestCase {
 
             // tell the leaf to browse host the file, should result in PushProxy
             // request
-            searchServices.doAsynchronousBrowseHost(callback.getRFD(),
-                    new GUID(GUID.makeGuid()), new GUID(clientGUID),
-                    proxies, false);
+            searchServices.doAsynchronousBrowseHost(new MockFriendPresence(), new GUID(GUID.makeGuid()), new BrowseListener() {
+                public void handleBrowseResult(SearchResult searchResult) {
+                    //To change body of implemented methods use File | Settings | File Templates.
+                }
+
+                public void browseFinished(boolean success) {
+                    //To change body of implemented methods use File | Settings | File Templates.
+                }
+            });
 
             // wait for the incoming PushProxy request
             // increase the timeout since we send udp pushes first
@@ -292,10 +310,15 @@ public class ClientSideBrowseHostTest extends ClientSideTestCase {
         assertNotNull(callback.getRFD());
 
         // tell the leaf to browse host the file,
-        searchServices.doAsynchronousBrowseHost(callback.getRFD(),
-                                new GUID(GUID.makeGuid()), new GUID(clientGUID),
-                                proxies, false);
+        searchServices.doAsynchronousBrowseHost(new MockFriendPresence(), new GUID(GUID.makeGuid()), new BrowseListener() {
+                public void handleBrowseResult(SearchResult searchResult) {
+                    //To change body of implemented methods use File | Settings | File Templates.
+                }
 
+                public void browseFinished(boolean success) {
+                    //To change body of implemented methods use File | Settings | File Templates.
+                }
+            });
         // nothing works for the guy, we should get a PushRequest
         do {
             m = testUP[0].receive(TIMEOUT*30);
@@ -366,6 +389,50 @@ public class ClientSideBrowseHostTest extends ClientSideTestCase {
             latch.countDown();
         }
     }
+    
+    class MockFriend implements Friend {
+        public String getId() {
+            return null;  //To change body of implemented methods use File | Settings | File Templates.
+        }
+
+        public String getName() {
+            return null;  //To change body of implemented methods use File | Settings | File Templates.
+        }
+
+        public String getRenderName() {
+            return null;  //To change body of implemented methods use File | Settings | File Templates.
+        }
+
+        public void setName(String name) {
+            //To change body of implemented methods use File | Settings | File Templates.
+        }
+
+        public boolean isAnonymous() {
+            return false;  //To change body of implemented methods use File | Settings | File Templates.
+        }
+
+        public Network getNetwork() {
+            return null;  //To change body of implemented methods use File | Settings | File Templates.
+        }
+    }
+    
+    class MockFriendPresence implements FriendPresence {
+        public Friend getFriend() {
+            return null;  //To change body of implemented methods use File | Settings | File Templates.
+        }
+
+        public String getPresenceId() {
+            return null;  //To change body of implemented methods use File | Settings | File Templates.
+        }
+
+        public Address getPresenceAddress() {
+            return null;  //To change body of implemented methods use File | Settings | File Templates.
+        }
+
+        public byte[] getAuthToken() {
+            return new byte[0];  //To change body of implemented methods use File | Settings | File Templates.
+        }
+    }
 
 }
 
diff --git a/tests/com/limegroup/gnutella/HTTPAcceptorTest.java b/tests/com/limegroup/gnutella/HTTPAcceptorTest.java
index f4d057f..98f46c9 100644
--- a/tests/com/limegroup/gnutella/HTTPAcceptorTest.java
+++ b/tests/com/limegroup/gnutella/HTTPAcceptorTest.java
@@ -19,6 +19,8 @@ import org.apache.http.nio.protocol.SimpleNHttpRequestHandler;
 import org.apache.http.protocol.HttpContext;
 import org.cybergarage.http.HTTPStatus;
 import org.limewire.http.HttpAcceptorListener;
+import org.limewire.http.auth.RequestAuthenticatorImpl;
+import org.limewire.http.auth.AuthenticatorRegistryImpl;
 import org.limewire.http.httpclient.HttpClientUtils;
 import org.limewire.io.SimpleNetworkInstanceUtils;
 import org.limewire.net.ConnectionDispatcher;
@@ -49,7 +51,7 @@ public class HTTPAcceptorTest extends BaseTestCase {
     protected void setUp() throws Exception {
         ConnectionDispatcher connectionDispatcher = new ConnectionDispatcherImpl(new SimpleNetworkInstanceUtils(false));
         socketAcceptor = new SocketAcceptor(connectionDispatcher);
-        httpAcceptor = new HTTPAcceptor(null);
+        httpAcceptor = new HTTPAcceptor(null, new RequestAuthenticatorImpl(new AuthenticatorRegistryImpl()));
         connectionDispatcher.addConnectionAcceptor(httpAcceptor, false, httpAcceptor.getHttpMethods());
         
         socketAcceptor.bind(PORT);
diff --git a/tests/com/limegroup/gnutella/security/SHA1Test.java b/tests/com/limegroup/gnutella/security/SHA1Test.java
deleted file mode 100644
index 247c892..0000000
--- a/tests/com/limegroup/gnutella/security/SHA1Test.java
+++ /dev/null
@@ -1,185 +0,0 @@
-/*
- * @(#)SHA1Test.java   1.9 2004-04-22
- * This file was freely contributed to the LimeWire project  and is covered
- * by its existing GPL licence, but it may be used individually as a public
- * domain implementation of a published algorithm (see below for references).
- * It was also freely contributed to the Bitzi public domain sources.
- * @author  Philippe Verdy
- */
-
-/*
- * Sun may wish to change the following package name, if integrating this
- * class in the Sun JCE Security Provider for Java 1.5 (code-named Tiger).
- */
-package com.limegroup.gnutella.security;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.security.MessageDigest;
-
-import org.limewire.util.TestUtils;
-
-import junit.framework.Test;
-
-import com.limegroup.gnutella.util.LimeTestCase;
-
-public class SHA1Test extends LimeTestCase {
-    
-    private static final SHA1 hash = new SHA1();
-    
-       
-    public SHA1Test(String name) {
-        super(name);
-    }
-    
-    public static Test suite() {
-        return buildTestSuite(SHA1Test.class);
-    }
-    
-    public static void main(String[] args) {
-        junit.textui.TestRunner.run(suite());
-    }          
-
-    public void testBasic() throws Exception {
-// http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf
-        tst(1, 1,
-            "abc",
-            "A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D");
-        tst(1, 2,
-            "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
-            "84983E44 1C3BD26e BAAE4AA1 F95129E5 E54670F1");
-        tst(1, 3,
-            1000000, "a",
-            "34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F");
-        // See also http://csrc.ncsl.nist.gov/cryptval/shs/sha1-vectors.zip
-    }
-    
-    public void testRate() throws Exception {
-        final int ITERATIONS = 16000;
-        final int BLOCKSIZE = 65536;
-        byte[] input = new byte[BLOCKSIZE];
-        for (int i = BLOCKSIZE; --i >= 0; )
-            input[i] = (byte)i;
-
-        long t0 = System.currentTimeMillis();
-        for (int i = ITERATIONS; --i >= 0; );
-        long t1 = System.currentTimeMillis();
-        for (int i = ITERATIONS; --i >= 0; )
-            hash.engineUpdate(input, 0, BLOCKSIZE);
-        long t2 = System.currentTimeMillis();
-        hash.engineReset();
-        double rate = 1000.0 * ITERATIONS * BLOCKSIZE / ((t2 - t1) - (t1 - t0));
-                    
-        double limeRate = rate;
-        //System.out.println("Our rate = " +
-        //                    (float)(rate * 8) + " bits/s = " +
-        //                    (float)(rate / (1024 * 1024)) + " Megabytes/s");
-        // Java 1.5 beta-b32c, on Athlon XP 1800+: 47.62 Megabytes/s.
-
-        MessageDigest md = MessageDigest.getInstance("SHA");
-        t0 = System.currentTimeMillis();
-        for (int i = ITERATIONS; --i >= 0; );
-        t1 = System.currentTimeMillis();
-        for (int i = ITERATIONS; --i >= 0; )
-            md.update(input, 0, BLOCKSIZE);
-        t2 = System.currentTimeMillis();
-        md.reset();
-        rate = 1000.0 * ITERATIONS * BLOCKSIZE / ((t2 - t1) - (t1 - t0));
-            //System.out.println("JCE rate = " +
-            //                    (float)(rate * 8) + " bits/s = " +
-            //                    (float)(rate / (1024 * 1024)) + " Megabytes/s");
-        // Java 1.5 beta-b32c, on Athlon XP 1800+: 22.78 Megabytes/s.
-        
-        assertGreaterThan(rate, limeRate);
-    }
-    
-    public void testFiles() throws Exception {
-        String dirString = "com/limegroup/gnutella";
-        File testDir = TestUtils.getResourceFile(dirString);
-        assertTrue(testDir.isDirectory());
-        int tested = testDirectory(testDir);
-        assertGreaterThan("didn't test enough", 10, tested);
-    }
-    
-    public int testDirectory(File dir) throws Exception {
-        int tested = 0;
-        File[] files = dir.listFiles();
-        for(int i = 0; i < files.length; i++) {
-            File f = files[i];
-            if(f.isDirectory())
-                tested += testDirectory(f);
-            else if(f.isFile() && f.exists()) {
-                byte[] old = createSHA1(f, true);
-                byte[] now = createSHA1(f, false);
-                assertEquals(old, now);
-                tested++;
-            }
-        }
-        return tested;
-    }
-    
-    
-	private static byte[] createSHA1(final File file, boolean digest) 
-      throws Exception {
-		FileInputStream fis = new FileInputStream(file);   		
-		// we can only calculate SHA1 for now
-		MessageDigest md = null;
-        if(digest)
-            md = MessageDigest.getInstance("SHA");
-        else
-            md = new SHA1();
-        
-        try {
-            byte[] buffer = new byte[16384];
-            int read;
-            while ((read=fis.read(buffer))!=-1)
-                md.update(buffer,0,read);
-        } finally {		
-            fis.close();
-        }
-
-        return md.digest();
-	}
-
-    
-    private static final void tst(final int set, final int vector,
-                                     final String source,
-                                     final String expect) {
-     //   System.out.print("Set " + set + ", vector# " + vector + ": ");
-        byte[] input = new byte[source.length()];
-        for (int i = 0; i < input.length; i++)
-            input[i] = (byte)source.charAt(i);
-        hash.engineUpdate(input, 0, input.length);
-        tstResult(expect);
-    }
-
-    private static final void tst(final int set, final int vector,
-                                     final int times, final String source,
-                                     final String expect) {
-     //   System.out.print("Set " + set + ", vector# " + vector + ": ");
-        byte[] input = new byte[source.length()];
-        for (int i = 0; i < input.length; i++)
-            input[i] = (byte)source.charAt(i);
-        for (int i = 0; i < times; i++)
-            hash.engineUpdate(input, 0, input.length);
-        tstResult(expect);
-    }
-
-    private static final void tstResult(final String expect) {
-        final String result = toHex(hash.engineDigest());
-        assertEquals(expect.toUpperCase(), result);
-    }
-
-    private static final String toHex(final byte[] bytes) {
-        StringBuffer buf = new StringBuffer(bytes.length * 2);
-        for (int i = 0; i < bytes.length; i++) {
-            if ((i & 3) == 0 && i != 0)
-               buf.append(' ');
-            buf.append(HEX.charAt((bytes[i] >> 4) & 0xF))
-               .append(HEX.charAt( bytes[i]       & 0xF));
-        }
-        return buf.toString();
-    }
-
-    private static final String HEX = "0123456789ABCDEF";
-}
diff --git a/tests/com/limegroup/gnutella/uploader/AltLocUploadTest.java b/tests/com/limegroup/gnutella/uploader/AltLocUploadTest.java
index 10d9065..7b4b841 100644
--- a/tests/com/limegroup/gnutella/uploader/AltLocUploadTest.java
+++ b/tests/com/limegroup/gnutella/uploader/AltLocUploadTest.java
@@ -64,6 +64,7 @@ import com.limegroup.gnutella.ReplyHandler;
 import com.limegroup.gnutella.Response;
 import com.limegroup.gnutella.URN;
 import com.limegroup.gnutella.UploadManager;
+import com.limegroup.gnutella.uploader.authentication.GnutellaFileListProvider;
 import com.limegroup.gnutella.altlocs.AltLocManager;
 import com.limegroup.gnutella.altlocs.AlternateLocation;
 import com.limegroup.gnutella.altlocs.AlternateLocationCollection;
@@ -1413,9 +1414,10 @@ public class AltLocUploadTest extends LimeTestCase {
                 Provider<HTTPAcceptor> httpAcceptor,
                 Provider<FileManager> fileManager,
                 Provider<ActivityCallback> activityCallback, 
-                TcpBandwidthStatistics tcpBandwidthStatistics) {
+                TcpBandwidthStatistics tcpBandwidthStatistics,
+                Provider<GnutellaFileListProvider> gnutellaBrowseRequestFileListProviderProvider) {
             super(slotManager, httpRequestHandlerFactory, contentManager, httpAcceptor,
-                    fileManager, activityCallback, tcpBandwidthStatistics);
+                    fileManager, activityCallback, tcpBandwidthStatistics, gnutellaBrowseRequestFileListProviderProvider);
         }
 
         @Override
