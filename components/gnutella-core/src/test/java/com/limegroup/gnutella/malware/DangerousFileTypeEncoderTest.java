package com.limegroup.gnutella.malware;

import junit.framework.Test;

import org.limewire.core.settings.FilterSettings;
import org.limewire.gnutella.tests.LimeTestCase;
import org.limewire.io.InvalidDataException;

/**
 * Tests that descriptions of dangerous file types are encoded and decoded
 * correctly. 
 */
public class DangerousFileTypeEncoderTest extends LimeTestCase {

    final static String fooMime = "application/x-foo";
    final static String[] fooExt = { "foo", "football" };
    final static DangerousFileType foo =
        new DangerousFileType(fooMime, fooExt);

    final static String barMime = "application/x-bar";
    final static String[] barExt = { "bar" };
    final static DangerousFileType bar =
        new DangerousFileType(barMime, barExt);

    public DangerousFileTypeEncoderTest(String name) {
        super(name);
    }

    public static Test suite() {
        return buildTestSuite(DangerousFileTypeEncoderTest.class);
    }

    public void testNoFileTypes() throws Exception {
        EncoderTestUtils.encodeAndDecode(new DangerousFileType[0]);
    }

    public void testOneFileType() throws Exception {
        EncoderTestUtils.encodeAndDecode(new DangerousFileType[] { foo });
    }

    public void testTwoFileTypes() throws Exception {
        EncoderTestUtils.encodeAndDecode(new DangerousFileType[] { foo, bar });
    }

    public void testSettingTypes() throws Exception {
        String setting = FilterSettings.DANGEROUS_FILE_TYPES.get();
        DangerousFileTypeEncoder.decodeSetting(setting);
    }

    public void testDetectsBrokenSetting() throws Exception {
        String setting = FilterSettings.DANGEROUS_FILE_TYPES.get();
        assertGreaterThan(1, setting.length());
        setting = setting.substring(1); // Borked
        try {
            DangerousFileTypeEncoder.decodeSetting(setting);
        } catch(InvalidDataException expected) {
            return;
        }
        fail("decoding should have failed");
    }
}
