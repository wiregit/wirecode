package com.limegroup.gnutella.malware;

import junit.framework.Test;

import org.limewire.core.settings.FilterSettings;
import org.limewire.gnutella.tests.LimeTestCase;
import org.limewire.io.InvalidDataException;
import org.limewire.util.StringUtils;

/**
 * Tests that descriptions of mime types are encoded and decoded correctly. 
 */
public class MimeTypeEncoderTest extends LimeTestCase {

    final static String fooName = "application/x-foo";
    final static Long[] fooOff = { 0L, 123L, -456L };
    final static byte[][] fooPat = {
        StringUtils.toUTF8Bytes("abc"),
        StringUtils.fromHexString("00FF"),
        { 127, 0, 0, 1 }
    };
    final static MimeType foo = new MimeType(fooName, fooOff, fooPat);

    final static String barName = "application/x-bar";
    final static Long[] barOff = { -5000000000L, 24L };
    final static byte[][] barPat = {
        StringUtils.toUTF8Bytes("blah"),
        StringUtils.toUTF8Bytes("bleh")
    };
    final static MimeType bar = new MimeType(barName, barOff, barPat);

    public MimeTypeEncoderTest(String name) {
        super(name);
    }

    public static Test suite() {
        return buildTestSuite(MimeTypeEncoderTest.class);
    }

    public void testNoMimeTypes() throws Exception {
        EncoderTestUtils.encodeAndDecode(new MimeType[0]);
    }

    public void testOneMimeType() throws Exception {
        EncoderTestUtils.encodeAndDecode(new MimeType[] { foo });
    }

    public void testTwoMimeTypes() throws Exception {
        EncoderTestUtils.encodeAndDecode(new MimeType[] { foo, bar });
    }

    public void testSettingTypes() throws Exception {
        String setting = FilterSettings.MIME_TYPES.get();
        MimeTypeEncoder.decodeSetting(setting);
    }

    public void testDetectsBrokenSetting() throws Exception {
        String setting = FilterSettings.MIME_TYPES.get();
        assertGreaterThan(1, setting.length());
        setting = setting.substring(1); // Borked
        try {
            MimeTypeEncoder.decodeSetting(setting);
        } catch(InvalidDataException expected) {
            return;
        }
        fail("Decoding should have failed");
    }

    public void testDetectsUnequalOffsetAndPatternLists() throws Exception {
        try {
            EncoderTestUtils.encodeAndDecode(new MimeType[] {
                    new MimeType(fooName, fooOff, barPat)
            });
        } catch(InvalidDataException expected) {
            return;
        }
        fail("Decoding should have failed");
    }

    public void testDetectsEmptyOffsetList() throws Exception {
        try {
            EncoderTestUtils.encodeAndDecode(new MimeType[] {
                    new MimeType(fooName, new Long[0], fooPat)
            });
        } catch(InvalidDataException expected) {
            return;
        }
        fail("Decoding should have failed");
    }
}
