package com.limegroup.gnutella.malware;

import static org.limewire.util.EventTypeMatcher.eventTypeMatches;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.net.URI;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

import junit.framework.Test;

import org.apache.http.HttpResponse;
import org.apache.http.HttpVersion;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.client.params.HttpClientParams;
import org.apache.http.entity.ByteArrayEntity;
import org.apache.http.entity.InputStreamEntity;
import org.apache.http.entity.StringEntity;
import org.apache.http.message.BasicHeader;
import org.apache.http.message.BasicHttpResponse;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpParams;
import org.jmock.Expectations;
import org.jmock.Mockery;
import org.jmock.Sequence;
import org.jmock.api.Invocation;
import org.jmock.lib.action.CustomAction;
import org.limewire.concurrent.ManagedThread;
import org.limewire.core.api.download.SaveLocationManager;
import org.limewire.core.api.file.CategoryManager;
import org.limewire.core.settings.DownloadSettings;
import org.limewire.core.settings.SharingSettings;
import org.limewire.gnutella.tests.LimeTestCase;
import org.limewire.listener.EventListener;
import org.limewire.util.AssignManyParametersAction;
import org.limewire.util.AssignParameterAction;
import org.limewire.util.FileUtils;
import org.limewire.http.httpclient.HttpClientInstanceUtils;

import com.google.common.collect.ImmutableMap;
import com.google.inject.Provider;
import com.limegroup.gnutella.ApplicationServices;
import com.limegroup.gnutella.DownloadManager;
import com.limegroup.gnutella.Downloader.DownloadState;
import com.limegroup.gnutella.downloader.DownloadStateEvent;
import com.limegroup.gnutella.downloader.DownloaderType;
import com.limegroup.gnutella.http.HttpClientListener;
import com.limegroup.gnutella.http.HttpExecutor;

public class VirusDefinitionDownloaderImplUnitTest extends LimeTestCase {
    
    private ApplicationServices applicationServices;
    private VirusDefinitionDownloaderImpl downloader;
    private SaveLocationManager saveLocationManager;
    private CategoryManager categoryManager;
    private DownloadManager downloadManager;
    private HttpClientInstanceUtils httpClientInstanceUtils;
    private HttpExecutor httpExecutor;
    private Mockery mock;
    
    public VirusDefinitionDownloaderImplUnitTest(String name) {
        super(name);
    }

    public static Test suite() {
        return buildTestSuite(VirusDefinitionDownloaderImplUnitTest.class);
    }
    
    @Override
    protected void setUp() throws Exception {
        mock = new Mockery();
        applicationServices = mock.mock(ApplicationServices.class);
        saveLocationManager = mock.mock(SaveLocationManager.class);
        categoryManager = mock.mock(CategoryManager.class);
        downloadManager = mock.mock(DownloadManager.class);
        httpClientInstanceUtils = mock.mock(HttpClientInstanceUtils.class);
        httpExecutor = mock.mock(HttpExecutor.class);
        downloader = new VirusDefinitionDownloaderImpl(saveLocationManager,
                categoryManager, downloadManager, httpExecutor, new Provider<HttpParams>() {            
            @Override
            public HttpParams get() {
                return new BasicHttpParams();
            }
        }, httpClientInstanceUtils);
        
        mock.checking(new Expectations() {{
           allowing(applicationServices).getMyGUID();
           will(returnValue(new byte[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}));
           allowing(httpClientInstanceUtils).addClientInfoToUrl("uri");
           will(returnValue("uri?guid=blah"));
            }
        });
    }
    
    public void testInitFromMemento() throws Exception {
        DownloadSettings.NUM_AV_MEMENTOS_RESUMED.set(0);
        VirusDefinitionDownloadMemento memento = new VirusDefinitionDownloadMemento();
        
        File saveFile = new File("c:/test file.txt");
        Map<String, Object> attributes = ImmutableMap.<String, Object>of("key", "value");
        URI uri = new URI("http://limewire.org");
        long amountWritten = 10;
        File incompleteFile = new File("c:/incomplete file.txt");
        
        memento.setDownloadType(downloader.getDownloadType());
        memento.setSaveFile(saveFile);
        memento.setAttributes(attributes);
        memento.setUri(uri);
        memento.setAmountWritten(amountWritten);
        memento.setIncompleteFile(incompleteFile);
        
        downloader.initFromMemento(memento);
        assertEquals(incompleteFile, downloader.getSaveFile()); // uses the incomplete!
        assertEquals("value", downloader.getAttribute("key"));
        assertEquals(uri, downloader.getUri());
        assertEquals(amountWritten, downloader.getAmountWritten());
        assertEquals(incompleteFile, downloader.getIncompleteFile());
        assertEquals(1, DownloadSettings.NUM_AV_MEMENTOS_RESUMED.getValue());
    }
    
    public void testFetchTriggersDownloadManager() throws Exception {
        downloader.setUriAndName(new URI("uri"), "name"); // required for fetch
        
        mock.checking(new Expectations() {{
            one(downloadManager).addNewDownloader(downloader);
        }});
        
        downloader.fetch(new VirusDefinitionHandler() {
            @Override
            public void downloadFailed(File incompleteFile) {
            }
            @Override
            public void downloadSucceeded(File defs) {
            }
        }, null, null);
        
        mock.assertIsSatisfied();
    }
    
    @SuppressWarnings("unchecked")
    public void testStartDownload() throws Exception {
        downloader.setUriAndName(new URI("uri"), "name");
        
        final VirusDefinitionHandler handler = mock.mock(VirusDefinitionHandler.class);
        final AtomicReference<HttpUriRequest> req = new AtomicReference<HttpUriRequest>();
        final AtomicReference<HttpParams> params = new AtomicReference<HttpParams>();
        final AtomicReference<HttpClientListener> clientListener = new AtomicReference<HttpClientListener>();
        final EventListener<DownloadStateEvent> listener = mock.mock(EventListener.class);
        
        mock.checking(new Expectations() {{
            one(downloadManager).addNewDownloader(downloader);
            one(httpExecutor).execute(with(any(HttpUriRequest.class)), with(any(HttpParams.class)), with(any(HttpClientListener.class)));
            will(new AssignManyParametersAction(req, params, clientListener));
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.DOWNLOADING)));
        }});
        downloader.addListener(listener);
        downloader.fetch(handler, null, null);
        assertFalse(downloader.isAlive());
        assertFalse(downloader.isCompleted());
        assertEquals(DownloadState.QUEUED, downloader.getState());
        downloader.startDownload();
        assertTrue(downloader.isAlive());
        assertFalse(downloader.isCompleted());
        assertEquals(DownloadState.DOWNLOADING, downloader.getState());
        
        assertTrue(req.get().getURI().toString().startsWith("uri?guid"));
        assertEquals(2, req.get().getAllHeaders().length); // probably change to two once we hit our server
        assertEquals("AVGINETSDK-LIMEWIRE @version@", req.get().getFirstHeader("User-Agent").getValue());
        assertEquals("close", req.get().getFirstHeader("Connection").getValue());
        
        assertTrue(HttpClientParams.isRedirecting(params.get()));
        
        mock.assertIsSatisfied();
    }
    
    public void testAbortDeletesIncompleteFile() throws Exception {
        downloader.setUriAndName(new URI("uri"), "name");
        File incomplete = downloader.getIncompleteFile();
        assertEquals("name", incomplete.getName());
        assertEquals(SharingSettings.INCOMPLETE_DIRECTORY.get(), incomplete.getParentFile());
        
        FileUtils.touch(incomplete);
        assertTrue(incomplete.exists());
        mock.checking(new Expectations() {{
            ignoring(downloadManager);
        }});
        downloader.stop();
        assertFalse(incomplete.exists());
    }
    
    @SuppressWarnings("unchecked")
    public void testAbortsBeforeDownloadStarts() throws Exception {
        final EventListener<DownloadStateEvent> listener = mock.mock(EventListener.class);
        
        mock.checking(new Expectations() {{
            one(downloadManager).remove(downloader, true);
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.ABORTED)));
        }});
        downloader.addListener(listener);
        downloader.stop();
    }
    
    @SuppressWarnings("unchecked")
    public void testAbortsBeforeRequestCompletes() throws Exception {
        downloader.setUriAndName(new URI("uri"), "name");
        
        final VirusDefinitionHandler handler = mock.mock(VirusDefinitionHandler.class);
        final AtomicReference<HttpGet> httpGet = new AtomicReference<HttpGet>();
        final EventListener<DownloadStateEvent> listener = mock.mock(EventListener.class);
        
        mock.checking(new Expectations() {{
            one(downloadManager).addNewDownloader(downloader);
            one(httpExecutor).execute(with(any(HttpUriRequest.class)), with(any(HttpParams.class)), with(any(HttpClientListener.class)));
            will(new AssignParameterAction<HttpGet>(httpGet));
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.DOWNLOADING)));
        }});
        downloader.addListener(listener);
        downloader.fetch(handler, null, null);
        downloader.startDownload();
        mock.assertIsSatisfied();
        
        mock.checking(new Expectations() {{
            one(downloadManager).remove(downloader, true);
            one(handler).downloadFailed(downloader.getIncompleteFile());
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.ABORTED)));
        }});
        assertFalse(httpGet.get().isAborted());

        downloader.stop();
        assertEquals(DownloadState.ABORTED, downloader.getState());
        assertTrue(httpGet.get().isAborted());
        mock.assertIsSatisfied();
        
        downloader.stop(); // second pass is effectively a noop.
        assertEquals(DownloadState.ABORTED, downloader.getState());
    }
    
    @SuppressWarnings("unchecked")
    public void testDoesntAbortAfterRequestFails() throws Exception {
        downloader.setUriAndName(new URI("uri"), "name");
        
        final VirusDefinitionHandler handler = mock.mock(VirusDefinitionHandler.class);
        final AtomicReference<HttpGet> httpGet = new AtomicReference<HttpGet>();
        final AtomicReference<HttpParams> params = new AtomicReference<HttpParams>();
        final AtomicReference<HttpClientListener> clientListener = new AtomicReference<HttpClientListener>();
        final EventListener<DownloadStateEvent> listener = mock.mock(EventListener.class);
        
        mock.checking(new Expectations() {{
            one(downloadManager).addNewDownloader(downloader);
            one(httpExecutor).execute(with(any(HttpUriRequest.class)), with(any(HttpParams.class)), with(any(HttpClientListener.class)));
            will(new AssignManyParametersAction(httpGet, params, clientListener));
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.DOWNLOADING)));
        }});
        downloader.addListener(listener);
        downloader.fetch(handler, null, null);
        downloader.startDownload();
        mock.assertIsSatisfied();
        
        mock.checking(new Expectations() {{
            one(downloadManager).remove(downloader, true);
            one(handler).downloadFailed(downloader.getIncompleteFile());
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.UNABLE_TO_CONNECT)));            
        }});
        assertFalse(httpGet.get().isAborted());

        clientListener.get().requestFailed(httpGet.get(), null, new IOException());
        mock.assertIsSatisfied();
        
        assertEquals(DownloadState.UNABLE_TO_CONNECT, downloader.getState());
        assertFalse(downloader.isAlive());
        assertFalse(downloader.isCompleted());
        
        downloader.stop();
        assertEquals(DownloadState.UNABLE_TO_CONNECT, downloader.getState());
        assertFalse(downloader.isAlive());
        assertFalse(downloader.isCompleted());
        assertFalse(httpGet.get().isAborted());
    }
    
    @SuppressWarnings("unchecked")
    public void testDoesntAbortAfterRequestSucceeds() throws Exception {
        downloader.setUriAndName(new URI("uri"), "name");
        
        final VirusDefinitionHandler handler = mock.mock(VirusDefinitionHandler.class);
        final AtomicReference<HttpGet> httpGet = new AtomicReference<HttpGet>();
        final AtomicReference<HttpParams> params = new AtomicReference<HttpParams>();
        final AtomicReference<HttpClientListener> clientListener = new AtomicReference<HttpClientListener>();
        final EventListener<DownloadStateEvent> listener = mock.mock(EventListener.class);
        
        mock.checking(new Expectations() {{
            one(downloadManager).addNewDownloader(downloader);
            one(httpExecutor).execute(with(any(HttpUriRequest.class)), with(any(HttpParams.class)), with(any(HttpClientListener.class)));
            will(new AssignManyParametersAction(httpGet, params, clientListener));
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.DOWNLOADING)));
        }});
        downloader.addListener(listener);
        downloader.fetch(handler, null, null);
        downloader.startDownload();
        mock.assertIsSatisfied();
        
        assertFalse(httpGet.get().isAborted());        
        final HttpResponse httpResponse = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, "OK");
        httpResponse.setEntity(new ByteArrayEntity(new byte[1]));

        final Sequence stateSequence = mock.sequence("stateSequence");
        mock.checking(new Expectations() {{
            one(downloadManager).remove(downloader, true);
            one(httpExecutor).releaseResources(httpResponse);
            one(handler).downloadSucceeded(downloader.getIncompleteFile());
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.APPLYING_ANTIVIRUS_DEFINITION_UPDATE)));
            inSequence(stateSequence);
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.COMPLETE)));
            inSequence(stateSequence);            
        }});
        clientListener.get().requestComplete(httpGet.get(), httpResponse);
        mock.assertIsSatisfied();
        
        assertEquals(DownloadState.COMPLETE, downloader.getState());
        assertFalse(downloader.isAlive());
        assertTrue(downloader.isCompleted());
        
        downloader.stop();
        assertEquals(DownloadState.COMPLETE, downloader.getState());
        assertFalse(downloader.isAlive());
        assertTrue(downloader.isCompleted());
        assertFalse(httpGet.get().isAborted());
    }
    
    @SuppressWarnings("unchecked")
    public void testAbortsWhileDownloading() throws Exception {
        downloader.setUriAndName(new URI("uri"), "name");
        
        final VirusDefinitionHandler handler = mock.mock(VirusDefinitionHandler.class);
        final AtomicReference<HttpGet> httpGet = new AtomicReference<HttpGet>();
        final AtomicReference<HttpParams> params = new AtomicReference<HttpParams>();
        final AtomicReference<HttpClientListener> clientListener = new AtomicReference<HttpClientListener>();
        final EventListener<DownloadStateEvent> listener = mock.mock(EventListener.class);
        
        mock.checking(new Expectations() {{
            one(downloadManager).addNewDownloader(downloader);
            one(httpExecutor).execute(with(any(HttpUriRequest.class)), with(any(HttpParams.class)), with(any(HttpClientListener.class)));
            will(new AssignManyParametersAction(httpGet, params, clientListener));
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.DOWNLOADING)));
        }});
        downloader.addListener(listener);
        downloader.fetch(handler, null, null);
        downloader.startDownload();
        mock.assertIsSatisfied();
        
        assertFalse(httpGet.get().isAborted());        
        final HttpResponse httpResponse = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, "OK");
        PipedInputStream in = new PipedInputStream(1);
        PipedOutputStream out = new PipedOutputStream();
        out.connect(in);        
        httpResponse.setEntity(new InputStreamEntity(in, 5));

        mock.checking(new Expectations() {{
            one(downloadManager).remove(downloader, true);
            one(httpExecutor).releaseResources(httpResponse);
            one(handler).downloadFailed(downloader.getIncompleteFile());
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.ABORTED)));
        }});
        
        final CountDownLatch latch = new CountDownLatch(1);
        Thread readThread = new ManagedThread(new Runnable() {
            @Override
            public void run() {
                clientListener.get().requestComplete(httpGet.get(), httpResponse);
                latch.countDown();
            }
        });
        readThread.start(); // send the completion request in another thread, because it will block reading.
        
        out.write(new byte[2]); // wait for a byte to be written, so make sure the other thread starts & reads.
        assertEquals(DownloadState.DOWNLOADING, downloader.getState());
        
        downloader.stop(); // now abort!
        // (and simulate IOException from pipe)
        readThread.interrupt();
        assertTrue(latch.await(2, TimeUnit.SECONDS));
        mock.assertIsSatisfied();
        
        assertEquals(DownloadState.ABORTED, downloader.getState());
        assertFalse(downloader.isAlive());
        assertFalse(downloader.isCompleted());
        assertTrue(httpGet.get().isAborted());
        
        downloader.stop();
        assertEquals(DownloadState.ABORTED, downloader.getState());
        assertFalse(downloader.isAlive());
        assertFalse(downloader.isCompleted());
        assertTrue(httpGet.get().isAborted());
    }
    
    @SuppressWarnings("unchecked")
    public void testDownloadSaves() throws Exception {
        downloader.setUriAndName(new URI("uri"), "name");
        
        final VirusDefinitionHandler handler = mock.mock(VirusDefinitionHandler.class);
        final AtomicReference<HttpGet> httpGet = new AtomicReference<HttpGet>();
        final AtomicReference<HttpParams> params = new AtomicReference<HttpParams>();
        final AtomicReference<HttpClientListener> clientListener = new AtomicReference<HttpClientListener>();
        final EventListener<DownloadStateEvent> listener = mock.mock(EventListener.class);
        
        mock.checking(new Expectations() {{
            one(downloadManager).addNewDownloader(downloader);
            one(httpExecutor).execute(with(any(HttpUriRequest.class)), with(any(HttpParams.class)), with(any(HttpClientListener.class)));
            will(new AssignManyParametersAction(httpGet, params, clientListener));
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.DOWNLOADING)));
        }});
        downloader.addListener(listener);       
        downloader.fetch(handler, null, null);
        downloader.startDownload();
        mock.assertIsSatisfied();
        
        assertFalse(httpGet.get().isAborted());        
        final HttpResponse httpResponse = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, "OK");
        final String outputData = "this is output";
        httpResponse.setEntity(new StringEntity(outputData));

        final Sequence stateSequence = mock.sequence("stateSequence");
        mock.checking(new Expectations() {{
            one(downloadManager).remove(downloader, true);
            one(httpExecutor).releaseResources(httpResponse);
            one(handler).downloadSucceeded(downloader.getIncompleteFile());
            will(new CustomAction("validate contents of incomplete file") {                
                @Override
                public Object invoke(Invocation invocation) throws Throwable {
                    byte[] data = FileUtils.readFileFully((File)invocation.getParameter(0));
                    assertEquals(outputData, new String(data));
                    return null;
                }
            });
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.APPLYING_ANTIVIRUS_DEFINITION_UPDATE)));
            inSequence(stateSequence);
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.COMPLETE)));
            inSequence(stateSequence);            
        }});
        clientListener.get().requestComplete(httpGet.get(), httpResponse);
        mock.assertIsSatisfied();
        
        assertEquals(DownloadState.COMPLETE, downloader.getState());
        assertFalse(downloader.isAlive());
        assertTrue(downloader.isCompleted());
    }
    
    @SuppressWarnings("unchecked")
    public void testNo2XXCode() throws Exception {
        downloader.setUriAndName(new URI("uri"), "name");
        
        final VirusDefinitionHandler handler = mock.mock(VirusDefinitionHandler.class);
        final AtomicReference<HttpGet> httpGet = new AtomicReference<HttpGet>();
        final AtomicReference<HttpParams> params = new AtomicReference<HttpParams>();
        final AtomicReference<HttpClientListener> clientListener = new AtomicReference<HttpClientListener>();
        final EventListener<DownloadStateEvent> listener = mock.mock(EventListener.class);
        
        mock.checking(new Expectations() {{
            one(downloadManager).addNewDownloader(downloader);
            one(httpExecutor).execute(with(any(HttpUriRequest.class)), with(any(HttpParams.class)), with(any(HttpClientListener.class)));
            will(new AssignManyParametersAction(httpGet, params, clientListener));
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.DOWNLOADING)));
        }});
        downloader.addListener(listener);
        downloader.fetch(handler, null, null);
        downloader.startDownload();
        mock.assertIsSatisfied();
        
        assertFalse(httpGet.get().isAborted());        
        final HttpResponse httpResponse = new BasicHttpResponse(HttpVersion.HTTP_1_1, 300, "Not Ok!");
        final String outputData = "this is output";
        httpResponse.setEntity(new StringEntity(outputData));

        mock.checking(new Expectations() {{
            one(downloadManager).remove(downloader, true);
            one(httpExecutor).releaseResources(httpResponse);
            one(handler).downloadFailed(downloader.getIncompleteFile());
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.UNABLE_TO_CONNECT)));
        }});
        clientListener.get().requestComplete(httpGet.get(), httpResponse);
        mock.assertIsSatisfied();
        
        assertEquals(DownloadState.UNABLE_TO_CONNECT, downloader.getState());
        assertFalse(downloader.isAlive());
        assertFalse(downloader.isCompleted());
    }
    
    @SuppressWarnings("unchecked")
    public void test200ButNoEntity() throws Exception {
        downloader.setUriAndName(new URI("uri"), "name");
        
        final VirusDefinitionHandler handler = mock.mock(VirusDefinitionHandler.class);
        final AtomicReference<HttpGet> httpGet = new AtomicReference<HttpGet>();
        final AtomicReference<HttpParams> params = new AtomicReference<HttpParams>();
        final AtomicReference<HttpClientListener> clientListener = new AtomicReference<HttpClientListener>();
        final EventListener<DownloadStateEvent> listener = mock.mock(EventListener.class);
        
        mock.checking(new Expectations() {{
            one(downloadManager).addNewDownloader(downloader);
            one(httpExecutor).execute(with(any(HttpUriRequest.class)), with(any(HttpParams.class)), with(any(HttpClientListener.class)));
            will(new AssignManyParametersAction(httpGet, params, clientListener));
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.DOWNLOADING)));
        }});
        downloader.addListener(listener);
        downloader.fetch(handler, null, null);
        downloader.startDownload();
        mock.assertIsSatisfied();
        
        assertFalse(httpGet.get().isAborted());        
        final HttpResponse httpResponse = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, "OK");

        mock.checking(new Expectations() {{
            one(downloadManager).remove(downloader, true);
            one(httpExecutor).releaseResources(httpResponse);
            one(handler).downloadFailed(downloader.getIncompleteFile());
            one(listener).handleEvent(with(eventTypeMatches(DownloadStateEvent.class, DownloadState.INVALID)));
        }});
        clientListener.get().requestComplete(httpGet.get(), httpResponse);
        mock.assertIsSatisfied();
        
        assertEquals(DownloadState.INVALID, downloader.getState());
        assertFalse(downloader.isAlive());
        assertFalse(downloader.isCompleted());
    }
    
    public void testCreateAndSaveMemento() throws Exception {
        downloader.setUriAndName(new URI("uri"), "name");
        
        File mementoFile = new File("memento");
        mementoFile.delete();
        final VirusDefinitionHandler handler = mock.mock(VirusDefinitionHandler.class);
        final AtomicReference<HttpGet> httpGet = new AtomicReference<HttpGet>();
        final AtomicReference<HttpParams> params = new AtomicReference<HttpParams>();
        final AtomicReference<HttpClientListener> clientListener = new AtomicReference<HttpClientListener>();
        
        mock.checking(new Expectations() {{
            one(downloadManager).addNewDownloader(downloader);
            one(httpExecutor).execute(with(any(HttpUriRequest.class)), with(any(HttpParams.class)), with(any(HttpClientListener.class)));
            will(new AssignManyParametersAction(httpGet, params, clientListener));
        }});
        downloader.setAttribute("key", "value", true);
        downloader.fetch(handler, mementoFile, mementoFile);
        downloader.startDownload();
        mock.assertIsSatisfied();
        
        assertFalse(httpGet.get().isAborted());        
        final HttpResponse httpResponse = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, "OK");
        PipedInputStream in = new PipedInputStream(2);
        PipedOutputStream out = new PipedOutputStream();
        out.connect(in);
        httpResponse.setEntity(new InputStreamEntity(in, 5));

        mock.checking(new Expectations() {{
            one(downloadManager).remove(downloader, true);
            one(httpExecutor).releaseResources(httpResponse);
            one(handler).downloadSucceeded(downloader.getIncompleteFile());
        }});
        
        final CountDownLatch latch = new CountDownLatch(1);
        Thread readThread = new ManagedThread(new Runnable() {
            @Override
            public void run() {
                clientListener.get().requestComplete(httpGet.get(), httpResponse);
                latch.countDown();
            }
        });
        readThread.start(); // send the completion request in another thread, because it will block reading.
        assertFalse(mementoFile.exists());
        out.write(new byte[1]); // write a single byte so the 'now' time is recorded.
        Thread.sleep(1200); // sleep for a second, so the next byte is read after a second & mementos are written.
        out.write(new byte[1]);
        assertEquals(DownloadState.DOWNLOADING, downloader.getState());
        
        Thread.sleep(1200); // sleep a little to let disk i/o process while writing the memento & output data.
        assertEquals(2, downloader.getAmountWritten());
        assertTrue(mementoFile.exists());
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(mementoFile));
        VirusDefinitionDownloadMemento memento = (VirusDefinitionDownloadMemento)ois.readObject();
        ois.close();
        assertEquals(DownloaderType.ANTIVIRUS, memento.getDownloadType());
        assertEquals(downloader.getSaveFile(), memento.getSaveFile());
        assertEquals(ImmutableMap.of("key", "value"), memento.getAttributes());
        assertEquals(new URI("uri"), memento.getUri());
        assertEquals(2, memento.getAmountWritten());
        assertEquals(downloader.getIncompleteFile(), memento.getIncompleteFile());
        
        Thread.sleep(1200); // wait a bit before the next write, to make sure another memento is written.
        out.write(new byte[2]);
        Thread.sleep(1200); // sleep a little to let disk i/o process while writing the memento & output data.
        ois = new ObjectInputStream(new FileInputStream(mementoFile));
        memento = (VirusDefinitionDownloadMemento)ois.readObject();
        ois.close();
        assertEquals(DownloaderType.ANTIVIRUS, memento.getDownloadType());
        assertEquals(downloader.getSaveFile(), memento.getSaveFile());
        assertEquals(ImmutableMap.of("key", "value"), memento.getAttributes());
        assertEquals(new URI("uri"), memento.getUri());
        assertEquals(4, memento.getAmountWritten());
        assertEquals(downloader.getIncompleteFile(), memento.getIncompleteFile());
        
        out.close(); // and close the connection now, things should complete as normal.
        assertTrue(latch.await(2, TimeUnit.SECONDS));
        mock.assertIsSatisfied();
        
        assertEquals(DownloadState.COMPLETE, downloader.getState());
        assertFalse(downloader.isAlive());
        assertTrue(downloader.isCompleted());
        assertFalse(mementoFile.exists());
    }
    
    public void testUsesAmountWrittenForRangeRequest() throws Exception {
        final VirusDefinitionHandler handler = mock.mock(VirusDefinitionHandler.class);
        final AtomicReference<HttpUriRequest> req = new AtomicReference<HttpUriRequest>();
        final AtomicReference<HttpParams> params = new AtomicReference<HttpParams>();
        final AtomicReference<HttpClientListener> clientListener = new AtomicReference<HttpClientListener>();
        
        mock.checking(new Expectations() {{
            one(downloadManager).addNewDownloader(downloader);
            one(httpExecutor).execute(with(any(HttpUriRequest.class)), with(any(HttpParams.class)), with(any(HttpClientListener.class)));
            will(new AssignManyParametersAction(req, params, clientListener));
        }});
        downloader.setUriAndName(new URI("uri"), "name");
        long startPoint = new Random().nextInt(500) + 1; // use a rnd just to make sure it's not hardcoded in the impl
        downloader.setAmountWritten(startPoint);
        downloader.fetch(handler, null, null);
        downloader.startDownload();
        
        assertTrue(req.get().getURI().toString().startsWith("uri?guid"));
        assertEquals(3, req.get().getAllHeaders().length); // probably change to two once we hit our server
        assertEquals("AVGINETSDK-LIMEWIRE @version@", req.get().getFirstHeader("User-Agent").getValue());
        assertEquals("close", req.get().getFirstHeader("Connection").getValue());
        assertEquals("bytes=" + startPoint + "-", req.get().getFirstHeader("Range").getValue());
        
        assertTrue(HttpClientParams.isRedirecting(params.get()));
        
        mock.assertIsSatisfied();        
    }
    
    public void testFailsIfStartPointIsAfterAmountWritten() throws Exception {
       downloader.setUriAndName(new URI("uri"), "name");
        
        final VirusDefinitionHandler handler = mock.mock(VirusDefinitionHandler.class);
        final AtomicReference<HttpGet> httpGet = new AtomicReference<HttpGet>();
        final AtomicReference<HttpParams> params = new AtomicReference<HttpParams>();
        final AtomicReference<HttpClientListener> clientListener = new AtomicReference<HttpClientListener>();
        
        mock.checking(new Expectations() {{
            one(downloadManager).addNewDownloader(downloader);
            one(httpExecutor).execute(with(any(HttpUriRequest.class)), with(any(HttpParams.class)), with(any(HttpClientListener.class)));
            will(new AssignManyParametersAction(httpGet, params, clientListener));
        }});
        downloader.fetch(handler, null, null);
        downloader.startDownload();
        mock.assertIsSatisfied();
        
        final HttpResponse httpResponse = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, "OK");
        final String outputData = "incomplete output";
        httpResponse.setEntity(new StringEntity(outputData));
        httpResponse.addHeader(new BasicHeader("Content-Range", "bytes 5-10/*"));

        mock.checking(new Expectations() {{
            one(downloadManager).remove(downloader, true);
            one(httpExecutor).releaseResources(httpResponse);
            one(handler).downloadFailed(downloader.getIncompleteFile());
        }});
        clientListener.get().requestComplete(httpGet.get(), httpResponse);
        mock.assertIsSatisfied();
        
        assertEquals(DownloadState.INVALID, downloader.getState());
        assertFalse(downloader.isAlive());
        assertFalse(downloader.isCompleted());
    }
    
    public void testWritesAtStartPointAndUpdatesAmountWritten() throws Exception {
       downloader.setUriAndName(new URI("uri"), "name");
        
        final VirusDefinitionHandler handler = mock.mock(VirusDefinitionHandler.class);
        final AtomicReference<HttpGet> httpGet = new AtomicReference<HttpGet>();
        final AtomicReference<HttpParams> params = new AtomicReference<HttpParams>();
        final AtomicReference<HttpClientListener> clientListener = new AtomicReference<HttpClientListener>();
        
        final String predata = "existing data";
        FileOutputStream out = new FileOutputStream(downloader.getIncompleteFile());
        out.write(predata.getBytes());
        out.close();
        
        mock.checking(new Expectations() {{
            one(downloadManager).addNewDownloader(downloader);
            one(httpExecutor).execute(with(any(HttpUriRequest.class)), with(any(HttpParams.class)), with(any(HttpClientListener.class)));
            will(new AssignManyParametersAction(httpGet, params, clientListener));
        }});
        downloader.setAmountWritten(predata.length());
        downloader.fetch(handler, null, null);
        downloader.startDownload();
        mock.assertIsSatisfied();
        
        final HttpResponse httpResponse = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, "OK");
        final String outputData = "incomplete output";
        httpResponse.setEntity(new StringEntity(outputData));
        httpResponse.addHeader(new BasicHeader("Content-Range", "bytes " + predata.length() + "-50/*"));

        mock.checking(new Expectations() {{
            one(downloadManager).remove(downloader, true);
            one(httpExecutor).releaseResources(httpResponse);
            one(handler).downloadSucceeded(downloader.getIncompleteFile());
            will(new CustomAction("validate contents of incomplete file") {                
                @Override
                public Object invoke(Invocation invocation) throws Throwable {
                    byte[] data = FileUtils.readFileFully((File)invocation.getParameter(0));
                    assertEquals(predata + outputData, new String(data));
                    return null;
                }
            });
        }});
        clientListener.get().requestComplete(httpGet.get(), httpResponse);
        mock.assertIsSatisfied();
        
        assertEquals(DownloadState.COMPLETE, downloader.getState());
        assertFalse(downloader.isAlive());
        assertTrue(downloader.isCompleted());
        assertEquals(predata.length() + outputData.length(), downloader.getAmountWritten());        
    }
    
    public void testWritesAtStartPointEvenIfItsBeforeWrittenAndUpdatesAmountWritten() throws Exception {
        downloader.setUriAndName(new URI("uri"), "name");
         
         final VirusDefinitionHandler handler = mock.mock(VirusDefinitionHandler.class);
         final AtomicReference<HttpGet> httpGet = new AtomicReference<HttpGet>();
         final AtomicReference<HttpParams> params = new AtomicReference<HttpParams>();
         final AtomicReference<HttpClientListener> clientListener = new AtomicReference<HttpClientListener>();
         
         final String predata = "existing data";
         FileOutputStream out = new FileOutputStream(downloader.getIncompleteFile());
         out.write(predata.getBytes());
         out.close();
         
         mock.checking(new Expectations() {{
             one(downloadManager).addNewDownloader(downloader);
             one(httpExecutor).execute(with(any(HttpUriRequest.class)), with(any(HttpParams.class)), with(any(HttpClientListener.class)));
             will(new AssignManyParametersAction(httpGet, params, clientListener));
         }});
         downloader.setAmountWritten(predata.length());
         downloader.fetch(handler, null, null);
         downloader.startDownload();
         mock.assertIsSatisfied();
         
         final HttpResponse httpResponse = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, "OK");
         final String outputData = "incomplete output";
         httpResponse.setEntity(new StringEntity(outputData));
         final int startPoint = predata.length() - 5;
         httpResponse.addHeader(new BasicHeader("Content-Range", "bytes " + startPoint + "-50/*"));

         mock.checking(new Expectations() {{
             one(downloadManager).remove(downloader, true);
             one(httpExecutor).releaseResources(httpResponse);
             one(handler).downloadSucceeded(downloader.getIncompleteFile());
             will(new CustomAction("validate contents of incomplete file") {                
                 @Override
                 public Object invoke(Invocation invocation) throws Throwable {
                     byte[] data = FileUtils.readFileFully((File)invocation.getParameter(0));
                     assertEquals(predata.substring(0, startPoint) + outputData, new String(data));
                     return null;
                 }
             });
         }});
         clientListener.get().requestComplete(httpGet.get(), httpResponse);
         mock.assertIsSatisfied();
         
         assertEquals(DownloadState.COMPLETE, downloader.getState());
         assertFalse(downloader.isAlive());
         assertTrue(downloader.isCompleted());
         assertEquals(startPoint + outputData.length(), downloader.getAmountWritten());        
     }    
}
