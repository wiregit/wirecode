package com.limegroup.gnutella.malware;

import java.io.File;
import java.net.URI;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

import junit.framework.Test;

import org.limewire.gnutella.tests.LimeTestCase;
import org.limewire.gnutella.tests.LimeTestUtils;
import org.limewire.listener.EventListener;
import org.limewire.util.FileUtils;
import org.limewire.util.TestUtils;

import com.google.inject.Injector;
import com.limegroup.gnutella.Downloader.DownloadState;
import com.limegroup.gnutella.downloader.DownloadStateEvent;
import com.limegroup.gnutella.util.FileServer;

public class VirusDefinitionDownloaderImplIntegrationTest extends LimeTestCase {
    
    private VirusDefinitionDownloaderImpl downloader;
    private Injector injector;
    private int port;
    private FileServer server;

    public VirusDefinitionDownloaderImplIntegrationTest(String name) {
        super(name);
    }

    public static Test suite() {
        return buildTestSuite(VirusDefinitionDownloaderImplIntegrationTest.class);
    }
    
    @Override
    protected void setUp() throws Exception {
        injector = LimeTestUtils.createInjectorAndStart();
        downloader = (VirusDefinitionDownloaderImpl)injector.getInstance(VirusDefinitionDownloader.class);
        
        File resourceDir = TestUtils.extractResourceDirectory("com/limegroup/gnutella/malware/public_html"); 
        port = 21981;
        server = new FileServer(port, resourceDir);
        server.start();
    }
    
    @Override
    protected void tearDown() throws Exception {
        server.stop();
        server.destroy();
    }
    
    public void testFetchFromServer() throws Exception {
        final CountDownLatch latch = new CountDownLatch(2);
        final AtomicReference<File> incompleteFile = new AtomicReference<File>();
        
        downloader.addListener(new EventListener<DownloadStateEvent>() {
            @Override
            public void handleEvent(DownloadStateEvent event) {
                if(event.getType() == DownloadState.COMPLETE) {
                    latch.countDown();
                }
            }
        });        
        downloader.setUriAndName(new URI("http://localhost:" + port + "/test-file.txt"), "filename");
        downloader.fetch(new VirusDefinitionHandler() {            
            @Override
            public void downloadSucceeded(File defs) {
                incompleteFile.set(defs);
                assertEquals(DownloadState.APPLYING_ANTIVIRUS_DEFINITION_UPDATE, downloader.getState());
                assertEquals("this is a file", new String(FileUtils.readFileFully(defs)));
                latch.countDown();                
            }            
            @Override
            public void downloadFailed(File incompleteFile) {
                fail("should have succeeded! -- failed with file: " + incompleteFile);
            }
        }, new File("memento"), new File("memento backup"));
        
        assertTrue("last state was: " + downloader.getState(), latch.await(2, TimeUnit.SECONDS));
        assertFalse(incompleteFile.get().exists());
    }
    
    public void testRangeFetchFromServer() throws Exception {
        final CountDownLatch latch = new CountDownLatch(2);
        final AtomicReference<File> incompleteFile = new AtomicReference<File>();
        
        downloader.addListener(new EventListener<DownloadStateEvent>() {
            @Override
            public void handleEvent(DownloadStateEvent event) {
                if(event.getType() == DownloadState.COMPLETE) {
                    latch.countDown();
                }
            }
        });        
        downloader.setUriAndName(new URI("http://localhost:" + port + "/test-file.txt"), "filename");
        downloader.setAmountWritten(5);
        downloader.fetch(new VirusDefinitionHandler() {            
            @Override
            public void downloadSucceeded(File defs) {
                incompleteFile.set(defs);
                assertEquals(DownloadState.APPLYING_ANTIVIRUS_DEFINITION_UPDATE, downloader.getState());
                byte[] read = FileUtils.readFileFully(defs);
                assertEquals("this is a file".getBytes().length, read.length); //length of file bytes == full output
                assertEquals("is a file", new String(read, 5, (int)defs.length() - 5)); // bytes read should match
                assertEquals(new byte[] {0, 0, 0, 0, 0}, read, 0, 5); // bytes unread should be unset.
                latch.countDown();                
            }            
            @Override
            public void downloadFailed(File incompleteFile) {
                fail("should have succeeded! -- failed with file: " + incompleteFile);
            }
        }, new File("memento"), new File("memento backup"));
        
        assertTrue("last state was: " + downloader.getState(), latch.await(2, TimeUnit.SECONDS));
        assertFalse(incompleteFile.get().exists());
    }
    
    public void testFailureToConnect() throws Exception {        
        final CountDownLatch latch = new CountDownLatch(2);
        final AtomicReference<File> incompleteFile = new AtomicReference<File>();
        
        downloader.addListener(new EventListener<DownloadStateEvent>() {
            @Override
            public void handleEvent(DownloadStateEvent event) {
                if(event.getType() == DownloadState.UNABLE_TO_CONNECT) {
                    latch.countDown();
                }
            }
        });        
        downloader.setUriAndName(new URI("http://localhost:" + (port+1) + "/test-file.txt"), "filename");
        downloader.fetch(new VirusDefinitionHandler() {            
            @Override
            public void downloadSucceeded(File defs) {
                fail("should have failed");
            }            
            @Override
            public void downloadFailed(File file) {
                incompleteFile.set(file);
                latch.countDown();
            }
        }, new File("memento"), new File("memento backup"));
        
        assertTrue("last state was: " + downloader.getState(), latch.await(6, TimeUnit.SECONDS));
        assertFalse(incompleteFile.get().exists());
    }
    
    public void testWrongFile() throws Exception {        
        final CountDownLatch latch = new CountDownLatch(2);
        final AtomicReference<File> incompleteFile = new AtomicReference<File>();
        
        downloader.addListener(new EventListener<DownloadStateEvent>() {
            @Override
            public void handleEvent(DownloadStateEvent event) {
                if(event.getType() == DownloadState.UNABLE_TO_CONNECT) {
                    latch.countDown();
                }
            }
        });        
        downloader.setUriAndName(new URI("http://localhost:" + port + "/not-a-test-file.txt"), "filename");
        downloader.fetch(new VirusDefinitionHandler() {            
       
            @Override
            public void downloadSucceeded(File defs) {
                fail("should have failed");
            }            
            @Override
            public void downloadFailed(File file) {
                incompleteFile.set(file);
                latch.countDown();
            }
        }, new File("memento"), new File("memento backup"));
        
        assertTrue("last state was: " + downloader.getState(), latch.await(6, TimeUnit.SECONDS));
        assertFalse(incompleteFile.get().exists());
    }
}
