package com.limegroup.gnutella.malware;

import junit.framework.Test;

import org.limewire.core.settings.FilterSettings;
import org.limewire.util.BaseTestCase;

/**
 * Tests that descriptions of dangerous file types are encoded and decoded
 * correctly. 
 */
public class FileExtensionEncoderTest extends BaseTestCase {

    final static String fooMime = "application/x-foo";
    final static String[] fooExt = new String[] {"foo", "football"};
    final static DangerousFileType foo =
        new DangerousFileType(fooMime, fooExt);

    final static String barMime = "application/x-bar";
    final static String[] barExt = new String[] {"bar"};
    final static DangerousFileType bar =
        new DangerousFileType(barMime, barExt);

    public FileExtensionEncoderTest(String name) {
        super(name);
    }

    public static Test suite() {
        return buildTestSuite(FileExtensionEncoderTest.class);
    }

    private void encodeAndDecode(DangerousFileType[] in) throws Exception {
        String setting = FileExtensionEncoder.encodeSetting(in);
        DangerousFileType[] out = FileExtensionEncoder.decodeSetting(setting);
        // Check that the decoded types match the encoded types
        checkTypesMatch(in, out);
    }

    private void checkTypesMatch(DangerousFileType[] in,
            DangerousFileType[] out) throws Exception {
        assertEquals(in.length, out.length);
        for(int i = 0; i < in.length; i++) {
            assertTrue(in[i].mimeType.equals(out[i].mimeType));
            assertEquals(in[i].extensions.length, out[i].extensions.length);
            for(int j = 0; j < in[i].extensions.length; j++)
                assertEquals(in[i].extensions[j], out[i].extensions[j]);
        }
    }

    /**
     * Tests that we remembered to generate a new setting after
     * changing the known file types.
     */
    public void testSettingIsUpToDate() throws Exception {
        String setting = FilterSettings.DANGEROUS_FILE_TYPES.get();
        DangerousFileType[] a = FileExtensionEncoder.decodeSetting(setting);
        DangerousFileType[] b = DangerousFileType.getKnownTypes();
        checkTypesMatch(a, b);
    }

    public void testNoFileTypes() throws Exception {
        encodeAndDecode(new DangerousFileType[0]);
    }

    public void testOneFileType() throws Exception {
        encodeAndDecode(new DangerousFileType[] {foo});
    }

    public void testTwoFileTypes() throws Exception {
        encodeAndDecode(new DangerousFileType[] {foo, bar});
    }

    public void testKnownFileTypes() throws Exception {
        encodeAndDecode(DangerousFileType.getKnownTypes());
    }

    public void testDetectsBrokenSetting() throws Exception {
        String setting = FilterSettings.DANGEROUS_FILE_TYPES.get();
        assertGreaterThan(1, setting.length());
        setting = setting.substring(1); // Borked
        try {
            FileExtensionEncoder.decodeSetting(setting);
        } catch(IllegalArgumentException expected) {
            return;
        }
        fail("decoding should have failed");
    }
}
