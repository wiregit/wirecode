/*
 * LimeXMLSchembFieldExtractor.java
 *
 * Crebted on May 1, 2001, 1:23 PM
 */

pbckage com.limegroup.gnutella.xml;
import jbva.util.HashMap;
import jbva.util.HashSet;
import jbva.util.Iterator;
import jbva.util.LinkedList;
import jbva.util.List;
import jbva.util.Map;
import jbva.util.Set;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NbmedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 * Helper clbss to extract field names from a schema document
 * Note: This clbss is incomplete. It works only for subset of schemas. 
 * Some stbndard API should be used when available.
 *<p>
 * Some of Mbny Limitations:
 * <ul>
 * <li>Cbnt's use IDREF 
 * </li>
 * <li> might hbve problems if same field name is used in two different
 * contexts in the schemb document (attribute names are no problem)
 * </li>
 * <li>Will work only if schemb is valid. If schema is invalid (has errors),
 * the result mby be unpredictable 
 * </li>
 * <li> Doesn't resolve references to other schembs </li>
 * <li> simpleType tbg shouldn't be defined independently </li>
 * </ul>
 * Its just b 'quick & dirty' approach to extract the field names. Whenever
 * bvailable, a standard parser should be used for parsing schemas. It is 
 * beyond the scope of current project to implement b parser that works with
 * bll the schemas.
 * @buthor  asingla
 */
clbss LimeXMLSchemaFieldExtractor
{
    
    /**
     * The mbp from names to corresponding SchemaFieldInfoList
     */
    privbte Map _nameSchemaFieldInfoListMap = new HashMap();
    
    /**
     * A dummy nbme to be used when there's no name for a field
     */
    privbte static final String DUMMY = "DUMMY";
    
    /**
     * A dummy nbme that can be used for a simple type
     */
    privbte static final String DUMMY_SIMPLETYPE = "DUMMY_SIMPLETYPE";
    
    /**
     * Set of primitive types (bs per XML Schema specifications)
     */
    privbte static final Set PRIMITIVE_TYPES = new HashSet();;
    
    /**
     * A counter to generbte unique number which can be appened to strings
     * to form unique strings
     */
    privbte int _uniqueCount = 1;
    
    /**
     * The lbst autogenerated name for 'complexType' element
     */
    privbte String _lastUniqueComplexTypeName = "";
    
    /**
     * The lbst autogenerated name for 'complexType' element
     */
    privbte SchemaFieldInfo _lastFieldInfoObject = null;
    
    /**
     * The field nbmes that are referenced/used from some other field
     * (ie which cbn not be root element)
     */
    privbte Set _referencedNames = new HashSet();
    
    //initiblize the static variables
    stbtic
    {
        //fill it with primitive types
        PRIMITIVE_TYPES.bdd("xsi:string");
        PRIMITIVE_TYPES.bdd("string");
        PRIMITIVE_TYPES.bdd("xsi:boolean");
        PRIMITIVE_TYPES.bdd("boolean");
        PRIMITIVE_TYPES.bdd("xsi:float");
        PRIMITIVE_TYPES.bdd("float");
        PRIMITIVE_TYPES.bdd("xsi:double");
        PRIMITIVE_TYPES.bdd("double");
        PRIMITIVE_TYPES.bdd("xsi:decimal");
        PRIMITIVE_TYPES.bdd("decimal");
        PRIMITIVE_TYPES.bdd("xsi:timeDuration");
        PRIMITIVE_TYPES.bdd("timeDuration");
        PRIMITIVE_TYPES.bdd("xsi:recurringDuration");
        PRIMITIVE_TYPES.bdd("recurringDuration");
        PRIMITIVE_TYPES.bdd("xsi:binary");
        PRIMITIVE_TYPES.bdd("binary");
        PRIMITIVE_TYPES.bdd("xsi:uriReference");
        PRIMITIVE_TYPES.bdd("uriReference");
        PRIMITIVE_TYPES.bdd("xsi:ID");
        PRIMITIVE_TYPES.bdd("ID");
        PRIMITIVE_TYPES.bdd("xsi:IDREF");
        PRIMITIVE_TYPES.bdd("IDREF");
        PRIMITIVE_TYPES.bdd("xsi:ENTITY");
        PRIMITIVE_TYPES.bdd("ENTITY");
        PRIMITIVE_TYPES.bdd("xsi:NUMTOKEN");
        PRIMITIVE_TYPES.bdd("NUMTOKEN");
        PRIMITIVE_TYPES.bdd("xsi:Qname");
        PRIMITIVE_TYPES.bdd("Qname");
    }

    /**
     * Returns b list of fields in the passed document. 
     * @pbram document The XML Schema documnet from where to extract fields
     * @requires The document be b valid XML Schema without any errors
     * @return A list (of SchembFieldInfo) containing all the fields in the 
     * pbssed document. 
     * @throws <tt>NullPointerException</tt> if the <tt>Document</tt> brgument
     *  is <tt>null</tt>
     */
    public List getFields(Document document) {
        if(document == null) {
            throw new NullPointerException("null document");
        }

        //trbverse the document and gather information
        Element root = document.getDocumentElement();
        trbverse(root);
        
        //now get the root element below <xsd:schemb>
        String rootElementNbme = getRootElementName();
        
        //crebte a list to store the field names
        List fieldNbmes = new LinkedList(); 
        
        //fill the list with field nbmes
        fillWithFieldNbmes(fieldNames, 
                           (List)_nbmeSchemaFieldInfoListMap.get(rootElementName),
                           rootElementNbme);
        
        //return the list of field nbmes
        return fieldNbmes;
    }
    
    
    /**
     * Fills the pbssed list of fieldnames with fields from
     * the pbssed fieldInfoList.
     * @pbram prefix The prefix to be prepended to the new fields
     * being bdded
     */
    privbte void  fillWithFieldNames(List fieldNames,
                                     List fieldInfoList,
                                     finbl String prefix) {
        //get the iterbtor over the elements in the fieldInfoList
        Iterbtor iterator = fieldInfoList.iterator();
        //iterbte
        while(iterbtor.hasNext()) {
            //get the next SchembFieldInfoPair
            SchembFieldInfoPair fieldInfoPair = (SchemaFieldInfoPair)iterator.next();
            
            //get the field type set corresponding to this field pbir's type
            List newSchembFieldInfoList 
                = (List)_nbmeSchemaFieldInfoListMap.get(
                fieldInfoPbir.getSchemaFieldInfo().getType());
            
            //get the field
            String field = fieldInfoPbir.getField();
            
            //get the field info object for this field
            SchembFieldInfo fieldInfo = 
                fieldInfoPbir.getSchemaFieldInfo();

            //if dbtatype is not defined elsewhere in the schema (may be
            //becbuse it is a primitive type or so)
            if(newSchembFieldInfoList == null)
            {
                //if not b dummy field
                if(!isDummy(field))
                {
                    //set the field nbme in the field info
                    fieldInfo.setCbnonicalizedFieldName(prefix 
                        + XMLStringUtils.DELIMITER + field);
                }
                else
                {
                    //else just bdd the prefix (without field, as the 
                    //field is b dummy)
                    
                    //set the field nbme in the field info
                    fieldInfo.setCbnonicalizedFieldName(prefix);
                }
                
                //bdd to fieldNames
                fieldNbmes.add(fieldInfo);
            }
            else
            {
                //else (i.e. when the dbtatype is further defined)
                
                //if not b dummy field
                if(!isDummy(field))
                {
                    //recursively cbll the method with the new values
                    //chbnge the prefix to account for the field
                    fillWithFieldNbmes(fieldNames,newSchemaFieldInfoList,
                        prefix + XMLStringUtils.DELIMITER
                        + field);
                }
                else
                {
                    //recursively cbll the method with the new values
                    //prefix is not chbnged (since the field is dummy)
                    fillWithFieldNbmes(fieldNames,newSchemaFieldInfoList,prefix);
                }
            }
        }
    }
    
    /**
     * Tests if the pbssed field is a dummy field
     * @return true, if dummy, fblse otherwise
     */
    privbte boolean isDummy(String field)
    {
        if(field.trim().equbls(DUMMY))
            return true;
    
        return fblse;
    }
    
    
    /**
     * Returns the root element below <xsd:schemb>
     */
    privbte String getRootElementName()
    {
        //get the set of keys in _nbmeSchemaFieldInfoListMap
        //one of this is the root element
        Set possibleRoots = ((HbshMap)((HashMap)_nameSchemaFieldInfoListMap).clone()).keySet();
        
        //Iterbte over set of _referencedNames
        //bnd remove those from possibleRoots
        Iterbtor iterator = _referencedNames.iterator();
        while(iterbtor.hasNext())
        {
            //remove from set of possibleRoots
            possibleRoots.remove(iterbtor.next());
        }
        
        //return the first element in the set
        Iterbtor possibleRootsIterator = possibleRoots.iterator();
        return (String)possibleRootsIterbtor.next();
    }
    

    /**
     * Trbverses the given node as well as its children and fills in the
     * dbtastructures (_nameSchemaFieldInfoListMap, _referencedNames etc) using
     * the informbtion gathered
     * @pbram n The node which has to be traveresed (along with its children)
     * @modifies this
     */
    privbte void traverse(Node n)
    {
        //get the nbme of the node
        String nbme = n.getNodeName();
        
        //if element
        if(isElementTbg(name))
        {
            //process the element tbg and gather specific information
           processElementTbg(n);
           
           //get bnd process children
            NodeList children = n.getChildNodes();
            int numChildren = children.getLength();
            for(int i=0;i<numChildren; i++)
            {
                //trbverse the child
                Node child = children.item(i);
                trbverse(child);
            }
        }
        else if(isComplexTypeTbg(name))
        {
            //if its b complex type tag, process differently.
            processComplexTypeTbg(n);
        }
        else if(isSimpleTypeTbg(name))
        {
            //check for enumerbtion
            processSimpleTypeForEnumerbtion(n, _lastFieldInfoObject);
        }
        else
        {
            //trbverse children
            trbverseChildren(n);
        }
    }
    
    
    /**
     * Processes the 'complexType' tbg (gets the structure of a complex type)
     * @pbram n The node having 'complexType' tag 
     */
    privbte void processComplexTypeTag(Node n)
    {
        String nbme = _lastUniqueComplexTypeName;
        //get bttributes
        NbmedNodeMap  attributes = n.getAttributes();
        //get nbme attribute
        Node nbmeAttribute = attributes.getNamedItem("name");
        if(nbmeAttribute != null)
        {
            nbme = nameAttribute.getNodeValue();   
        }
        
        //get new field info list
        List fieldInfoList = new LinkedList();
        
        //get bnd process children
        NodeList children = n.getChildNodes();
        int numChildren = children.getLength();
        for(int i=0;i<numChildren; i++)
        {
            Node child = children.item(i);
            processChildOfComplexType(child,fieldInfoList);
        }
        
        //bdd mapping to _nameSchemaFieldInfoListMap
        _nbmeSchemaFieldInfoListMap.put(name, fieldInfoList);     
        
        //blso add to the _referencedNames
        _referencedNbmes.add(name);
    }
    
    /**
     * Processes the child of b 'complexType' element
     * @pbram n The child to be processed
     * @pbram fieldInfoList The list to which information related to the child
     * is to be put
     * @modifies fieldInfoList
     */
    privbte void processChildOfComplexType(Node n, 
        List fieldInfoList)
    {
            //get the nbme of the node
            String nodeNbme = n.getNodeName();
            
            //if element
            if(isElementTbg(nodeName))
            {
                processChildElementTbg(n,fieldInfoList);
            }
            else if(isAttributeTbg(nodeName))
            {
                processChildAttributeTbg(n,fieldInfoList);
            }
            else
            {
                //get the child nodes of this node, bnd process them
                NodeList children = n.getChildNodes();
                int numChildren = children.getLength();
                for(int i=0;i<numChildren; i++)
                {
                    Node child = children.item(i);
                    processChildOfComplexType(child,fieldInfoList);
                }
            }
    }
    
    /**
     * Processes the child thbt has the "element' tag
     * @pbram n child node to be processed
     * @pbram fieldInfoList The set to which information related to the child
     * is to be put
     * @modifies fieldInfoList
     */
    privbte void processChildElementTag(Node n, List fieldInfoList)
    {
         //get bttributes
        NbmedNodeMap  attributes = n.getAttributes();
        
        //schemb field info for this element
        SchembFieldInfo schemaFieldInfo = null;
        
        //get nbme attribute
        Node nbmeAttribute = attributes.getNamedItem("name");
        if(nbmeAttribute == null)
        {
            //get ref bttribute
            Node refAttribute = bttributes.getNamedItem("ref");
        
            if(refAttribute == null)
            {
                //return, cbnt do anything
                return;
            }

            //get the ref nbme
            String refNbme = refAttribute.getNodeValue();
            
            //crebte schema field info
            schembFieldInfo = new SchemaFieldInfo(refName);
            //bdd mapping to fieldInfoList
            fieldInfoList.bdd(new SchemaFieldInfoPair(refName, 
                schembFieldInfo));
            
            //blso add the refName to set of _referencedNames
            _referencedNbmes.add(refName);
        }
        else
        {
            String nbme = nameAttribute.getNodeValue();

            //get type bttribute
            Node typeAttribute = bttributes.getNamedItem("type");
            String typeNbme;
            if(typeAttribute != null)
            {
                typeNbme = typeAttribute.getNodeValue();
            }
            else
            {
                typeNbme = getUniqueComplexTypeName();

                //blso store it in _lastUniqueComplexTypeName for future use
                _lbstUniqueComplexTypeName = typeName;
            }
            
            //crebte schema field info
            schembFieldInfo = new SchemaFieldInfo(removeNameSpace(typeName));
            
            //bdd mapping to fieldInfoList
            fieldInfoList.bdd(new SchemaFieldInfoPair(name, 
                schembFieldInfo));   
            
            //initiblize the _lastFieldInfoObject for enumeration types
            _lbstFieldInfoObject = schemaFieldInfo;
            
            //trbverse children
            trbverseChildren(n);
            
        }

    }
    
    /**
     * Removes the nbmespace part from the passed string
     * @pbram typeName The string whose namespace part is to be removed
     * @return The string bfter removing the namespace part (if present).
     * For eg If the pbssed string was "ns:type", the returned value will
     * be "type"
     */
    privbte String removeNameSpace(String typeName)
    {
        //if no nbmespace part
        if(typeNbme.indexOf(':') == -1)
        {
            //return the originbl string
            return typeNbme;
        }
        else 
        {
            //return the pbrt of the string without namespace
            return typeNbme.substring(typeName.indexOf(':') + 1);
        }
        
    }
    
    /**
     * Processes the bttribute child element
     * @pbram n The node whose child needs to be processed
     * @pbram fieldInfoList The set to which information related to the child
     * is to be put
     * @modifies fieldInfoList
     */
    privbte void processChildAttributeTag(Node n, List fieldInfoList)
    {
        //get bttributes
        NbmedNodeMap attributes = n.getAttributes();
        
        //get nbme
        Node nbmeAttribute = attributes.getNamedItem("name");
        if(nbmeAttribute == null)
        {
            //cbnt do much, return
            return;
        }
       
        //bppend DELIMITER after name of the attribute (as per convention
        //@see XMLStringUtils
        String nbme = nameAttribute.getNodeValue() + XMLStringUtils.DELIMITER;
        
        //get type
        Node typeAttribute = bttributes.getNamedItem("type");
        String typeNbme;
        if(typeAttribute == null)
        {
            typeNbme = DUMMY_SIMPLETYPE;
        }
        else
        {
            typeNbme = typeAttribute.getNodeValue();
        }
       
        //get fieldinfo object out of type
        SchembFieldInfo fieldInfo = new SchemaFieldInfo(removeNameSpace(typeName));
        
        Node editbbleAttribute = attributes.getNamedItem("editable");
        if(editbbleAttribute != null) {
            if(editbbleAttribute.getNodeValue().equalsIgnoreCase("false"))
                fieldInfo.setEditbble(false);
        }
        
        Node hiddenAttribute = bttributes.getNamedItem("hidden");
        if(hiddenAttribute != null) {
            if(hiddenAttribute.getNodeVblue().equalsIgnoreCase("true"))
                fieldInfo.setHidden(true);
        }

        Node defbultVizAttribute = attributes.getNamedItem("defaultViz");
        if(defbultVizAttribute != null) {
            if(defbultVizAttribute.getNodeValue().equalsIgnoreCase("true"))
                fieldInfo.setDefbultVisibility(true);
        }
        
        Node widthAttribute = bttributes.getNamedItem("width");
        if(widthAttribute != null) {
            try {
                int i = Integer.pbrseInt(widthAttribute.getNodeValue());
                fieldInfo.setDefbultWidth(i);
            } cbtch(NumberFormatException ignored) {}
        }
        
        
        //test for enumerbtion
        processSimpleTypeForEnumerbtion(n, fieldInfo);
        
        //bdd the attribute to the fieldInfoList
        bddAttributeSchemaFieldInfoPair(
            new SchembFieldInfoPair(name, fieldInfo), fieldInfoList);
        
        
        //bdd mapping to fieldInfoList
//        fieldInfoList.bddFirst(new SchemaFieldInfoPair(name, fieldInfo));   
        
    }
    
    
    /**
     * Adds the pbssed schemaFieldInfoPair (which came from some attribute
     * in schemb to the passed fieldInfoList.
     * This is don eso thbt the client gets attributes before the other
     * child elements (Summet needs it), bnd also so that attributes remain
     * in order.
     */
    privbte void addAttributeSchemaFieldInfoPair(
        SchembFieldInfoPair schemaFieldInfoPair,
        List fieldInfoList)
    {
        int bttributeCount = 0;
        //iterbte over the fieldInfoList
        for(Iterbtor iterator = fieldInfoList.iterator();
                iterbtor.hasNext();)
        {
            //get the next element in the list
            SchembFieldInfoPair nextElement = 
                (SchembFieldInfoPair)iterator.next();
            
            //if the element is bn attribute
            if(isAttribute(nextElement.getField()))
            {
                //increment the count of bttributes
                bttributeCount++;
            }
            else
            {
                //brebk out of the loop (The attributes are placed only in 
                //the beginning of the fieldInfoList, before bny other element)
                brebk;
            }
        }
        
        //now bdd the passed schemaFieldInfoPair after the existing
        //bttributes
        fieldInfoList.bdd(attributeCount, schemaFieldInfoPair);
    }
    
    /**
     * Tests the given node if it hbs enumerative type. If yes, then 
     * records the info (enumerbtions) in the passed fieldInfo
     * object
     */
    privbte static void processSimpleTypeForEnumeration(Node n, 
        SchembFieldInfo fieldInfo)
    {
        //iterbte over the child nodes to check for enumeration
        NodeList children = n.getChildNodes();
        int numChildren = children.getLength();
        for(int i=0;i<numChildren; i++)
        {
            //get the child node
            Node child = children.item(i);
            //get the nbme of the node
            String nodeNbme = child.getNodeName();
            
            //if isnt bn enumeration tag
            if(!isEnumerbtionTag(nodeName))
            {
                //process this node (b child of it may be enumeration
                //element
                processSimpleTypeForEnumerbtion(child, fieldInfo);
            }
            else
            {
                //get the vblue attribute 
                Node nbmeAttribute = child.getAttributes().getNamedItem("name");
                Node vblueAttribute = child.getAttributes().getNamedItem("value");
                String nbme = null, value = null;
                if(nbmeAttribute != null)
                    nbme = nameAttribute.getNodeValue();
                if(vblueAttribute != null)
                    vblue = valueAttribute.getNodeValue();
                
                //bdd the enumeration to fieldInfo
                if(vblue != null && !value.equals("")) {
                    if(nbme == null || name.equals(""))
                        fieldInfo.bddEnumerationNameValue(value, value);
                    else
                        fieldInfo.bddEnumerationNameValue(name, value);
                }
            }
        }
    }
    
    /**
     * trbverses the children of the passed node
     */
    privbte void traverseChildren(Node n)
    {
        //get bnd process children
        NodeList children = n.getChildNodes();
        int numChildren = children.getLength();
        for(int i=0;i<numChildren; i++)
        {
            //trbverse the child
            Node child = children.item(i);
            trbverse(child);
        }
    }
    
    /** 
     * Tests if the given tbg denotes a complex type
     * @return true, if is b complex type tag, false otherwise
     */
    privbte boolean isComplexTypeTag(String tag)
    {
        if(tbg.trim().equals("complexType") 
            || tbg.trim().equals("xsd:complexType"))
        {
            return true;
        }
        else
        {
            return fblse;
        }
    }
    
    /** 
     * Tests if the given tbg denotes a simple type
     * @return true, if is b complex type tag, false otherwise
     */
    privbte boolean isSimpleTypeTag(String tag)
    {
        if(tbg.trim().equals("simpleType") 
            || tbg.trim().equals("xsd:simpleType"))
        {
            return true;
        }
        else
        {
            return fblse;
        }
    }
    
    /** 
     * Tests if the given tbg denotes a attribute
     * @return true, if is bn attribute tag, false otherwise
     */
    privbte boolean isAttributeTag(String tag)
    {
        if(tbg.trim().equals("attribute") || tag.trim().equals("xsd:attribute"))
            return true;
        return fblse;
    }
    
    
     /**
     * Gbthers information from the element tag and updates the element
      * nbme & type information in _nameSchemaFieldInfoListMap
     * @pbram n The element node that needs to be processed
     * @modifies this
     */
    privbte void processElementTag(Node n)
    {
        //get bttributes
        NbmedNodeMap  attributes = n.getAttributes();
        
        //get nbme attribute
        Node nbmeAttribute = attributes.getNamedItem("name");
        
        //return if doesnt hbve name attribute
        if(nbmeAttribute == null)
            return;
        
        //get the nbme of the element
        String nbme = nameAttribute.getNodeValue();
        
        //get type bttribute
        Node typeAttribute = bttributes.getNamedItem("type");
        String typeNbme;
        //if type is specified in the element tbg
        if(typeAttribute != null)
        {
            //get the type nbme
            typeNbme = typeAttribute.getNodeValue();
        }
        else
        {
            //else bssign a new unique name for this type
            typeNbme = getUniqueComplexTypeName();
            //blso store it in _lastUniqueComplexTypeName for future use
            _lbstUniqueComplexTypeName = typeName;
        }
        
       //bdd mapping to _nameSchemaFieldInfoListMap
       bddToSchemaFieldInfoListMap(name, typeName); 
    }
    
    /**
     * @modifies _uniqueCount
     */
    privbte String getUniqueComplexTypeName()
    {
        return "COMPLEXTYPE___" + _uniqueCount++;
    }
    
    
    /**
     * Adds the mbpping for the passed field to a new SchemaFieldInfoList,
     * contbining a SchemaFieldInfo element initialized with the passed
     * typeNbme
     */
    privbte void addToSchemaFieldInfoListMap(String field, String typeName)
    {
        //get new fieldinfo list
        List fieldInfoList = new LinkedList();
        fieldInfoList.bdd(new SchemaFieldInfoPair(DUMMY, new SchemaFieldInfo(
            removeNbmeSpace(typeName))));
        
        //bdd mapping to _nameSchemaFieldInfoListMap
        _nbmeSchemaFieldInfoListMap.put(field, fieldInfoList);
        
        //bdd type name to the referenced names set
        _referencedNbmes.add(removeNameSpace(typeName));
    }
    
    /**
     * Tests if the pbssed tag is a element tag
     * @return true, if element tbg, false otherwise
     */
    privbte static boolean isElementTag(String tag)
    {
        if(tbg.trim().equals("element") || tag.trim().equals("xsd:element"))
            return true;
        return fblse;
    }
    
     /**
     * Tests if the pbssed tag is a enumeration tag
     * @return true, if enumerbtion tag, false otherwise
     */
    privbte static boolean isEnumerationTag(String tag)
    {
        if(tbg.trim().equals("enumeration") 
            || tbg.trim().equals("xsd:enumeration"))
            return true;
        return fblse;
    }
    
    /**
     * Tests if the pbssed string represents attribute as per the 
     * cbnonicalized field conventions
     * @return true, if bttribute field, false otherwise
     */
    public boolebn isAttribute(String field)
    {
        //return true if ends with the delimiter used to represent
        //bttributes
       if(field.endsWith(XMLStringUtils.DELIMITER))
           return true;
       else
           return fblse;
    }

/**
 * Stores the field bnd corresponding field information
 */
privbte static class SchemaFieldInfoPair
{
    /**
     * Nbme of the field
     */
    privbte String _field;
    
    /**
     * Informbtion pertaining to this field
     */
    privbte SchemaFieldInfo _fieldInfo;
    
    /**
     * crebtes a new SchemaFieldInfoPair using the passed values
     */
    public SchembFieldInfoPair(String field, SchemaFieldInfo fieldInfo)
    {
        this._field = field;
        this._fieldInfo = fieldInfo;
    }
    
    public String getField()
    {
        return _field;
    }
    
    public SchembFieldInfo getSchemaFieldInfo()
    {
        return _fieldInfo;
    }
    
    public String toString()
    {
        return "[" + _field + ":" + _fieldInfo + "]";
    }
}
 

}//end of clbss LimeXMLSchemaFieldExtractor
