package com.limegroup.gnutella.malware;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URI;
import java.util.Collections;
import java.util.List;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.client.params.HttpClientParams;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpParams;
import org.limewire.core.api.download.DownloadException;
import org.limewire.core.api.download.DownloadSourceInfo;
import org.limewire.core.api.download.SaveLocationManager;
import org.limewire.core.api.file.CategoryManager;
import org.limewire.core.settings.SharingSettings;
import org.limewire.io.Address;
import org.limewire.io.GUID;
import org.limewire.io.IOUtils;
import org.limewire.listener.EventListener;
import org.limewire.listener.EventListenerList;
import org.limewire.logging.Log;
import org.limewire.logging.LogFactory;
import org.limewire.nio.observer.Shutdownable;
import org.limewire.util.FileUtils;

import com.google.inject.Inject;
import com.limegroup.gnutella.BandwidthTrackerImpl;
import com.limegroup.gnutella.DownloadManager;
import com.limegroup.gnutella.InsufficientDataException;
import com.limegroup.gnutella.RemoteFileDesc;
import com.limegroup.gnutella.URN;
import com.limegroup.gnutella.downloader.AbstractCoreDownloader;
import com.limegroup.gnutella.downloader.CoreDownloader;
import com.limegroup.gnutella.downloader.DownloadStateEvent;
import com.limegroup.gnutella.downloader.DownloaderType;
import com.limegroup.gnutella.downloader.serial.DownloadMemento;
import com.limegroup.gnutella.http.HTTPHeaderName;
import com.limegroup.gnutella.http.HttpClientListener;
import com.limegroup.gnutella.http.HttpExecutor;
import com.limegroup.gnutella.util.LimeWireUtils;

public class VirusDefinitionDownloader extends AbstractCoreDownloader
implements HttpClientListener, CoreDownloader, EventListener<DownloadStateEvent> {

    private static final Log LOG =
        LogFactory.getLog(VirusDefinitionDownloader.class);

    private static final String AVG_LW_USER_AGENT = "AVGINETSDK-LIMEWIRE";
    private static final String AVG_LW_HOST = "af.avg.com";

    private final DownloadManager downloadManager;
    private final HttpExecutor httpExecutor;
    private final EventListenerList<DownloadStateEvent> eventListenerList;
    private final BandwidthTrackerImpl bandwidthTracker;

    private URI uri = null;
    private File incompleteFile = null;
    private VirusDefinitionHandler handler = null;
    private DownloadState state = DownloadState.QUEUED;
    private volatile Shutdownable aborter;
    private volatile long contentLength = 0;
    private volatile long amountRead = 0;

    @Inject
    public VirusDefinitionDownloader(SaveLocationManager saveLocationManager,
            CategoryManager categoryManager, DownloadManager downloadManager,
            HttpExecutor httpExecutor) {
        super(saveLocationManager, categoryManager);
        this.downloadManager = downloadManager;
        this.httpExecutor = httpExecutor;
        eventListenerList = new EventListenerList<DownloadStateEvent>();
        bandwidthTracker = new BandwidthTrackerImpl();
        addListener(this);
    }

    public void fetch(URI uri, String name, VirusDefinitionHandler handler) {
        this.uri = uri;
        this.handler = handler;
        incompleteFile =
            new File(SharingSettings.INCOMPLETE_DIRECTORY.get(), name);
        downloadManager.addNewDownloader(this);
    }

    @Override
    public boolean requestComplete(HttpUriRequest method, HttpResponse response) {
        aborter = null;
        if(state == DownloadState.ABORTED)
            return false;
        InputStream downloadStream = null;
        OutputStream outputStream = null;
        int status = response.getStatusLine().getStatusCode();
        if(status < 200 || status >= 300) {
            if(LOG.isErrorEnabled())
                LOG.error("Bad status code: " + status);
            state = DownloadState.UNABLE_TO_CONNECT;
            httpExecutor.releaseResources(response);
            handler.downloadFailed();
            eventListenerList.broadcast(new DownloadStateEvent(this, state));
            return false;
        }
        HttpEntity entity = response.getEntity();
        if(entity == null) {
            if(LOG.isErrorEnabled())
                LOG.error("Invalid response: no entity");
            state = DownloadState.INVALID;
            httpExecutor.releaseResources(response);
            handler.downloadFailed();
            eventListenerList.broadcast(new DownloadStateEvent(this, state));
            return false;
        }
        long length = entity.getContentLength();
        contentLength = length > 0 ? length : 0;
        incompleteFile.getParentFile().mkdirs();
        try {
            outputStream = new BufferedOutputStream(
                    new FileOutputStream(incompleteFile));
            downloadStream = entity.getContent();
            int read = 0;
            byte[] buf = new byte[1024];
            while((read = downloadStream.read(buf, 0, buf.length)) != -1) {
                amountRead += read;
                outputStream.write(buf, 0, read);
            }
            state = DownloadState.COMPLETE;
        } catch(IOException e) {
            state = DownloadState.INVALID;
            e.printStackTrace();
            if(LOG.isErrorEnabled())
                LOG.error("Error downloading virus definitions from " + uri, e);
        } finally {
            IOUtils.close(downloadStream);
            IOUtils.close(outputStream);
            httpExecutor.releaseResources(response);
            handler.downloadSucceeded(incompleteFile);
            deleteIncompleteFiles();
        }

        eventListenerList.broadcast(new DownloadStateEvent(this, state));
        return false;
    }

    @Override
    public boolean requestFailed(HttpUriRequest method, HttpResponse response,
            IOException e) {
        state = DownloadState.UNABLE_TO_CONNECT;
        downloadManager.remove(this, true);
        handler.downloadSucceeded(null);
        eventListenerList.broadcast(
                new DownloadStateEvent(this, DownloadState.UNABLE_TO_CONNECT));
        return false;
    }

    @Override
    public void discardCorruptDownload(boolean delete) {
    }

    @Override
    public void discardUnscannedPreview(boolean delete) {
    }

    @Override
    public long getAmountLost() {
        return 0;
    }

    @Override
    public int getAmountPending() {
        return 0;
    }

    @Override
    public long getAmountRead() {
        return amountRead;
    }

    @Override
    public long getAmountVerified() {
        return 0;
    }

    @Override
    public List<RemoteFileDesc> getRemoteFileDescs() {
        return Collections.emptyList();
    }

    @Override
    public int getChunkSize() {
        return 1;
    }

    @Override
    public long getContentLength() {
        return contentLength;
    }

    @Override
    public File getDownloadFragment(ScanListener listener) {
        return null;
    }

    @Override
    public File getFile() {
        return getSaveFile();
    }

    @Override
    public int getNumHosts() {
        return 0;
    }

    @Override
    public List<Address> getSourcesAsAddresses() {
        return Collections.emptyList();
    }

    @Override
    public List<DownloadSourceInfo> getSourcesDetails() {
        return Collections.emptyList();
    }

    @Override
    public int getQueuePosition() {
        return 0;
    }

    @Override
    public int getQueuedHostCount() {
        return 0;
    }

    @Override
    public int getRemainingStateTime() {
        return 0;
    }

    @Override
    public URN getSha1Urn() {
        return null;
    }

    @Override
    public File getSaveFile() {
        return incompleteFile;
    }

    @Override
    public void setSaveFile(File saveDirectory, String fileName,
            boolean overwrite) throws DownloadException {
    }

    @Override
    public DownloadState getState() {
        return state;
    }

    @Override
    public String getVendor() {
        return null;
    }

    @Override
    public boolean isCompleted() {
        return state == DownloadState.COMPLETE;
    }

    @Override
    public boolean isInactive() {
        return false;
    }

    @Override
    public boolean isLaunchable() {
        return false;
    }

    @Override
    public boolean isPausable() {
        return false;
    }

    @Override
    public boolean isPaused() {
        return false;
    }

    @Override
    public boolean isRelocatable() {
        return false;
    }

    @Override
    public boolean isResumable() {
        return false;
    }

    @Override
    public void pause() {
    }

    @Override
    public boolean resume() {
        return false;
    }

    @Override
    public void stop() {
        state = DownloadState.ABORTED;
        if(aborter != null) {
            aborter.shutdown();
            aborter = null;
        }
        downloadManager.remove(this, true);
    }

    @Override
    public float getAverageBandwidth() {
        return bandwidthTracker.getAverageBandwidth();
    }

    @Override
    public float getMeasuredBandwidth() throws InsufficientDataException {
        return bandwidthTracker.getMeasuredBandwidth();
    }

    @Override
    public void measureBandwidth() {
        bandwidthTracker.measureBandwidth(amountRead);
    }

    @Override
    public int getTriedHostCount() {
        return -1;
    }

    @Override
    public String getCustomIconDescriptor() {
        return null;
    }

    @Override
    public void finish() {
    }

    @Override
    public GUID getQueryGUID() {
        return null;
    }

    @Override
    public void handleInactivity() {
    }

    @Override
    public void initialize() {
    }

    @Override
    public boolean isAlive() {
        return false;
    }

    @Override
    public boolean isQueuable() {
        return false;
    }

    @Override
    public void setInactivePriority(int priority) {
    }

    @Override
    public boolean shouldBeRemoved() {
        return isCompleted() ||
        state == DownloadState.ABORTED ||
        state == DownloadState.INVALID ||
        state == DownloadState.UNABLE_TO_CONNECT;
    }

    @Override
    public boolean shouldBeRestarted() {
        return state == DownloadState.QUEUED;
    }

    @Override
    public void startDownload() {
        HttpGet get = new HttpGet(uri);
        get.addHeader("User-Agent", AVG_LW_USER_AGENT + " " +
                LimeWireUtils.getLimeWireVersion());
        get.addHeader("Host", AVG_LW_HOST);
        get.addHeader(HTTPHeaderName.CONNECTION.httpStringValue(), "close");

        HttpParams params = new BasicHttpParams();
        HttpClientParams.setRedirecting(params, true);
        state = DownloadState.DOWNLOADING;
        aborter = httpExecutor.execute(get, params, this);
    }

    @Override
    public DownloaderType getDownloadType() {
        return DownloaderType.ANTIVIRUS;
    }

    @Override
    public void addListener(EventListener<DownloadStateEvent> listener) {
        eventListenerList.addListener(listener);
    }

    @Override
    public boolean removeListener(EventListener<DownloadStateEvent> listener) {
        return eventListenerList.removeListener(listener);
    }

    @Override
    public boolean allowRequest(HttpUriRequest request) {
        return true;
    }

    @Override
    public boolean isMementoSupported() {
        return false;
    }

    @Override
    protected DownloadMemento createMemento() {
        return null;
    }

    @Override
    protected File getDefaultSaveFile() {
        return getSaveFile();
    }

    @Override
    public boolean conflicts(URN urn, long fileSize, File... files) {
        return false;
    }

    @Override
    public boolean conflictsWithIncompleteFile(File incomplete) {
        return false;
    }

    @Override
    public void handleEvent(DownloadStateEvent event) {
        if(DownloadState.COMPLETE == event.getType()) {
            downloadManager.remove(this, true);
        }
    }

    @Override
    public void deleteIncompleteFiles() {
        FileUtils.forceDelete(incompleteFile);
    }
}
