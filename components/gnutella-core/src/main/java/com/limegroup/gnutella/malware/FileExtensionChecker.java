package com.limegroup.gnutella.malware;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Locale;

import org.limewire.core.settings.FilterSettings;
import org.limewire.io.IOUtils;
import org.limewire.util.FileUtils;

import com.google.inject.Inject;

/**
 * Compares the initial bytes of a file to its extension to ensure that, if
 * the initial bytes indicate a dangerous file type, the extension indicates
 * the same file type. See FileExtensionEncoder for the defined types. 
 */
public class FileExtensionChecker implements DangerousFileChecker {

    private DangerousFileType[] fileTypes;
    private int magicLength;

    private boolean loaded = false;
    
    @Inject
    public FileExtensionChecker() {
    }

    private void init() {
        DangerousFileType[] ft;
        try {
            String setting = FilterSettings.DANGEROUS_FILE_TYPES.get();
            ft = FileExtensionEncoder.decodeSetting(setting);
        } catch(IllegalArgumentException e) {
            ft = new DangerousFileType[0];
        }
        fileTypes = ft;
        // Work out how many bytes we need to read
        int max = 0;
        for(DangerousFileType d : fileTypes) {
            if(d.magic.length > max)
                max = d.magic.length;
        }
        magicLength = max;
        
        loaded = true;
    }
    
    /**
     * Returns the number of dangerous file types the checker knows about.
     * Package access for testing.
     */
    int getNumKnownTypes() {
        if (!loaded) {
            init();
        }
        
        return fileTypes.length;
    }

    /**
     * Returns true if the file's initial bytes indicate a dangerous type
     * but the extension does not.
     */
    @Override
    public boolean isDangerous(File file) {
        if (!loaded) {
            init();
        }        
        
        // Read the first bytes of the file
        byte[] magic = new byte[magicLength];
        FileInputStream in = null;
        try {
            in = new FileInputStream(file);
            int read = 0;
            while(read < magic.length) {
                int i = in.read(magic, read, magic.length - read);
                if(i == -1)
                    break;
                read += i;
            }
        } catch(IOException e) {
            return false;
        } finally {
            IOUtils.close(in);
        }
        // Get the extension (empty if there's no extension)
        String ext = FileUtils.getFileExtension(file).toLowerCase(Locale.US);
        // Check each dangerous file type
        for(DangerousFileType d : fileTypes) {
            boolean dangerous = true;
            for(int i = 0; i < d.magic.length; i++) {
                if(magic[i] != d.magic[i]) {
                    dangerous = false;
                    break; // Check the next file type
                }

            }
            if(dangerous) {
                for(String s : d.extensions) {
                    if(s.equals(ext))
                        return false; // Dangerous but honest
                }
                return true;
            }
        }
        return false;
    }
}
