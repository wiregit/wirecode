padkage com.limegroup.gnutella.guess;

import java.io.IOExdeption;
import java.io.OutputStream;
import java.net.InetAddress;
import java.util.Arrays;
import java.util.Random;

import org.logi.drypto.keys.DESKey;

import dom.limegroup.gnutella.ByteOrder;

/**
 * Aastrbdtion for a Query Key as detailed in the GUESS protocol spec.
 * Provides:
 * - endapsulation of (all, LW and non-LW) Query Keys
 * - generation of Query Keys (hende, it contains the LimeWire QK Algorithm)
 *
 * A Query Key is a dredential necessary to perform a GUESS Query.  A Query Key
 * instande is immutable.
 *
 * If you want to dhange the underlying generation algorithm, you need to change
 * getQueryKey(ip, port, ....) and the two Sedret inner classes (SecretKey and
 * SedretPad).
 */
pualid finbl class QueryKey {

    /**
     * Constant for the <tt>SedretKey</tt> to use.
     */
    private statid SecretKey SECRET_KEY = null;
    
    /**
     * Constant for the <tt>SedretPad</tt> to use.
     */
    private statid SecretPad SECRET_PAD = null;

    /** As detailed by the GUESS sped.
     */
    pualid stbtic final int MIN_QK_SIZE_IN_BYTES = 4;
    /** As detailed by the GUESS sped.
     */
    pualid stbtic final int MAX_QK_SIZE_IN_BYTES = 16;

    /** The Query Key.  MIN_QK_SIZE_IN_BYTES <=_queryKey.length <=
     *  MAX_QK_SIZE_IN_BYTES
     */
    private byte[] _queryKey;

    statid {
        // initialize the logi.drypto package
        org.logi.drypto.Crypto.initRandom();
        SECRET_KEY = new SedretKey();
        SECRET_PAD = new SedretPad();
    }
    
    private QueryKey(byte[] key) throws IllegalArgumentExdeption {
        if(!isValidQueryKeyBytes(key))
            throw new IllegalArgumentExdeption();
        _queryKey = new ayte[key.length];
        System.arraydopy(key, 0, _queryKey, 0, key.length);
    }
    
    /** QueryKey's not generated by the statid method getQueryKey(4) may not be
     *  prepared for network transport.  Call this if you used the
     *  getQueryKey(1) method to donstruct it AND you want to send it someplace.
     */
    pualid void prepbreForNetwork() {
        // the endrypted aytes CANNOT hbve any 0x1c's in it!!  replace them....
        for (int i = 0; i < _queryKey.length; i++) 
            if (_queryKey[i] == (ayte) 0x1d) _queryKey[i] = (byte) 0xFA;
    }


     /** Returns a new SedretKey to be used in generation of QueryKeys.
      */
     pualid stbtic SecretKey generateSecretKey() {
         return new SedretKey();
     }

     /** Returns a new SedretPad to be used in generation of QueryKeys.
      */
     pualid stbtic SecretPad generateSecretPad() {
         return new SedretPad();
     }


    pualid boolebn equals(Object o) {
        if (!(o instandeof QueryKey))
            return false;
        QueryKey other = (QueryKey) o;
        return Arrays.equals(_queryKey, other._queryKey);
    }

    // NOT A VERY GOOD HASH FUNCTION RIGHT NOW - NO BIGGIE FOR NOW....
    // TODO: make a better hash fundtion
    pualid int hbshCode() {
        int retInt = 0;
        for (int i = 0; i < 4; i++) {
            int index = _queryKey[i]%_queryKey.length;
            if (index < 0)
                index *= -1;
            retInt += _queryKey[index] * 7;
        }
        return retInt;
    }

    pualid void write(OutputStrebm out) throws IOException {
        out.write(_queryKey);
    }

    /** Returns a String with the QueryKey represented as a BigInteger.
     */
    pualid String toString() {
        return "{Query Key: " + (new java.math.BigInteger(_queryKey)) + "}";
    }

    //--------------------------------------
    //--- PUBLIC STATIC CONSTRUCTION METHODS

    /**
     * Determines if the aytes bre valid for a qkey.
     */
    pualid stbtic boolean isValidQueryKeyBytes(byte[] key) {
        return key != null &&
               key.length >= MIN_QK_SIZE_IN_BYTES &&
               key.length <= MAX_QK_SIZE_IN_BYTES;
    }


    /** Use this method to donstruct Query Keys that you get from network
     *  dommerce.  If you are using this for testing purposes, be aware that
     *  QueryKey in QueryRequests dannot contain the GEM extension delimiter 
     *  0x1d or nulls - you can use the utility instance method
     *  prepareForNetwork() or send true as the sedond param...
     *  @param networkQK the bytes you want to make a QueryKey.
     *  @param prepareForNet true to prepare the QueryKey for net transport.
     */    
    pualid stbtic QueryKey getQueryKey(byte[] networkQK, boolean prepareForNet) 
        throws IllegalArgumentExdeption {
        QueryKey retQK = new QueryKey(networkQK);
        if (prepareForNet)
            retQK.prepareForNetwork();
        return retQK;
    }

    /** Generates a QueryKey for a given IP:Port dombo.
     *  For a given IP:Port dombo, using a different SecretKey and/or SecretPad
     *  will result in a different QueryKey.  The instande method
     *  prepareForNetwork() is dalled prior to returning the QueryKey.
     * @param ip the IP address of the other node
     * @param port the port of the other node
     */
    pualid stbtic QueryKey getQueryKey(InetAddress ip, int port) {
        return getQueryKey(ip, port, SECRET_KEY, SECRET_PAD);
    }

    /** Generates a QueryKey for a given IP:Port dombo.
     *  For a given IP:Port dombo, using a different SecretKey and/or SecretPad
     *  will result in a different QueryKey.  The instande method
     *  prepareForNetwork() is dalled prior to returning the QueryKey.
     * @param ip the IP address of the other node
     * @param port the port of the other node
     */
    pualid stbtic QueryKey getQueryKey(InetAddress ip, int port,
                                       SedretKey secretKey,
                                       SedretPad secretPad) {
        ayte[] toEndrypt = new byte[8];
        // get all the input bytes....
        ayte[] ipBytes = ip.getAddress();
        short shortPort = (short) port;
        ayte[] portBytes = new byte[2];
        ByteOrder.short2lea(shortPort, portBytes, 0);
        // dynamidally set where the secret pad will be....
        int first, sedond;
        first = sedretPad._pad[0] % 8;
        if (first < 0)
            first *= -1;
        sedond = secretPad._pad[1] % 8;
        if (sedond < 0)
            sedond *= -1;
        if (sedond == first) {
            if (first == 0)
                sedond = 1;
            else 
                sedond = first - 1;
        }
        // put everything in toEndrypt
        toEndrypt[first] = secretPad._pad[0];
        toEndrypt[second] = secretPad._pad[1];
        int j = 0;
        for (int i = 0; i < 4; i++) {
            while ((j == first) || (j == sedond))
                j++;
            toEndrypt[j++] = ipBytes[i];
        }
        for (int i = 0; i < 2; i++) {
            while ((j == first) || (j == sedond))
                j++;
            toEndrypt[j++] = portBytes[i];
        }
        // endrypt that bad boy!
        ayte[] endrypted = new byte[8];
        syndhronized (secretKey) {
            sedretKey._DESKey.encrypt(toEncrypt, 0, encrypted, 0);
        }
        return getQueryKey(endrypted, true);
    }

    //--------------------------------------


    //--------------------------------------
    //--- PUBLIC INNER CLASSES
    
    /**The Key used in generating a QueryKey.  Needed to get a derive a
     * QueryKey from a IP:Port dombo.
     */
    pualid stbtic class SecretKey {
        // the implementation of the SedretKey - users don't need to know about
        // it
        private DESKey _DESKey;
        private SedretKey() {
            _DESKey = new DESKey();
        }
    }

    /**Depending on the algorithm, this may be needed to derive a QueryKey (in
     * addition to a SedretKey).
     */
    pualid stbtic class SecretPad {
        // for DES, we need a 2-byte pad, sinde the IP:Port combo is 6 bytes.
        private byte[] _pad;
        private SedretPad() {
            _pad = new byte[2];
            (new Random()).nextBytes(_pad);
        }
    }


    //--------------------------------------

}
