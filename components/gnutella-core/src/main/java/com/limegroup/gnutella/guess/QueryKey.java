package com.limegroup.gnutella.guess;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetAddress;
import java.util.Arrays;
import java.security.SecureRandom;

import com.limegroup.gnutella.ByteOrder;

/**
 * Abstraction for a Query Key as detailed in the GUESS protocol spec.
 * Provides:
 * - encapsulation of (all, LW and non-LW) Query Keys
 * - generation of Query Keys (hence, it contains the LimeWire QK Algorithm)
 *
 * A Query Key is a credential necessary to perform a GUESS Query.  A Query Key
 * instance is immutable.
 *
 * QueryKeys make spoofing UDP IP addresses about as difficult as spoofing TCP
 * IP addresses by forcing some two-way communication before the heavy data
 * transfer occurs (sending search results).  This prevents the use of the
 * Gnutella network as a huge DDoS botnet.
 *
 * If you want to change the underlying generation algorithm, you need to change
 * getKeyBytes(ip, port) and of the inner class QueryKeyGenerator.
 */
public final class QueryKey {

    /**
     * The <tt>QueryKeyGenerator</tt> holding our secret key(s).
     */
    private static QueryKeyGenerator secretKey = null;
    
    /**
     * The <tt>QueryKeyGenerator</tt> used to provide graceful
     * transition when our secret keys expire.  QueryKeys can
     * still be validated against the old key until the current
     * key expires and replaces the old key.
     */
    private static QueryKeyGenerator oldSecretKey = null;
    
    // TODO: Every 6 hours, move secretKey to oldSecretKey and
    // generate a new secretKey so that no key is in use for more
    // than 12 hours.
    
    /** As detailed by the GUESS spec.
     */
    public static final int MIN_QK_SIZE_IN_BYTES = 4;
    /** As detailed by the GUESS spec.
     */
    public static final int MAX_QK_SIZE_IN_BYTES = 16;

    /** The Query Key.  MIN_QK_SIZE_IN_BYTES <=_queryKey.length <=
     *  MAX_QK_SIZE_IN_BYTES
     */
    private byte[] _queryKey;
    
    /**
     * Cached value to make hashCode() much faster.
     */
    private final int _hashCode;

    static {
        secretKey = new QueryKeyGenerator();
        // Start out with the old and new generators
        // being identical.
        oldSecretKey = secretKey;
    }
    
    private QueryKey(byte[] key, boolean prepareForNet) throws IllegalArgumentException {
        if(!isValidQueryKeyBytes(key))
            throw new IllegalArgumentException();
        key = (byte[]) key.clone();
        
        if (prepareForNet)  {
            for (int i = key.length - 1; i >= 0; --i) {
                // The old prepareForNetwork() seemed to leave cobbs encoding to get
                // of nulls?  TODO: is it okay to leave nulls alone?
                if (key[i] == 0x1c) {
                    key[i] = (byte) (0xFA);
                }
            }
        }
        
        // While we have key in the CPU data cache, calculate _hashCode
        int code = 0x5A5A5A5A;
        // Mix all bits of key fairly evenly into code
        for (int i = key.length - 1; i >= 0; --i) {
            code ^= (0xFF & key[i]);
            // One-to-one mixing function from RC6 cipher
            long codeLong = 0xFFFFFFFFL & code;
            code = (int) (codeLong * ((codeLong << 1) + 1));
            // Left circular rotate code by 5 bits
            code = (code >>> 27) | (code << 5);
        }
        
        _queryKey = key;
        _hashCode = code;
    }

    /** Validates that a QueryKey was generated by secretKey for the
     * given IP and port.  Returns true only if the given QueryKey
     * was created by our secretKey (or an attacker has broken
     * our algorithm).
     */
    public static boolean validate(QueryKey qk, InetAddress ip, int port) {
        if (Arrays.equals(qk._queryKey, secretKey.getKeyBytes(ip,port))) {
            return true;
        }
        // Check if qk was generated by the previous secret key
        return Arrays.equals(qk._queryKey, oldSecretKey.getKeyBytes(ip,port));
    }
    
     /** Returns a new QueryKeyGenerator with random secret key(s).
      */
     public static QueryKeyGenerator createKeyGenerator() {
         return new QueryKeyGenerator();
     }

    public boolean equals(Object o) {
        if (o.hashCode() != _hashCode)
            return false;
        if (!(o instanceof QueryKey))
            return false;
        QueryKey other = (QueryKey) o;
        return Arrays.equals(_queryKey, other._queryKey);
    }

    public int hashCode() {
       return _hashCode;
    }

    public void write(OutputStream out) throws IOException {
        out.write(_queryKey);
    }

    /** Returns a String with the QueryKey represented in hexadecimal.
     */
    public String toString() {
        return "{Query Key: " + (new java.math.BigInteger(1,_queryKey)).toString(16) + "}";
    }

    //--------------------------------------
    //--- PUBLIC STATIC CONSTRUCTION METHODS

    /**
     * Determines if the bytes are valid for a qkey.
     */
    public static boolean isValidQueryKeyBytes(byte[] key) {
        return key != null &&
               key.length >= MIN_QK_SIZE_IN_BYTES &&
               key.length <= MAX_QK_SIZE_IN_BYTES;
    }


    /** Use this method to construct Query Keys that you get from network
     *  commerce.  If you are using this for testing purposes, be aware that
     *  QueryKey in QueryRequests cannot contain the GEM extension delimiter 
     *  0x1c or nulls, so send true as the second param...
     *  
     *  
     *  @param networkQK the bytes you want to make a QueryKey.
     *  @param prepareForNet true to prepare the QueryKey for net transport.
     */    
    public static QueryKey getQueryKey(byte[] networkQK, boolean prepareForNet) 
        throws IllegalArgumentException {
        return new QueryKey(networkQK, prepareForNet);
    }

    /** Generates a QueryKey for a given IP:Port combo.
     *  For a given IP:Port combo, using a different SecretKey and/or SecretPad
     *  will result in a different QueryKey.  The return value is constructed
     *  with prepareForNet equal to true.
     *  
     * @param ip the IP address of the other node
     * @param port the port of the other node
     */
    public static QueryKey getQueryKey(InetAddress ip, int port) {
        return new QueryKey(secretKey.getKeyBytes(ip,port), true);
    }

    /** Generates a QueryKey for a given IP:Port combo.
     *  For a given IP:Port combo, using a different QueryKeyGenerator
     *  will result in a different QueryKey.  The return value is constructed
     *  with prepareForNet equal to true.
     *
     * @param ip the IP address of the other node
     * @param port the port of the other node
     */
    public static QueryKey getQueryKey(InetAddress ip, int port,
                                       QueryKeyGenerator keyGen) {
        return new QueryKey(keyGen.getKeyBytes(ip, port), true);
    }

    //--------------------------------------


    //--------------------------------------
    //--- PUBLIC INNER CLASSES
    
    /**The algorithm and secret key(s) used in generating a QueryKey.
     * This is needed to create a QueryKey from a IP:Port combo.
     */
    public static class QueryKeyGenerator {
        // the implementation of the SecretKey - users don't need to know about
        // it
        
        // This uses TEA (Tiny Encryption Algorithm) from
        // D. Wheeler and R. Needham of Cambridge University.
        // TEA is believed to be stronger than the DES cipher
        // used in the previous LW QK algorithm, is much faster
        // in software, and has an extremely small footprint in
        // the CPU's data and instruction caches.
        
        // Length of each query key that we generate, in bytes.
        protected final int QK_LENGTH = 4;
        
        // Pre- and post- encryption cyclic shift values
        // to get random padding equivalent to the previous
        // DES implementation.
        protected final int PRE_ROTATE;
        protected final int POST_ROTATE;
        
        // TEA encryption keys
        protected final int LK0;
        protected final int LK1;
        protected final int RK0;
        protected final int RK1;
        
        // Keys for "whitening" the left and right
        // halves of the encryption block before and
        // after encryption.
        protected final long PRE_WHITEN_KEY;
        protected final long POST_WHITEN_KEY;
        
        // Constructor is package scoped for unit tests
        /* package */ QueryKeyGenerator(int k0, int k1, int k2, int k3,
                int preRotate, int postRotate) {
            
            // Set cyclic shifts to allow getting at differet
            // parts of the output
            PRE_ROTATE = preRotate & 0x3F;
            POST_ROTATE = postRotate & 0x3F;
            
            // No whitening, to expose TEA to tests
            PRE_WHITEN_KEY = POST_WHITEN_KEY = 0;
            
            // Use given TEA keys
            LK0 = k0; LK1 = k1; RK0 = k2; RK1 = k3;
        }
        private QueryKeyGenerator() {
           SecureRandom rand = new SecureRandom();
           PRE_WHITEN_KEY = rand.nextLong();
           POST_WHITEN_KEY = rand.nextLong();
          
           LK0 = rand.nextInt();
           LK1 = rand.nextInt();
           RK0 = rand.nextInt();
           RK1 = rand.nextInt();
           
           int rotations = rand.nextInt();
           PRE_ROTATE = rotations & 0x3F; // Low 6 bits
           POST_ROTATE = rotations >>> 26; // High 6 bits
        }
        
        /** Returns the raw bytes for a QueryKey, which may need to
         * be processed to remove 0x1C and 0x00 before sending on
         * the network.
         */
        public byte[] getKeyBytes(InetAddress ip, int port) {
            byte[] toEncrypt = new byte[8];
            // get all the input bytes....
            byte[] ipBytes = ip.getAddress();
            int ipInt = 0;
            // Load the first 4 bytes into ipInt in little-endian order,
            // with the twist that any negative bytes end up flipping
            // all of the higher order bits, but we don't care.
            for(int i=3; i >= 0; --i) {
                ipInt ^= ipBytes[i] << (i << 3);
            }
            
            // Start out with 64 bits |0x00|0x00|port(2bytes)|ip(4bytes)|
            // and encrypt it with our secret key material.
            long key64 = encrypt(((long)port) << 32) | (ipInt & 0xFFFFFFFFL);
            
            // 32-bit QK gives attackers the least amount of information
            // about our secret key while still not making it worth their
            // while to try and make a botnet out of the Gnutella network
            byte[] qkBytes = new byte[QK_LENGTH];
            
            // Copy bytes that arent 0x00 or 0x1C into output
            int outIndex = QK_LENGTH - 1;
            for (int left=(int)(key64 >> 32), right=(int)key64; outIndex>=0; left >>>= 8) {
                if (left == 0) {
                    // get more data
                    left = right;
                    right = ~right; // This ensures loop termination
                    // Worst case is 0x1CnNnNnN 0x1CnNnNnN, where nN is 0 or 1C.
                }
                int lowByte = left & 0xFF;
                if (lowByte != 0 && lowByte != 0x1C) {
                    qkBytes[outIndex] = (byte) lowByte;
                    --outIndex;
                }
            }
                                  
            return qkBytes;
        }
        

        /**
         * Encrypts a 64-bit value using the TEA block cipher.
         * 
         * The role previously played by the variable padding
         * is now done by pre- and post-encryption cyclic
         * shifting, as well as pre- and post-encryption whitening.
         * 
         * @param block the 64-bit block to be encrypted
         * @return block encrypted using the secret key material
         *     within this class.
         */
        private final long encrypt(long block) {
            block = (block << PRE_ROTATE) | (block >>> (64 - PRE_ROTATE));

            // Pre-encryption whitening
            block ^= PRE_WHITEN_KEY;

            // 32 cycle (a.k.a. 64 Feistel round) TEA encryption
            int left = (int) (block >> 32);
            int right = (int) block;
            for (int cycleCount = 32, roundKey = 0; cycleCount > 0; --cycleCount) {
                roundKey += 0x9E3779B9;
                left  += ((right<<4)+LK0) ^ (right+roundKey) ^ ((right>>>5)+LK1);
                right += (( left<<4)+RK0) ^ ( left+roundKey) ^ (( left>>>5)+RK1);
            }
            block = (((long) left) << 32) | (right & 0xFFFFFFFFL);

            // Post-encryption whitening
            block ^= POST_WHITEN_KEY;

            // Post-encryption cyclic shift
            return (block << POST_ROTATE) | (block >>> (64 - POST_ROTATE));
        }
    }
    //--------------------------------------

}
