package com.limegroup.gnutella.malware;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.concurrent.atomic.AtomicBoolean;

import org.limewire.collection.SortedList;
import org.limewire.core.api.malware.VirusUpdatesURL;
import org.limewire.io.Expand;
import org.limewire.io.IOUtils;
import org.limewire.logging.Log;
import org.limewire.logging.LogFactory;

import com.google.inject.Inject;
import com.google.inject.Provider;

class VirusDefinitionManagerImpl implements VirusDefinitionManager {
    
    private static final Log LOG = LogFactory.getLog(VirusDefinitionManagerImpl.class);

    private final Provider<VirusDefinitionDownloader> downloader;
    private final Provider<VirusScanner> virusScanner;
    private final Provider<String> updatesURL;
    private final AtomicBoolean checking;

    private final VirusDefinitionHandler fullUpdateHandler =
        new VirusDefinitionHandler() {
        @Override
        public void downloadSucceeded(File defs) {
            InputStream in = null;
            try {
                in = new BufferedInputStream(new FileInputStream(defs));
                Expand.expandFile(in, VirusUtils.getDatabaseDirectory(), true, null);
                virusScanner.get().stop();
                // FIXME: clean up old definitions
            } catch(IOException e) {
                // FIXME: We should be retrying some definitions here,
                //        or falling back to the last stable definition.
                LOG.debug("error expanding definitions", e);
            } finally {
                IOUtils.close(in);
            }
            checking.set(false);
        }

        @Override
        public void downloadFailed() {
            LOG.debug("unable to download virus definitions!");
            checking.set(false);
        }
    };

    private class IncrementalUpdateHandler implements VirusDefinitionHandler {
        
        private final SortedList<NFOFile.Entry> incrementalEntries;

        public IncrementalUpdateHandler(SortedList<NFOFile.Entry> incrementalEntries) {
            this.incrementalEntries = incrementalEntries;
        }
        
        private void downloadNext() {
            if(incrementalEntries.size() > 0) {
                try {
                    NFOFile.Entry entry = incrementalEntries.remove(0);
                    download(entry);  
                } catch (URISyntaxException e) {
                    LOG.debug("invalid URI for incremental update", e);
                    // FIXME fallback to full update
                }
            }
        }

        private void download(NFOFile.Entry entry) throws URISyntaxException {
            URI incrementalUpdate = new URI(updatesURL.get() + entry.getPath());
            downloader.get().fetch(incrementalUpdate, entry.getPath(), this);
        }

        @Override
        public void downloadSucceeded(File defs) {
            InputStream in = null;
            try {
                in = new BufferedInputStream(new FileInputStream(defs));
                Expand.expandFile(in, VirusUtils.getDatabaseDirectory(), true, null);
                virusScanner.get().loadIncrementalUpdate(VirusUtils.getLatestDefinitionsDirectory());
                downloadNext();
                // FIXME: clean up old definitions
            } catch(IOException e) {
                LOG.debug("io error downloading incremental update", e);
                // FIXME: fallback to full update
            } catch (VirusScanException e) {
                LOG.debug(e.getMessage(), e);
                // FIXME: fallback to full update
            } finally {
                IOUtils.close(in);
            }
            checking.set(false);
        }

        @Override
        public void downloadFailed() {
            LOG.debug("unable to download incremental update");
            // FIXME: fallback to full update
            checking.set(false);
        }
    }
    
    private final VirusDefinitionHandler nfoHandler = 
        new VirusDefinitionHandler() {
            @Override
            public void downloadSucceeded(File nfo) {
                try {
                    NFOFile nfoFile = new NFOFile(nfo);
                    //doIncrementalOrFullUpdate(nfoFile);
                    doFullUpdate(nfoFile);
                } catch (FileNotFoundException e) {
                    LOG.debugf(e, "Unable to load file {0}", nfo);
                    checking.set(false);
                }
            }

            @Override
            public void downloadFailed() {
                LOG.debug("Unable to download nfo file");
                checking.set(false);
            }
        };

    private void doFullUpdate(NFOFile nfoFile) {
        int currentVersion = VirusUtils.getLatestFullDefinitionsVersion();
        SortedList<NFOFile.Entry> fullEntries = nfoFile.getFullEntries();
        if(fullEntries.last().getVersion() > currentVersion) {                             
            NFOFile.Entry latestFullEntry = nfoFile.getFullEntries().last();
            try {
                URI fullUpdate = new URI(updatesURL.get() + latestFullEntry.getPath());
                downloader.get().fetch(fullUpdate, latestFullEntry.getPath(), fullUpdateHandler);
            } catch (URISyntaxException e) {
                LOG.debug("Invalid full update URI", e);
                checking.set(false);
            }     
        }
    }

    private void doIncrementalOrFullUpdate(NFOFile nfoFile) {
        int currentVersion = VirusUtils.getLatestDefinitionsVersion();
        SortedList<NFOFile.Entry> incrementalEntries = nfoFile.getIncrementalEntries();
        if(incrementalEntries.last().getVersion() > currentVersion) {
            if(incrementalEntries.first().getVersion() > currentVersion) {
                // do full upgrade
                // FIXME actually can probably check for > currentVersion + 1                              
                NFOFile.Entry latestFullEntry = nfoFile.getFullEntries().last();
                try {
                    URI fullUpdate = new URI(updatesURL.get() + latestFullEntry.getPath());
                    downloader.get().fetch(fullUpdate, latestFullEntry.getPath(), fullUpdateHandler);
                } catch (URISyntaxException e) {
                    LOG.debug("Invalid full update URI", e);
                    checking.set(false);
                }                            
            } else {
                // do incremental upgrade
                SortedList<NFOFile.Entry> newIncrementalEntries  = new SortedList<NFOFile.Entry>(new NFOFile.EntryComparator());
                for(NFOFile.Entry entry : incrementalEntries) {
                    if(entry.getVersion() > currentVersion) {
                        newIncrementalEntries.add(entry);        
                    }
                }
                IncrementalUpdateHandler incrementalUpdateHandler = new IncrementalUpdateHandler(newIncrementalEntries);
                incrementalUpdateHandler.downloadNext();
            }
        }
    }

    @Inject
    VirusDefinitionManagerImpl(Provider<VirusDefinitionDownloader> downloader,
                               Provider<VirusScanner> virusScanner,
                               @VirusUpdatesURL Provider<String> updatesURL) {
        this.downloader = downloader;
        this.virusScanner = virusScanner;
        this.updatesURL = updatesURL;
        checking = new AtomicBoolean(false);
    }

    @Override
    public void checkForDefinitions() {
        if(checking.getAndSet(true))
            return;
        // Download the NFO file
        try {
            URI nfo = new URI(updatesURL.get() + "current.nfo");
            downloader.get().fetch(nfo, "current.nfo", nfoHandler);
        } catch(URISyntaxException e) {
            LOG.debug("Invalid URI for current.nfo", e);
            checking.set(false);
        }
    }
    
    public boolean isChecking() {
        return checking.get();
    }
}
