package com.limegroup.gnutella.malware;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import org.limewire.collection.SortedList;
import org.limewire.core.api.malware.VirusUpdatesURL;
import org.limewire.core.settings.FilterSettings;
import org.limewire.io.Expand;
import org.limewire.logging.Log;
import org.limewire.logging.LogFactory;
import org.limewire.util.FileUtils;

import com.google.inject.Inject;
import com.google.inject.Provider;
import com.google.inject.Singleton;
import com.google.inject.name.Named;
import com.limegroup.gnutella.util.LimeWireUtils;

@Singleton
class VirusDefinitionManagerImpl implements VirusDefinitionManager {

    private static final Log LOG =
        LogFactory.getLog(VirusDefinitionManagerImpl.class);
    private static final int MAX_RETRIES = 2;

    private final Provider<VirusDefinitionDownloader> downloader;
    private final Provider<VirusScanner> virusScanner;
    private final Provider<String> updatesURL;
    private final ScheduledExecutorService backgroundExecutor;
    private final AtomicBoolean checking;
    private int retries = 0;

    @Inject
    VirusDefinitionManagerImpl(Provider<VirusDefinitionDownloader> downloader,
            Provider<VirusScanner> virusScanner,
            @VirusUpdatesURL Provider<String> updatesURL,
            @Named("backgroundExecutor") ScheduledExecutorService backgroundExecutor) {
        LOG.debug("Creating VirusDefinitionManagerImpl");
        this.downloader = downloader;
        this.virusScanner = virusScanner;
        this.updatesURL = updatesURL;
        this.backgroundExecutor = backgroundExecutor;
        checking = new AtomicBoolean(false);
    }

    @Override
    public boolean isChecking() {
        return checking.get();
    }

    @Override
    public void checkForDefinitions() {
        if(!virusScanner.get().isSupported()) {
            LOG.debug("Not supported");
            return;
        }
        if(LimeWireUtils.isTemporaryDirectoryInUse()) {
            LOG.debug("Won't use a temporary directory");
            return;
        }
        if(!FilterSettings.CHECK_FOR_VIRUS_DEFINITION_UPDATES.getValue()) {
            LOG.debug("Checking for virus definition updates is disabled");
            return;
        }
        if(checking.getAndSet(true)) {
            LOG.debug("Already checking");
            return;
        }
        // Download the NFO file
        try {
            URI nfo = new URI(updatesURL.get() + "current.nfo");
            downloader.get().fetch(nfo, "current.nfo", new NFOHandler());
        } catch(URISyntaxException e) {
            LOG.debug("Invalid URI for current.nfo", e);
            scheduleNextCheck();
        }
    }

    private void doFullUpdate(NFOFile nfoFile, int currentVersion) {
        SortedList<NFOFile.Entry> fullEntries = nfoFile.getFullEntries();
        if(fullEntries.last().getVersion() > currentVersion) {                             
            NFOFile.Entry latestFullEntry = nfoFile.getFullEntries().last();
            try {
                URI fullUpdate =
                    new URI(updatesURL.get() + latestFullEntry.getPath());
                downloader.get().fetch(fullUpdate, latestFullEntry.getPath(),
                        new FullUpdateHandler());
            } catch (URISyntaxException e) {
                LOG.debug("Invalid full update URI", e);
                scheduleNextCheck();
            }     
        }
    }

    private void doIncrementalOrFullUpdate(NFOFile nfoFile) {
        int currentVersion = virusScanner.get().getDefinitionsVersion();
        if(currentVersion == 0) {
            // We don't have any definitions - do a full update
            doFullUpdate(nfoFile, currentVersion);
            return;
        }
        SortedList<NFOFile.Entry> incrementalEntries =
            nfoFile.getIncrementalEntries();
        if(incrementalEntries.last().getVersion() <= currentVersion) {
            LOG.debug("Virus definitions are up to date");
            scheduleNextCheck();
            return;
        }
        if(incrementalEntries.first().getVersion() > currentVersion + 1) {
            // Not enough increments available - do a full update
            doFullUpdate(nfoFile, currentVersion);
            return;
        }
        // Do an incremental upgrade
        SortedList<NFOFile.Entry> newIncrementalEntries =
            new SortedList<NFOFile.Entry>(new NFOFile.EntryComparator());
        for(NFOFile.Entry entry : incrementalEntries) {
            if(entry.getVersion() > currentVersion) {
                newIncrementalEntries.add(entry);
            }
        }
        IncrementalUpdateHandler incrementalUpdateHandler =
            new IncrementalUpdateHandler(newIncrementalEntries);
        incrementalUpdateHandler.downloadNext();
    }

    private boolean isUpdateCompatibleWithLibrary(File updateDir) throws IOException {
        String library = virusScanner.get().getLibraryVersion();
        LOG.debugf("Library version: {0}", library);
        int[] lib = parseVersion(library);
        File nfo = new File(updateDir, "version.nfo");
        String required =
            VirusUtils.getNfoValue(nfo, "REQUIRED_BIN_RELEASE_VERSION");
        LOG.debugf("Required version: {0}", required);
        int[] req = parseVersion(required);
        for(int i = 0; i < 3; i++) {
            if(lib[i] > req[i])
                return true;
            if(lib[i] < req[i])
                return false;
        }
        return true;
    }

    private int[] parseVersion(String version) throws IOException {
        String[] strings = version.split("\\.");
        if(strings.length != 3)
            throw new IOException("Invalid version: " + version);
        int[] ints = new int[3];
        try {
            for(int i = 0; i < 3; i++) {
                ints[i] = Integer.parseInt(strings[i]);
            }
        } catch(NumberFormatException e) {
            throw new IOException("Invalid version: " + version, e);
        }
        return ints;
    }

    private void scheduleNextCheck() {
        checking.set(false);
        Runnable check = new Runnable() {
            @Override
            public void run() {
                checkForDefinitions();
            }
        };
        LOG.debug("Scheduling next check in 24 hours");
        backgroundExecutor.schedule(check, 24, TimeUnit.HOURS);
    }

    private void considerRetrying() {
        if(retries++ < MAX_RETRIES) {
            LOG.debug("Retrying");
            checkForDefinitions();
        } else {
            LOG.debug("Not retrying");
            retries = 0;
            scheduleNextCheck();
        }
    }

    private class FullUpdateHandler implements VirusDefinitionHandler {

        @Override
        public void downloadSucceeded(File defs) {
            boolean startFromScratch = false;
            File temp = VirusUtils.getTemporaryDirectory();
            FileUtils.forceDeleteRecursive(temp);
            temp.mkdirs();
            temp.mkdir();
            try {
                Expand.expandFile(defs, temp, true);
                String name = FileUtils.getFilenameNoExtension(defs.getName());
                File updateDir = new File(temp, name);
                if(!updateDir.exists())
                    throw new IOException("Unexpected zip format");
                if(!isUpdateCompatibleWithLibrary(updateDir)) {
                    // Disable updates until the library is upgraded
                    FilterSettings.CHECK_FOR_VIRUS_DEFINITION_UPDATES.set(false);
                    throw new IOException("Update is not compatible with library");
                }
                virusScanner.get().loadFullUpdate(updateDir);
            } catch(IOException e) {
                // Carry on with what we've got, unless we haven't got anything
                LOG.debug("Error expanding full update", e);
                if(virusScanner.get().getDefinitionsVersion() == 0)
                    startFromScratch = true;
            } catch(VirusScanException e) {
                // The existing definitions might have been corrupted
                LOG.debug("Error loading full update", e);
                FileUtils.forceDeleteRecursive(VirusUtils.getDatabaseDirectory());
                startFromScratch = true;
            } finally {
                FileUtils.forceDeleteRecursive(temp);
            }
            checking.set(false);
            if(startFromScratch)
                considerRetrying();
        }

        @Override
        public void downloadFailed() {
            LOG.debug("Unable to download full update");
            scheduleNextCheck();
        }
    }

    private class IncrementalUpdateHandler implements VirusDefinitionHandler {

        private final SortedList<NFOFile.Entry> incrementalEntries;

        public IncrementalUpdateHandler(SortedList<NFOFile.Entry> incrementalEntries) {
            this.incrementalEntries = incrementalEntries;
        }

        private void downloadNext() {
            if(incrementalEntries.size() > 0) {
                try {
                    NFOFile.Entry entry = incrementalEntries.remove(0);
                    download(entry);  
                } catch (URISyntaxException e) {
                    // Carry on with what we've got
                    LOG.debug("Invalid incremental update URI", e);
                    scheduleNextCheck();
                }
            }
        }

        private void download(NFOFile.Entry entry) throws URISyntaxException {
            URI incrementalUpdate = new URI(updatesURL.get() + entry.getPath());
            downloader.get().fetch(incrementalUpdate, entry.getPath(), this);
        }

        @Override
        public void downloadSucceeded(File defs) {
            boolean startFromScratch = false;
            File temp = VirusUtils.getTemporaryDirectory();
            FileUtils.forceDeleteRecursive(temp);
            temp.mkdirs();
            temp.mkdir();
            try {
                Expand.expandFile(defs, temp, true);
                String name = FileUtils.getFilenameNoExtension(defs.getName());
                File updateDir = new File(temp, name);
                if(!updateDir.exists())
                    throw new IOException("Unexpected zip format");
                if(!isUpdateCompatibleWithLibrary(updateDir)) {
                    FilterSettings.CHECK_FOR_VIRUS_DEFINITION_UPDATES.set(false);
                    throw new IOException("Update is not compatible with library");
                }
                virusScanner.get().loadIncrementalUpdate(updateDir);
                downloadNext();
            } catch(IOException e) {
                // Carry on with what we've got
                LOG.debug("Error expanding or loading incremental update", e);
            } catch(VirusScanException e) {
                // The existing definitions might have been corrupted
                LOG.debug("Error loading incremental update", e);
                FileUtils.forceDeleteRecursive(VirusUtils.getDatabaseDirectory());
                startFromScratch = true;
            } finally {
                FileUtils.forceDeleteRecursive(temp);
            }
            checking.set(false);
            if(startFromScratch)
                considerRetrying();
        }

        @Override
        public void downloadFailed() {
            // Carry on with what we've got
            LOG.debug("Unable to download incremental update");
            scheduleNextCheck();
        }
    }

    private class NFOHandler implements VirusDefinitionHandler {

        @Override
        public void downloadSucceeded(File nfo) {
            try {
                NFOFile nfoFile = new NFOFile(nfo);
                doIncrementalOrFullUpdate(nfoFile);
            } catch(FileNotFoundException e) {
                LOG.debugf(e, "Unable to load file {0}", nfo);
                scheduleNextCheck();
            }
        }

        @Override
        public void downloadFailed() {
            LOG.debug("Unable to download nfo file");
            scheduleNextCheck();
        }
    }
}
