package com.limegroup.gnutella.malware;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import org.limewire.collection.SortedList;
import org.limewire.core.api.malware.VirusUpdatesURL;
import org.limewire.core.settings.FilterSettings;
import org.limewire.inject.EagerSingleton;
import org.limewire.io.Expand;
import org.limewire.io.InvalidDataException;
import org.limewire.lifecycle.Asynchronous;
import org.limewire.lifecycle.Join;
import org.limewire.lifecycle.Service;
import org.limewire.lifecycle.ServiceRegistry;
import org.limewire.listener.EventListener;
import org.limewire.listener.EventListenerList;
import org.limewire.logging.Log;
import org.limewire.logging.LogFactory;
import org.limewire.util.CommonUtils;
import org.limewire.util.FileUtils;

import com.google.inject.Inject;
import com.google.inject.Provider;
import com.google.inject.name.Named;
import com.limegroup.gnutella.malware.VirusDefinitionHandler.HandlerType;
import com.limegroup.gnutella.util.LimeWireUtils;

@EagerSingleton
class VirusDefinitionManagerImpl implements VirusDefinitionManager, Service {

    private static final Log LOG = LogFactory.getLog(VirusDefinitionManagerImpl.class);
    private static final int MAX_RETRIES = 2;

    private final File mementoFile = new File(CommonUtils.getUserSettingsDir(), "vdef.dat");
    private final File mementoBackupFile = new File(CommonUtils.getUserHomeDir(), "vdef.bak");
    private final Provider<VirusDefinitionDownloader> downloaderFactory;
    private final Provider<VirusScanner> virusScannerProvider;
    private final Provider<String> updatesURL;
    private final ScheduledExecutorService backgroundExecutor;
    private final EventListenerList<VirusDefinitionVersionEvent> listeners;
    private final AtomicBoolean checking;
    private int retries = 0;

    @Inject
    VirusDefinitionManagerImpl(Provider<VirusDefinitionDownloader> downloader,
            Provider<VirusScanner> virusScanner,
            @VirusUpdatesURL Provider<String> updatesURL,
            @Named("backgroundExecutor") ScheduledExecutorService backgroundExecutor) {
        LOG.debug("Creating VirusDefinitionManagerImpl");
        this.downloaderFactory = downloader;
        this.virusScannerProvider = virusScanner;
        this.updatesURL = updatesURL;
        this.backgroundExecutor = backgroundExecutor;
        listeners = new EventListenerList<VirusDefinitionVersionEvent>();
        checking = new AtomicBoolean(false);
    }
    
    @Inject void register(ServiceRegistry registry) {
        registry.register(this);
    }
    
    @Override
    public String getServiceName() {
        return "Virus Definition Service";
    }

    @Override
    public void initialize() {
    }

    /**
     * Starts this service, checking & downloading new definitions
     * as necessary is virus scanning is supported.
     */
    @Override @Asynchronous(join=Join.NONE)
    public void start() {
        LOG.debug("Starting Virus Definition Checking..");
        VirusScanner scanner = virusScannerProvider.get();
        if(isScanningAllowed()) {
            LOG.debug("Virus scanner is supported!");
            VirusDefinitionDownloadMemento memento = loadMemento();
            if(memento == null) {
                LOG.debug("No memento exists, starting as normal.");
                fetchNfo(null);
            } else {
                if(scanner.getDefinitionsVersion() == 0) {
                    LOG.debug("No loaded database, continuing from memento...");
                    try {
                        startMementoDownload(memento, false);
                    } catch(InvalidDataException ide) {
                        LOG.debug("Invalid memento, starting full check", ide);
                        eraseMementos(memento);
                        fetchNfo(null);
                    }
                } else {                    
                    LOG.debug("Database is loaded, checking NFO to see if we should continue...");
                    fetchNfo(memento);
                }
            }
        }
    }

    @Override
    public void stop() {
    }

    @Override
    public void addListener(EventListener<VirusDefinitionVersionEvent> listener) {
        listeners.addListener(listener);
    }

    @Override
    public boolean removeListener(EventListener<VirusDefinitionVersionEvent> listener) {
        return listeners.removeListener(listener);
    }

    private boolean isScanningAllowed() {
        if(!virusScannerProvider.get().isSupported()) {
            LOG.debug("Not supported");
            return false;
        } else if(LimeWireUtils.isTemporaryDirectoryInUse()) {
            LOG.debug("Won't use a temporary directory");
            return false;
        } else if(!FilterSettings.CHECK_FOR_VIRUS_DEFINITION_UPDATES.getValue()) {
            LOG.debug("Checking for virus definition updates is disabled");
            return false;
        } else {
            return true;
        }
    }
    
    /** Loads the saved memento from disk, erasing it if it's invalid. */
    VirusDefinitionDownloadMemento loadMemento() {
        if(!mementoFile.exists()) {
            LOG.debug("No memento file exists, unable to load a memento");
            return null;
        }
        
        try {
            Object read = FileUtils.readObject(mementoFile);
            // Only return the memento if it's for a full file & its incomplete file still exists.
            if(read instanceof VirusDefinitionDownloadMemento) {
                VirusDefinitionDownloadMemento memento = (VirusDefinitionDownloadMemento) read;
                LOG.debugf("Loaded memento file {0}", memento);
                if (memento.getHandlerType() == HandlerType.FULL
                        && memento.getIncompleteFile() != null
                        && memento.getIncompleteFile().exists()
                        && memento.getUri() != null) {
                    return memento;
                } else {
                    eraseMementos(memento);
                }
                return null;
            }
        } catch(Throwable t) {
            LOG.error("Error reading memento file", t);
        }
        eraseMementos(null);
        return null;
    }
    
    /** Erases any mementos from disk. */
    private void eraseMementos(VirusDefinitionDownloadMemento memento) {
        if(memento != null && memento.getIncompleteFile() != null) {
            memento.getIncompleteFile().delete();
        }
        mementoFile.delete();
        mementoBackupFile.delete();
    }
    
    /** Notification that downloads are completed -- erases all saved mementos. */
    private void downloadFinished() {
        eraseMementos(null);
    }
    
    @Override
    public void checkForDefinitions() {
        fetchNfo(null);
    }
    
    /** Starts a download from a memento. */
    private void startMementoDownload(VirusDefinitionDownloadMemento memento, boolean alreadyChecking) throws InvalidDataException {
        assert memento.getHandlerType() == HandlerType.FULL;

        VirusDefinitionDownloader downloader = downloaderFactory.get();
        try {
            downloader.initFromMemento(memento);
        } catch(Throwable t) {
            throw new InvalidDataException("Invalid memento!", t);
        }
        
        if(alreadyChecking) {
            assert checking.get();
        } else {
            // Only set to true if we passed the above method, which can throw.
            boolean wasChecking = checking.getAndSet(true);
            assert !wasChecking;
        }
        
        downloader.fetch(new FullUpdateHandler(true), mementoFile, mementoBackupFile);
    }
    
    /** Fetches the NFO file, possibly restarting a memento if it's non-null. */
    private void fetchNfo(VirusDefinitionDownloadMemento memento) {
        if(checking.getAndSet(true)) {
            LOG.debug("Already checking");
            return;
        }
        
        // Download the NFO file
        try {
            URI nfo = new URI(updatesURL.get() + "current.nfo");
            VirusDefinitionDownloader downloader = downloaderFactory.get();
            downloader.setUriAndName(nfo, "current.nfo");
            downloader.fetch(new NFOHandler(memento), null, null);
        } catch(URISyntaxException e) {
            LOG.debug("Invalid URI for current.nfo", e);
            scheduleNextCheck();
        }
    }

    /** Does a full update, possibly continuing off the existing memento. */
    private void doFullUpdate(NFOFile nfoFile, int currentVersion, VirusDefinitionDownloadMemento memento) {
        SortedList<NFOFile.Entry> fullEntries = nfoFile.getFullEntries();
        if(!fullEntries.isEmpty() && fullEntries.last().getVersion() > currentVersion) {                             
            NFOFile.Entry latestFullEntry = nfoFile.getFullEntries().last();
            try {
                URI fullUpdate = new URI(updatesURL.get() + latestFullEntry.getPath());
                if(memento != null && fullUpdate.equals(memento.getUri())) {
                    try {
                        startMementoDownload(memento, true);
                        return;
                    } catch(InvalidDataException ignored) {
                        eraseMementos(memento);
                    }
                }
                // If we didn't return above, we need to start a new download.
                VirusDefinitionDownloader downloader = downloaderFactory.get();
                downloader.setUriAndName(fullUpdate, latestFullEntry.getPath());
                downloader.fetch(new FullUpdateHandler(false), mementoFile, mementoBackupFile);
            } catch (URISyntaxException e) {
                LOG.debug("Invalid full update URI", e);
                scheduleNextCheck();
            }     
        }
    }

    private void doIncrementalOrFullUpdate(NFOFile nfoFile, VirusDefinitionDownloadMemento memento) {
        int currentVersion = virusScannerProvider.get().getDefinitionsVersion();
        if(currentVersion == 0) {
            // We don't have any definitions - do a full update
            doFullUpdate(nfoFile, currentVersion, memento);
            return; // TODO: What happens if there are more incrementals???
        }
        SortedList<NFOFile.Entry> incrementalEntries =
            nfoFile.getIncrementalEntries();
        
        if (!incrementalEntries.isEmpty()) {
            if(incrementalEntries.last().getVersion() <= currentVersion) {
                LOG.debug("Virus definitions are up to date");
                listeners.broadcast(new VirusDefinitionVersionEvent(currentVersion));
                scheduleNextCheck();
                return;
            }
            if(incrementalEntries.first().getVersion() > currentVersion + 1) {
                // Not enough increments available - do a full update
                doFullUpdate(nfoFile, currentVersion, memento);
                return;
            }
        
            eraseMementos(memento); // mementos are useless right now.
            // Do an incremental upgrade
            SortedList<NFOFile.Entry> newIncrementalEntries =
                new SortedList<NFOFile.Entry>(new NFOFile.EntryComparator());
            for(NFOFile.Entry entry : incrementalEntries) {
                if(entry.getVersion() > currentVersion) {
                    newIncrementalEntries.add(entry);
                }
            }
            IncrementalUpdateHandler incrementalUpdateHandler =
                new IncrementalUpdateHandler(newIncrementalEntries);
            incrementalUpdateHandler.downloadNext();
        }
    }

    private boolean isUpdateCompatibleWithLibrary(File updateDir) throws IOException {
        long libraryV = virusScannerProvider.get().getLibraryBuildVersion();
        File nfo = new File(updateDir, "version.nfo");
        String required = VirusUtils.getNfoValue(nfo, "REQUIRED_BIN_RELEASE_VERSION");
        long reqV = parseVersion(required);
        LOG.debugf("Library version: {0}, required version string: {1}, required version: {2}", libraryV, required, reqV);
        return libraryV > reqV;
    }

    private long parseVersion(String version) throws IOException {
        int idx = version.lastIndexOf(".");
        if(idx + 1 < version.length()) {
            try {
                return Long.parseLong(version.substring(idx + 1));
            } catch(NumberFormatException nfe) {
                throw new IOException("Invalid version: " + version, nfe);
            }
        }
        throw new IOException("Invalid version: " + version);
    }

    private void scheduleNextCheck() {
        checking.set(false);
        Runnable check = new Runnable() {
            @Override
            public void run() {
                fetchNfo(null);
            }
        };
        LOG.debug("Scheduling next check in 24 hours");
        backgroundExecutor.schedule(check, 24, TimeUnit.HOURS);
    }

    private void considerRetrying() {
        if(retries++ < MAX_RETRIES) {
            LOG.debug("Retrying");
            fetchNfo(null);
        } else {
            LOG.debug("Not retrying");
            retries = 0;
            scheduleNextCheck();
        }
    }

    private class FullUpdateHandler implements VirusDefinitionHandler {
        private final boolean fromMemento;
        
        FullUpdateHandler(boolean fromMemento) {
            this.fromMemento = fromMemento;
        }
        
        @Override
        public HandlerType getHandlerType() {
            return HandlerType.FULL;
        }

        @Override
        public void downloadSucceeded(File defs) {
            downloadFinished();
            
            boolean startFromScratch = false;
            File temp = VirusUtils.getTemporaryDirectory();
            FileUtils.forceDeleteRecursive(temp);
            temp.mkdirs();
            temp.mkdir();
            try {
                Expand.expandFile(defs, temp, true);
                String name = FileUtils.getFilenameNoExtension(defs.getName());
                File updateDir = new File(temp, name);
                if(!updateDir.exists()) {
                    throw new IOException("Unexpected zip format");
                }
                if(!isUpdateCompatibleWithLibrary(updateDir)) {
                    // Disable updates until the library is upgraded
                    FilterSettings.CHECK_FOR_VIRUS_DEFINITION_UPDATES.set(false);
                    throw new IOException("Update is not compatible with library");
                }
                virusScannerProvider.get().loadFullUpdate(updateDir);
                int version = virusScannerProvider.get().getDefinitionsVersion();
                listeners.broadcast(new VirusDefinitionVersionEvent(version));
                if(fromMemento) {
                    fetchNfo(null);
                }
            } catch(IOException e) {
                // Carry on with what we've got, unless we haven't got anything
                LOG.debug("Error expanding full update", e);
                if(virusScannerProvider.get().getDefinitionsVersion() == 0) {
                    startFromScratch = true;
                }
            } catch(VirusScanException e) {
                // The existing definitions might have been corrupted
                LOG.debug("Error loading full update", e);
                FileUtils.forceDeleteRecursive(VirusUtils.getDatabaseDirectory());
                listeners.broadcast(new VirusDefinitionVersionEvent(0));
                startFromScratch = true;
            } finally {
                FileUtils.forceDeleteRecursive(temp);
            }
            checking.set(false);
            if(startFromScratch) {
                considerRetrying();
            }
        }

        @Override
        public void downloadFailed(File incomplete) {
            downloadFinished();
            
            LOG.debug("Unable to download full update");
            if(fromMemento) {
                considerRetrying();
            } else {
                scheduleNextCheck();
            }
        }
    }

    private class IncrementalUpdateHandler implements VirusDefinitionHandler {

        private final SortedList<NFOFile.Entry> incrementalEntries;

        public IncrementalUpdateHandler(SortedList<NFOFile.Entry> incrementalEntries) {
            this.incrementalEntries = incrementalEntries;
        }
        
        @Override
        public HandlerType getHandlerType() {
            return HandlerType.INCREMENTAL;
        }   

        private void downloadNext() {
            if(incrementalEntries.size() > 0) {
                try {
                    NFOFile.Entry entry = incrementalEntries.remove(0);
                    download(entry);  
                } catch (URISyntaxException e) {
                    // Carry on with what we've got
                    LOG.debug("Invalid incremental update URI", e);
                    scheduleNextCheck();
                }
            }
        }

        private void download(NFOFile.Entry entry) throws URISyntaxException {
            URI incrementalUpdate = new URI(updatesURL.get() + entry.getPath());
            VirusDefinitionDownloader downloader = downloaderFactory.get();
            downloader.setUriAndName(incrementalUpdate, entry.getPath());
            downloader.fetch(this, null, null);
        }

        @Override
        public void downloadSucceeded(File defs) {
            downloadFinished();
            
            boolean startFromScratch = false;
            File temp = VirusUtils.getTemporaryDirectory();
            FileUtils.forceDeleteRecursive(temp);
            temp.mkdirs();
            temp.mkdir();
            try {
                Expand.expandFile(defs, temp, true);
                String name = FileUtils.getFilenameNoExtension(defs.getName());
                File updateDir = new File(temp, name);
                if(!updateDir.exists())
                    throw new IOException("Unexpected zip format");
                if(!isUpdateCompatibleWithLibrary(updateDir)) {
                    FilterSettings.CHECK_FOR_VIRUS_DEFINITION_UPDATES.set(false);
                    throw new IOException("Update is not compatible with library");
                }
                virusScannerProvider.get().loadIncrementalUpdate(updateDir);
                int version = virusScannerProvider.get().getDefinitionsVersion();
                listeners.broadcast(new VirusDefinitionVersionEvent(version));
                downloadNext();
            } catch(IOException e) {
                // Carry on with what we've got
                LOG.debug("Error expanding or loading incremental update", e);
            } catch(VirusScanException e) {
                // The existing definitions might have been corrupted
                LOG.debug("Error loading incremental update", e);
                FileUtils.forceDeleteRecursive(VirusUtils.getDatabaseDirectory());
                listeners.broadcast(new VirusDefinitionVersionEvent(0));
                startFromScratch = true;
            } finally {
                FileUtils.forceDeleteRecursive(temp);
            }
            checking.set(false);
            if(startFromScratch)
                considerRetrying();
        }

        @Override
        public void downloadFailed(File incomplete) {
            downloadFinished();
            
            // Carry on with what we've got
            LOG.debug("Unable to download incremental update");
            scheduleNextCheck();
        }
    }

    private class NFOHandler implements VirusDefinitionHandler {
        private final VirusDefinitionDownloadMemento memento;
        
        public NFOHandler(VirusDefinitionDownloadMemento memento) {
            this.memento = memento;
        }
        

        @Override
        public void downloadSucceeded(File nfo) {
            downloadFinished();
            
            try {
                NFOFile nfoFile = new NFOFile(nfo);
                doIncrementalOrFullUpdate(nfoFile, memento);
            } catch(FileNotFoundException e) {
                LOG.debugf(e, "Unable to load file {0}", nfo);
                scheduleNextCheck();
            }
        }

        @Override
        public void downloadFailed(File incomplete) {
            downloadFinished();
            
            LOG.debug("Unable to download nfo file");
            scheduleNextCheck();
        }
        
        @Override
        public HandlerType getHandlerType() {
            return HandlerType.NFO;
        }
    }
}
