package com.limegroup.gnutella.malware;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Properties;
import java.util.Scanner;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;

import org.limewire.concurrent.SimpleTimer;
import org.limewire.core.settings.ApplicationSettings;
import org.limewire.core.settings.DownloadSettings;
import org.limewire.core.settings.FilterSettings;
import org.limewire.inject.EagerSingleton;
import org.limewire.lifecycle.Service;
import org.limewire.lifecycle.ServiceRegistry;
import org.limewire.logging.Log;
import org.limewire.logging.LogFactory;
import org.limewire.setting.IntSetting;
import org.limewire.setting.PropertiesSetting;
import org.limewire.util.FileUtils;
import org.limewire.util.OSUtils;

import com.google.inject.Inject;
import com.jacob.activeX.ActiveXComponent;
import com.jacob.com.CLSCTX;
import com.jacob.com.ComFailException;
import com.jacob.com.ComThread;
import com.jacob.com.Dispatch;
import com.jacob.com.Variant;
import com.limegroup.gnutella.util.LimeWireUtils;

@EagerSingleton // Register eagerly but initialize lazily
class VirusScannerImpl implements VirusScanner, Service {

    private static final Log LOG = LogFactory.getLog(VirusScannerImpl.class);

    private final ScheduledExecutorService queue;
    private volatile Boolean supported = null;
    private volatile int definitionsVersion = -1;

    // These must only be accessed from the queue's thread
    private boolean comInitialized = false;
    private Dispatch avg = null;

    @Inject
    VirusScannerImpl() {
        LOG.debug("Creating VirusScannerImpl");
        // All COM calls must happen on the same thread
        queue = new SimpleTimer(true);
    }

    @Inject
    public void register(ServiceRegistry serviceRegistry) {
        serviceRegistry.register(this);
    }

    @Override
    public void initialize() {
        // Initialize lazily
    }

    @Override
    public void start() {
        // Initialize lazily
    }

    @Override
    public String getServiceName() {
        return "AntiVirusService";
    }

    @Override
    public void stop() {
        Future<Void> stop = queue.submit(new StopCommand());
        try {
            stop.get();
        } catch(ExecutionException e) {
            LOG.debug("Failed to stop", e);
        } catch(InterruptedException e) {
            LOG.debug("Failed to stop", e);
        }
    }

    @Override
    public boolean isSupported() {
        if(supported == null) {
            synchronized (this) {
                if(supported == null) {
                    if(LimeWireUtils.isTemporaryDirectoryInUse()) {
                        supported = false;
                    } else if(!LimeWireUtils.isPro() &&
                            ApplicationSettings.AVG_REMOVE_FROM_FREE_VERSION_5_4.getValue()) {
                        //TODO this if check can be removed after the beta, and we will jsut not support isBetaRelease versions anymore.
                        supported = false;
                    } else if(!FilterSettings.USE_VIRUS_SCANNER.getValue() 
                            || !OSUtils.isGoodWindows()) {
                        // FIXME: minimum Windows version
                        supported = false;
                    } else if(LimeWireUtils.isTestingVersion()) {
                        supported = FilterSettings.TEST_VIRUS_SCANNER.getValue();
                    } else {
                        supported = LimeWireUtils.isPro() || LimeWireUtils.isBetaRelease();
                    }
                    LOG.debugf("Supported: {0}", supported);
                }
            }
        }
        return supported;
    }

    private String readLicense() {
        File licenseFile = VirusUtils.getLicenseFile();
        byte[] licence = FileUtils.readFileFully(licenseFile);
        if(licence == null) {
            LOG.debugf("Error reading license file: {0}", licenseFile);
            return "";
        }
        return new String(licence);
    }

    private boolean initializeLazily() throws VirusScanException {
        if(avg != null)
            return true;
        if(definitionsVersion == 0) {
            throw new VirusScanException("No virus definitions",
                    VirusScanException.Detail.DOWNLOADING_DEFINITIONS);    
        }
        try {
            ComThread.InitMTA();
        } catch(ComFailException e) {
            long hr = e.getHResult();
            if(hr < 0)
                hr += Integer.MAX_VALUE;
            LOG.debugf(e, "Failed to initialize COM: {0}", hr);
            throw new VirusScanException("hr: " + hr, e);
        }
        comInitialized = true;
        try {
            avg = new ActiveXComponent("AvgSdkCom.AvgSdk",
                    CLSCTX.CLSCTX_LOCAL_SERVER).getObject();
            Dispatch.call(avg, "InitializeLicense", readLicense());
            File db = VirusUtils.getDatabaseDirectory();
            Dispatch.call(avg, "LoadVdbFiles", db.getAbsolutePath());
        } catch(ComFailException e) {
            uninitialize();
            long hr = e.getHResult();
            if(hr < 0)
                hr += Integer.MAX_VALUE;
            LOG.debugf(e, "Failed to initialize AVG: {0}", hr);
            throw new VirusScanException("hr: " + hr, e);
        }
        return true;
    }

    @Override
    public int getDefinitionsVersion() {
        if(definitionsVersion == -1) {
            File db = VirusUtils.getDatabaseDirectory();
            File nfo = new File(db, "version.nfo");
            Scanner scanner = null;
            try {
                scanner = new Scanner(nfo);
                while(scanner.hasNextLine()) {
                    String line = scanner.nextLine();
                    String[] keyValue = line.split(":");
                    if(keyValue.length != 2) {
                        LOG.debugf("Could not parse line: {0}", line);
                        continue;
                    }
                    String key = keyValue[0].trim();
                    String value = keyValue[1].trim();
                    if(key.equals("VDB_RELEASE_VERSION")) {
                        definitionsVersion = Integer.parseInt(value);
                        break;
                    }
                }
            } catch(FileNotFoundException e) {
                LOG.debug("Cannot find version.nfo");
                definitionsVersion = 0;
            } catch(NumberFormatException e) {
                LOG.debug("Failed to parse VBD_RELEASE_VERSION");
                definitionsVersion = 0;
            } finally {
                if(scanner != null)
                    scanner.close();
            }
        }
        LOG.debugf("Virus definitions version {0}", definitionsVersion);
        return definitionsVersion;
    }

    @Override
    public boolean isInfected(File file) throws VirusScanException {
        assert isSupported();
        Future<Boolean> infected = queue.submit(new ScanCommand(file));
        try {
            boolean result = infected.get();
            return result;
        } catch(ExecutionException e) {
            if(e.getCause() instanceof VirusScanException) {
                throw (VirusScanException)e.getCause();
            } else {
                throw new VirusScanException(e);
            }
        } catch(InterruptedException e) {
            throw new VirusScanException(e);
        }
    }

    private void updateStats(File file, boolean infected) {
        IntSetting numScannedInfected = DownloadSettings.NUM_SCANNED_INFECTED;
        IntSetting numScannedClean = DownloadSettings.NUM_SCANNED_CLEAN;
        PropertiesSetting infectedExtensions = DownloadSettings.INFECTED_EXTENSIONS;
        if(infected) {
            numScannedInfected.set(numScannedInfected.get() + 1);
            String ext = FileUtils.getFileExtension(file);
            Properties props = infectedExtensions.get();
            String inf = props.getProperty(ext);
            Integer numInfectedForExtension = inf != null ? Integer.valueOf(inf) : 0;
            numInfectedForExtension++;            
            props.put(ext, numInfectedForExtension.toString());
            infectedExtensions.set(props);
        } else {
            numScannedClean.set(numScannedClean.get() + 1);
        }
    }

    @Override
    public void stopScanner() {
        stop();
    }

    @Override
    public void loadFullUpdate(File updateDir) throws VirusScanException {
        assert isSupported();
        Future<Void> load = queue.submit(new LoadFullUpdateCommand(updateDir));
        try {
            load.get();
        } catch(ExecutionException e) {
            if(e.getCause() instanceof VirusScanException) {
                throw (VirusScanException)e.getCause();
            } else {
                throw new VirusScanException(e);
            }
        } catch(InterruptedException e) {
            throw new VirusScanException(e);
        }
    }

    @Override
    public void loadIncrementalUpdate(File updateDir) throws IOException, VirusScanException {
        assert isSupported();
        Future<Void> load = queue.submit(new LoadIncrementalUpdateCommand(updateDir));
        try {
            load.get();
        } catch(ExecutionException e) {
            if(e.getCause() instanceof VirusScanException) {
                throw (VirusScanException)e.getCause();
            } else if(e.getCause() instanceof IOException) {
                throw (IOException)e.getCause();
            } else {
                throw new VirusScanException(e);
            }
        } catch(InterruptedException e) {
            throw new VirusScanException(e);
        }
    }

    private void uninitialize() {
        if(avg != null) {
            LOG.debug("Releasing AvgSdk instance");
            avg.safeRelease();
            avg = null;
        }
        if(comInitialized) {
            try {
                LOG.debug("Uninitializing COM");
                ComThread.Release();
            } catch(ComFailException e) {
                long hr = e.getHResult();
                if(hr < 0)
                    hr += Integer.MAX_VALUE;
                LOG.debugf(e, "Failed to uninitialize COM: {0}", hr);
            }
            comInitialized = false;
        }
    }

    private class ScanCommand implements Callable<Boolean> {
        private final File file;

        ScanCommand(File file) {
            this.file = file;
        }

        /**
         * Returns true if the file is infected or false if it's clean.
         * @throws VirusScanException if the file cannot be scanned.
         */
        @Override
        public Boolean call() throws VirusScanException {
            if(!file.exists())
                return false;
            if(!initializeLazily())
                throw new VirusScanException("Failed to initialize");
            try {
                Variant resultVar = new Variant();
                Dispatch params =
                    new ActiveXComponent("AvgSdkCom.AvgScanParameters",
                            CLSCTX.CLSCTX_LOCAL_SERVER).getObject();
                String path = file.getAbsolutePath();
                Variant infected;
                if(file.isDirectory()) {
                    LOG.debugf("Scanning directory: {0}", path);
                    infected = Dispatch.call(avg, "ScanDirectory", path,
                            resultVar, params);
                } else {
                    LOG.debugf("Scanning file: {0}", path);
                    infected = Dispatch.call(avg, "ScanFile", path, path,
                            resultVar, params);
                }
                params.safeRelease();
                boolean isInfected =  infected.getBoolean();
                LOG.debugf("Infected: {0}", infected);
                updateStats(file, isInfected);
                return isInfected;
            } catch(ComFailException e) {
                long hr = e.getHResult();
                if(hr < 0)
                    hr += Integer.MAX_VALUE;
                LOG.debugf(e, "Failed to scan {0}: {1}", file, hr);
                throw new VirusScanException("hr: " + hr, e);
            }
        }
    }

    private class StopCommand implements Callable<Void> {
        @Override
        public Void call() {
            uninitialize();
            return null;
        }
    }

    private class LoadIncrementalUpdateCommand implements Callable<Void> {

        private final File updateDir;

        LoadIncrementalUpdateCommand(File updateDir) {
            this.updateDir = updateDir;
        }

        @Override
        public Void call() throws IOException, VirusScanException {
            LOG.debugf("Loading incremental update from {0}", updateDir);
            definitionsVersion = -1;
            if(!initializeLazily())
                throw new VirusScanException("Failed to initialize");
            // Find the patch file in the update directory
            File patch = null;
            File[] files = updateDir.listFiles();
            if(files == null)
                throw new IOException("Update directory is empty");
            for(File file : files) {
                if(file.getName().endsWith(".trs")) {
                    patch = file;
                    break;
                }
            }
            if(patch == null)
                throw new IOException("Could not find patch file");
            // Find the source file for the merge in the database directory
            File db = VirusUtils.getDatabaseDirectory();
            File source = new File(db, "incavi.avm");
            if(!source.exists())
                throw new IOException("Could not find source file");
            // The destination file will be created in the temporary directory
            File temp = VirusUtils.getTemporaryDirectory();
            File destination = new File(temp, "incavi.avm");
            try {
                Dispatch avgVDBUpdate =
                    new ActiveXComponent("AvgSdkCom.AvgVdbUpd",
                            CLSCTX.CLSCTX_LOCAL_SERVER).getObject();
                Dispatch.call(avgVDBUpdate, "UpdateIncrementalVdbFile",
                        source.getAbsolutePath(),
                        destination.getAbsolutePath(), 1,
                        patch.getAbsolutePath(), new Variant());
                avgVDBUpdate.safeRelease();
            } catch(ComFailException e) {
                long hr = e.getHResult();
                if(hr < 0)
                    hr += Integer.MAX_VALUE;
                LOG.debugf(e, "Failed to merge incremental update: {0}", hr);
                throw new IOException("hr: " + hr, e);
            }
            // Move the new incavi.avm into the database directory
            definitionsVersion = 0;
            source.delete();
            if(!destination.renameTo(source))
                throw new VirusScanException("Failed to rename incavi.avm");
            // Move the new version.nfo into the database directory
            File newVersion = new File(updateDir, "version.nfo");
            File oldVersion = new File(db, "version.nfo");
            oldVersion.delete();
            if(!newVersion.renameTo(oldVersion))
                throw new VirusScanException("Failed to rename version.nfo");
            // Load the new definitions
            try {
                Dispatch.call(avg, "ReloadVdbFiles");
            } catch(ComFailException e) {
                long hr = e.getHResult();
                if(hr < 0)
                    hr += Integer.MAX_VALUE;
                LOG.debugf(e, "Failed to reload definitions: {0}", hr);
                throw new VirusScanException("hr: " + hr, e);
            }
            // Determine the new version
            definitionsVersion = -1;
            getDefinitionsVersion();
            return null;
        }
    }

    private class LoadFullUpdateCommand implements Callable<Void> {

        private final File updateDir;

        LoadFullUpdateCommand(File updateDir) {
            this.updateDir = updateDir;
        }

        @Override
        public Void call() throws VirusScanException {
            LOG.debugf("Loading full update from {0}", updateDir);
            // Shut down the scanner
            uninitialize();
            // Wipe out the old definitions (if any)
            definitionsVersion = 0;
            File db = VirusUtils.getDatabaseDirectory();
            FileUtils.forceDeleteRecursive(db);
            db.mkdirs();
            db.mkdir();
            // Move the update files into the database directory
            File[] files = updateDir.listFiles();
            if(files == null)
                throw new VirusScanException("Update directory is empty");
            for(File file : files) {
                LOG.debugf("Renaming {0}", file);
                if(!file.renameTo(new File(db, file.getName())))
                    throw new VirusScanException("Failed to rename file");
            }
            // Determine the new version
            definitionsVersion = -1;
            getDefinitionsVersion();
            return null;
        }
    }
}