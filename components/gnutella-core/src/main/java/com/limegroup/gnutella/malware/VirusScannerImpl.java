package com.limegroup.gnutella.malware;

import java.io.File;
import java.io.IOException;
import java.util.Properties;
import java.util.Scanner;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.limewire.concurrent.SimpleTimer;
import org.limewire.core.settings.DownloadSettings;
import org.limewire.core.settings.FilterSettings;
import org.limewire.inject.EagerSingleton;
import org.limewire.lifecycle.Service;
import org.limewire.lifecycle.ServiceRegistry;
import org.limewire.logging.Log;
import org.limewire.logging.LogFactory;
import org.limewire.setting.IntSetting;
import org.limewire.setting.PropertiesSetting;
import org.limewire.util.FileUtils;
import org.limewire.util.OSUtils;

import com.google.inject.Inject;
import com.jacob.activeX.ActiveXComponent;
import com.jacob.com.CLSCTX;
import com.jacob.com.ComFailException;
import com.jacob.com.ComThread;
import com.jacob.com.Dispatch;
import com.jacob.com.Variant;
import com.limegroup.gnutella.util.LimeWireUtils;

@EagerSingleton // Register eagerly but initialize lazily
class VirusScannerImpl implements VirusScanner, Service {
    
    private static final Log LOG = LogFactory.getLog(VirusScannerImpl.class);

    private final VirusDefinitionManager manager;
    private final ScheduledExecutorService queue;
    private volatile Boolean supported = null;

    // These must only be accessed from the queue's thread
    private boolean initialized = false;
    private Dispatch avg = null;

    @Inject
    VirusScannerImpl(VirusDefinitionManager manager) {
        LOG.debug("Creating virus scanner impl...");
        this.manager = manager;
        // All COM calls must happen on the same thread
        queue = new SimpleTimer(true);
    }

    @Inject
    public void register(ServiceRegistry serviceRegistry) {
        serviceRegistry.register(this);
    }

    @Override
    public void initialize() {
        // Initialize lazily
    }

    @Override
    public void start() {
        // Initialize lazily
        if(isSupported()) {
            queue.scheduleWithFixedDelay(new Runnable(){
                @Override
                public void run() {
                    manager.checkForDefinitions(); // FIXME: wait a bit after startup?
                }
            }, 0, 24, TimeUnit.HOURS);
        }
            
    }

    @Override
    public String getServiceName() {
        return "AntiVirusService";
    }

    @Override
    public void stop() {
        if(queue == null)
            return;
        Future<Void> stop = queue.submit(new StopCommand());
        try {
            stop.get();
        } catch(ExecutionException e) {
            LOG.debug("ExceutionException", e);
        } catch(InterruptedException e) {
            LOG.debug("Interrupted", e);
        }
    }

    @Override
    public boolean isSupported() {
        if(!FilterSettings.VIRUS_SCANNER_ENABLED.getValue())
            return false;
        if(supported == null) {
            synchronized (this) {
                if(supported == null) {
                    // FIXME: minimum Windows version
                    supported = OSUtils.isGoodWindows() &&
                    (LimeWireUtils.isPro() ||
                            LimeWireUtils.isBetaRelease() ||
                            LimeWireUtils.isTestingVersion());
                }
            }
        }
        return supported;
    }

    private String readLicense() {
        File licenseFile = VirusUtils.getLicenseFile();
        String license = "";
        try {
            Scanner scanner = new Scanner(licenseFile);
            if(scanner.hasNextLine())
                license = scanner.nextLine();
            scanner.close();
        } catch(IOException e) {
            LOG.debug("IOException", e);
        }
        return license;
    }

    private boolean initializeLazily() throws VirusScanException {
        if(initialized)
            return true;
        File defs = VirusUtils.getLatestFullDefinitionsDirectory();
        if(defs == null) {
            VirusScanException.Detail detail = manager.isChecking() ?
                    VirusScanException.Detail.DOWNLOADING_DEFINITIONS : VirusScanException.Detail.NONE;
            // TODO race condition between isChecking() and VirusUtils.getLatestDefinitionsDirectory()
            throw new VirusScanException("No virus definitions", detail);    
        }
        try {
            ComThread.InitMTA();
            avg = new ActiveXComponent("AvgSdkCom.AvgSdk", CLSCTX.CLSCTX_LOCAL_SERVER).getObject();
            Dispatch.call(avg, "InitializeLicense", readLicense());
            Dispatch.call(avg, "LoadVdbFiles", defs.getAbsolutePath());
        } catch(ComFailException e) {
            LOG.debugf(e, "Failed to install hr {0}, context {1}, help file {2}", e.getHResult(), e.getHelpContext(), e.getHelpFile());
            throw new VirusScanException(e);
        }
        initialized = true;
        return true;
    }

    @Override
    public boolean isInfected(File file) throws VirusScanException {
        assert isSupported();
        Future<Boolean> infected = queue.submit(new ScanCommand(file));
        try {
            boolean result = infected.get();
            return result;
        } catch(ExecutionException e) {
            if(e.getCause() instanceof VirusScanException) {
                throw (VirusScanException)e.getCause();
            } else {
                throw new VirusScanException(e);
            }
        } catch(InterruptedException e) {
            throw new VirusScanException(e);
        }
    }

    private void updateStats(File file, boolean infected) {
        IntSetting numScannedInfected = DownloadSettings.NUM_SCANNED_INFECTED;
        IntSetting numScannedClean = DownloadSettings.NUM_SCANNED_CLEAN;
        PropertiesSetting infectedExtensions = DownloadSettings.INFECTED_EXTENSIONS;
        if(infected) {
            numScannedInfected.set(numScannedInfected.get() + 1);
            String ext = FileUtils.getFileExtension(file);
            Integer numInfectedForExtension = (Integer)infectedExtensions.get().get(ext);
            if(numInfectedForExtension != null) {
                numInfectedForExtension++;
            } else {
                numInfectedForExtension = 1;
            }
            Properties props = infectedExtensions.get();
            props.put(ext, numInfectedForExtension);
            infectedExtensions.set(props);
        } else {
            numScannedClean.set(numScannedClean.get() + 1);
        }
    }

    private class ScanCommand implements Callable<Boolean> {
        private final File file;

        ScanCommand(File file) {
            this.file = file;
        }

        /**
         * Returns true if the file is infected or false if it's clean.
         * @throws VirusScanException if the file cannot be scanned.
         */
        @Override
        public Boolean call() throws VirusScanException {
            if(!file.exists())
                return false;
            if(!initializeLazily())
                throw new VirusScanException("Failed to initialize");
            try {
                Variant resultVar = new Variant();
                Dispatch params =
                    new ActiveXComponent("AvgSdkCom.AvgScanParameters", CLSCTX.CLSCTX_LOCAL_SERVER).getObject();
                String path = file.getAbsolutePath();
                Variant infected = Dispatch.call(avg, "ScanFile", path, path, resultVar, params);
                params.safeRelease();
                boolean isInfected =  infected.getBoolean();
                updateStats(file, isInfected);
                return isInfected;
            } catch(ComFailException e) {
                LOG.debugf(e, "Failed to scan. hr {0}, context {1}, help file {2}", e.getHResult(), e.getHelpContext(), e.getHelpFile());                
                throw new VirusScanException(e);
            }
        }
    }

    private class StopCommand implements Callable<Void> {
        @Override
        public Void call() {
            if(!initialized) {
                return null;
            }
            if(avg != null) {
                avg.safeRelease();
                avg = null;
            }
            try {
                ComThread.Release();
            } catch(ComFailException e) {
                LOG.debugf(e, "Failed to stop hr {0}, context {1}, help file {2}", e.getHResult(), e.getHelpContext(), e.getHelpFile());
            }
            initialized = false;
            return null;
        }
    }
}