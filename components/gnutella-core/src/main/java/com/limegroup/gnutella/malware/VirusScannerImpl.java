package com.limegroup.gnutella.malware;

import java.io.File;
import java.util.Properties;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.limewire.concurrent.SimpleTimer;
import org.limewire.core.settings.DownloadSettings;
import org.limewire.core.settings.FilterSettings;
import org.limewire.core.settings.InstallSettings;
import org.limewire.inject.EagerSingleton;
import org.limewire.lifecycle.Service;
import org.limewire.lifecycle.ServiceRegistry;
import org.limewire.logging.Log;
import org.limewire.logging.LogFactory;
import org.limewire.setting.IntSetting;
import org.limewire.setting.PropertiesSetting;
import org.limewire.util.FileUtils;
import org.limewire.util.OSUtils;

import com.google.inject.Inject;
import com.jacob.activeX.ActiveXComponent;
import com.jacob.com.CLSCTX;
import com.jacob.com.ComFailException;
import com.jacob.com.ComThread;
import com.jacob.com.Dispatch;
import com.jacob.com.Variant;
import com.limegroup.gnutella.util.LimeWireUtils;

@EagerSingleton // Register eagerly but initialize lazily
class VirusScannerImpl implements VirusScanner, Service {

    private static final Log LOG = LogFactory.getLog(VirusScannerImpl.class);

    private final VirusDefinitionManager manager;
    private final ScheduledExecutorService queue;
    private volatile Boolean supported = null;

    // These must only be accessed from the queue's thread
    private boolean comInitialized = false;
    private Dispatch avg = null;

    @Inject
    VirusScannerImpl(VirusDefinitionManager manager) {
        LOG.debug("Creating virus scanner impl...");
        this.manager = manager;
        // All COM calls must happen on the same thread
        queue = new SimpleTimer(true);
    }

    @Inject
    public void register(ServiceRegistry serviceRegistry) {
        serviceRegistry.register(this);
    }

    @Override
    public void initialize() {
        // Initialize lazily
    }

    @Override
    public void start() {
        // Initialize lazily
        if(isSupported()) {
            queue.scheduleWithFixedDelay(new Runnable(){
                @Override
                public void run() {
                    manager.checkForDefinitions(); // FIXME: wait a bit after startup?
                }
            }, 0, 24, TimeUnit.HOURS);
        }
    }

    @Override
    public String getServiceName() {
        return "AntiVirusService";
    }

    @Override
    public void stop() {
        Future<Void> stop = queue.submit(new StopCommand());
        try {
            stop.get();
        } catch(ExecutionException e) {
            LOG.debug("Failed to stop", e);
        } catch(InterruptedException e) {
            LOG.debug("Failed to stop", e);
        }
    }

    @Override
    public boolean isSupported() {
        if(supported == null) {
            synchronized (this) {
                if(supported == null) {
                    // FIXME: minimum Windows version
                    if(!LimeWireUtils.isPro() && InstallSettings.AVG_REMOVE_FROM_FREE_VERSION_5_4.getValue()) {
                    	//TODO this if check can be removed after the beta, and we will jsut not support isBetaRelease versions anymore.
                        supported = false;
                    } else if(!FilterSettings.USE_VIRUS_SCANNER.getValue() 
                            || !OSUtils.isGoodWindows()) {
                        supported = false;
                    } else if(LimeWireUtils.isTestingVersion()) {
                        supported = FilterSettings.TEST_VIRUS_SCANNER.getValue();
                    } else {
                        supported = LimeWireUtils.isPro() || LimeWireUtils.isBetaRelease();
                    }
                    LOG.debugf("Supported: {0}", supported);
                }
            }
        }
        return supported;
    }

    private String readLicense() {
        //reading avg license file
        File licenseFile = VirusUtils.getLicenseFile();
        byte[] licence = FileUtils.readFileFully(licenseFile);
        if(licence == null) {
            LOG.debugf("Error reading license file: {0}", licenseFile);
            return "";
        }
        return new String(licence);
    }

    private boolean initializeLazily() throws VirusScanException {
        if(avg != null)
            return true;
        File defs = VirusUtils.getLatestFullDefinitionsDirectory();
        if(defs == null) {
            VirusScanException.Detail detail = manager.isChecking() ?
                    VirusScanException.Detail.DOWNLOADING_DEFINITIONS : VirusScanException.Detail.NONE;
            // TODO race condition between isChecking() and VirusUtils.getLatestDefinitionsDirectory()
            throw new VirusScanException("No virus definitions", detail);    
        }
        try {
            ComThread.InitMTA();
        } catch(ComFailException e) {
            LOG.debugf(e, "Failed to initialize COM: {0}", e.getHResult());
            throw new VirusScanException(e);
        }
        comInitialized = true;
        try {
            avg = new ActiveXComponent("AvgSdkCom.AvgSdk",
                    CLSCTX.CLSCTX_LOCAL_SERVER).getObject();
            Dispatch.call(avg, "InitializeLicense", readLicense());
            Dispatch.call(avg, "LoadVdbFiles", defs.getAbsolutePath());
        } catch(ComFailException e) {
            LOG.debugf(e, "Failed to initialize AVG: {0}", e.getHResult());
            uninitialize();
            throw new VirusScanException(e);
        }
        return true;
    }

    @Override
    public boolean isInfected(File file) throws VirusScanException {
        assert isSupported();
        Future<Boolean> infected = queue.submit(new ScanCommand(file));
        try {
            boolean result = infected.get();
            return result;
        } catch(ExecutionException e) {
            if(e.getCause() instanceof VirusScanException) {
                throw (VirusScanException)e.getCause();
            } else {
                throw new VirusScanException(e);
            }
        } catch(InterruptedException e) {
            throw new VirusScanException(e);
        }
    }

    private void updateStats(File file, boolean infected) {
        IntSetting numScannedInfected = DownloadSettings.NUM_SCANNED_INFECTED;
        IntSetting numScannedClean = DownloadSettings.NUM_SCANNED_CLEAN;
        PropertiesSetting infectedExtensions = DownloadSettings.INFECTED_EXTENSIONS;
        if(infected) {
            numScannedInfected.set(numScannedInfected.get() + 1);
            String ext = FileUtils.getFileExtension(file);
            String inf = infectedExtensions.get().get(ext).toString();
            Integer numInfectedForExtension = Integer.valueOf(inf);
            if(numInfectedForExtension != null) {
                numInfectedForExtension++;
            } else {
                numInfectedForExtension = 1;
            }
            Properties props = infectedExtensions.get();
            props.put(ext, numInfectedForExtension.toString());
            infectedExtensions.set(props);
        } else {
            numScannedClean.set(numScannedClean.get() + 1);
        }
    }
    
    public void loadIncrementalUpdate(File f) throws VirusScanException {
        assert isSupported();
        Future<Void> returnCode = queue.submit(new LoadIncrementalUpdatesCommand(f));
        try {
            returnCode.get();
        } catch(ExecutionException e) {
            if(e.getCause() instanceof VirusScanException) {
                throw (VirusScanException)e.getCause();
            } else {
                throw new VirusScanException(e);
            }
        } catch(InterruptedException e) {
            throw new VirusScanException(e);
        }
    }

    private void uninitialize() {
        if(avg != null) {
            avg.safeRelease();
            avg = null;
        }
        if(comInitialized) {
            try {
                ComThread.Release();
            } catch(ComFailException e) {
                LOG.debugf(e, "Failed to uninitialize COM: {0}", e.getHResult());
            }
            comInitialized = false;
        }
    }

    private class ScanCommand implements Callable<Boolean> {
        private final File file;

        ScanCommand(File file) {
            this.file = file;
        }

        /**
         * Returns true if the file is infected or false if it's clean.
         * @throws VirusScanException if the file cannot be scanned.
         */
        @Override
        public Boolean call() throws VirusScanException {
            if(!file.exists())
                return false;
            if(!initializeLazily())
                throw new VirusScanException("Failed to initialize");
            try {
                Variant resultVar = new Variant();
                Dispatch params =
                    new ActiveXComponent("AvgSdkCom.AvgScanParameters", CLSCTX.CLSCTX_LOCAL_SERVER).getObject();
                String path = file.getAbsolutePath();
                Variant infected;
                if(file.isDirectory()) {
                    LOG.debugf("Scanning directory: {0}", path);
                    infected = Dispatch.call(avg, "ScanDirectory", path, resultVar, params);
                } else {
                    LOG.debugf("Scanning file: {0}", path);
                    infected = Dispatch.call(avg, "ScanFile", path, path, resultVar, params);
                }
                params.safeRelease();
                boolean isInfected =  infected.getBoolean();
                updateStats(file, isInfected);
                return isInfected;
            } catch(ComFailException e) {
                LOG.debugf(e, "Failed to scan {0}: {1}", file, e.getHResult());
                throw new VirusScanException("hr: " + e.getHResult() + ", context: " + e.getHelpContext() + ", file: " + e.getHelpFile(), e);
            }
        }
    }

    private class StopCommand implements Callable<Void> {
        @Override
        public Void call() {
            uninitialize();
            return null;
        }
    }
    
    private class LoadIncrementalUpdatesCommand implements Callable<Void> {
        private final File file;

        LoadIncrementalUpdatesCommand(File file) {
            this.file = file;
        }

        @Override
        public Void call() throws VirusScanException {
            if(!file.exists())
                return null;
            if(!initializeLazily())
                throw new VirusScanException("Failed to initialize");
            File defs = VirusUtils.getLatestFullDefinitionsDirectory();
            try {
                Dispatch avgVDBUpdate =
                    new ActiveXComponent("AvgSdkCom.AvgVdbUpd", CLSCTX.CLSCTX_LOCAL_SERVER).getObject();
                // FIXME: defs.getAbsolutePath() and  file.getAbsolutePath() need to
                // point to the exact files to patch, not the directories containing the files
                // this requires parsing the .nfo file in the incremental update to know
                // which file to patch
                @SuppressWarnings("unused")
                Variant errorCode = Dispatch.call(avgVDBUpdate, "UpdateIncrementalVdbFile",
                        defs.getAbsolutePath(), defs.getAbsolutePath(), 1, file.getAbsolutePath(), new Variant());
                avgVDBUpdate.safeRelease();
                Dispatch.call(avg, "ReloadVdbFiles", defs.getAbsolutePath());                
                // TODO look at return code to see if it worked
                return null;
            } catch(ComFailException e) {
                throw new VirusScanException("hr: " + e.getHResult() + ", context: " + e.getHelpContext() + ", file: " + e.getHelpFile(), e);
            }
        }
    }
}