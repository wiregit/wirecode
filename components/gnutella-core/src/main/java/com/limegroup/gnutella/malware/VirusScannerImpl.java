package com.limegroup.gnutella.malware;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

import org.limewire.concurrent.ExecutorsHelper;
import org.limewire.concurrent.ThreadPoolListeningExecutor;
import org.limewire.inject.EagerSingleton;
import org.limewire.io.Expand;
import org.limewire.io.IOUtils;
import org.limewire.lifecycle.Service;
import org.limewire.lifecycle.ServiceRegistry;
import org.limewire.util.CommonUtils;
import org.limewire.util.OSUtils;
import org.limewire.util.SystemUtils;

import com.google.inject.Inject;
import com.jacob.activeX.ActiveXComponent;
import com.jacob.com.ComFailException;
import com.jacob.com.ComThread;
import com.jacob.com.Dispatch;
import com.jacob.com.Variant;
import com.limegroup.gnutella.util.LimeWireUtils;

@EagerSingleton // Register eagerly but initialize lazily
class VirusScannerImpl implements VirusScanner, Service {

    final static String LICENSE = "INSERT LICENSE HERE";

    private volatile Boolean supported = null;
    private final ThreadPoolListeningExecutor queue;

    // These must only be accessed from the queue's thread
    private boolean installed = false;
    private boolean installFailed = false;
    private boolean initialized = false;
    private Dispatch avg = null;

    @Inject
    VirusScannerImpl() {
        // All COM calls must happen on the same thread
        queue = ExecutorsHelper.newSingleThreadExecutor(
                ExecutorsHelper.daemonThreadFactory("AntiVirusExecutor"));
        queue.allowCoreThreadTimeOut(false);
    }

    @Inject
    public void register(ServiceRegistry serviceRegistry) {
        serviceRegistry.register(this);
    }

    @Override
    public void initialize() {
        // Initialize lazily
    }

    @Override
    public void start() {
        // Initialize lazily
    }

    @Override
    public String getServiceName() {
        return "AntiVirusService";
    }

    @Override
    public void stop() {
        if(queue == null)
            return;
        Future<Void> stop = queue.submit(new StopCommand());
        try {
            stop.get();
        } catch(ExecutionException e) {
            // FIXME: log
            e.printStackTrace();
        } catch(InterruptedException e) {
            // FIXME: log
            e.printStackTrace();
        }
    }

    @Override
    public boolean isSupported() {
        if(supported == null) {
            synchronized (this) {
                if(supported == null) {
                    File zipFile = getZipFile();
                    // FIXME: minimum Windows version
                    supported = OSUtils.isGoodWindows() &&
                    zipFile != null &&
                    zipFile.exists() &&
                    (LimeWireUtils.isPro() ||
                            LimeWireUtils.isBetaRelease() ||
                            LimeWireUtils.isTestingVersion());
                }
            }
        }
        return supported;
    }

    private boolean install() {
        if(installed)
            return true;
        if(installFailed)
            return false;
        // Did we install during a previous session?
        File versionFile = getVersionFile();
        if(versionFile == null) {
            installFailed = true;
            return false;
        }
        if(versionFile.exists()) {
            installed = true;
            return true;
        }
        // We need to install the DLLs
        File installPath = getInstallationDirectory();
        if(installPath == null) {
            installFailed = true;
            return false;
        }
        File zipFile = getZipFile();
        if(zipFile == null || !zipFile.exists()) {
            installFailed = true;
            return false;
        }
        // FileUtils.deleteRecursive(installPath);
        InputStream in = null;
        try {
            in = new BufferedInputStream(new FileInputStream(zipFile));
            Expand.expandFile(in, installPath, true, null);
            registerDLLs();
            versionFile.createNewFile();
            installed = true;
            return true;
        } catch (IOException e) {
            installFailed = true;
            return false;
        } finally {
            IOUtils.close(in);
        }
    }

    private File getZipFile() {
        if(LimeWireUtils.isTestingVersion()) {
            File home = CommonUtils.getUserHomeDir();
            if(home != null)
                return new File(CommonUtils.getUserHomeDir(), "avg.zip");
        }
        String runningPath = SystemUtils.getRunningPath();
        if(runningPath != null && runningPath.contains("LimeWire.exe")) {
            File limewireDirectory = new File(runningPath).getParentFile();
            File libDirectory = new File(limewireDirectory, "lib");
            return new File(libDirectory, "avg.zip");
        }
        return null;
    }

    private File getInstallationDirectory() {
        // FIXME: don't install into a temporary settings directory
        return new File(CommonUtils.getUserSettingsDir(), "avg");
    }

    private File getVersionFile() {
        return new File(getInstallationDirectory(), "avg-1.0");
    }

    private File getDatabaseDirectory() {
        return new File(getInstallationDirectory(), "database");
    }

    private void registerDLLs() {
        // FIXME
    }

    private boolean initializeLazily() throws VirusScanException {
        if(initialized)
            return true;
        File databaseDir = getDatabaseDirectory();
        if(databaseDir == null || !databaseDir.exists())
            throw new VirusScanException("No virus definitions");
        try {
            ComThread.InitMTA();
            avg = new ActiveXComponent("AvgSdkCom.AvgSdk").getObject();
            Dispatch.call(avg, "InitializeLicense", LICENSE);
            Dispatch.call(avg, "LoadVdbFiles", databaseDir.getAbsolutePath());
        } catch(ComFailException e) {
            e.printStackTrace();
            throw new VirusScanException(e);
        }
        initialized = true;
        return true;
    }

    @Override
    public boolean isInfected(File file) throws VirusScanException {
        Future<Boolean> infected = queue.submit(new ScanCommand(file));
        try {
            return infected.get();
        } catch(ExecutionException e) {
            throw new VirusScanException(e);
        } catch(InterruptedException e) {
            throw new VirusScanException(e);
        }
    }

    private class ScanCommand implements Callable<Boolean> {
        private final File file;

        ScanCommand(File file) {
            this.file = file;
        }

        /**
         * Returns true if the file is infected or false if it's clean.
         * @throws VirusScanException if the file cannot be scanned.
         */
        @Override
        public Boolean call() throws VirusScanException {
            if(!install())
                throw new VirusScanException("Failed to install");
            if(!initializeLazily())
                throw new VirusScanException("Failed to initialize");
            try {
                Variant resultVar = new Variant();
                Dispatch params =
                    new ActiveXComponent("AvgSdkCom.AvgScanParameters").getObject();
                String path = file.getAbsolutePath();
                Variant infected =
                    Dispatch.call(avg, "ScanFile", path, path, resultVar, params);
                return infected.getBoolean();
            } catch(ComFailException e) {
                throw new VirusScanException(e);
            }
        }
    }

    private class StopCommand implements Callable<Void> {
        @Override
        public Void call() {
            if(!initialized)
                return null;
            try {
                ComThread.Release();
            } catch(ComFailException e) {
                // FIXME: log
                e.printStackTrace();
            }
            initialized = false;
            return null;
        }
    }
}
