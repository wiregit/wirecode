package com.limegroup.gnutella.malware;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;

import org.limewire.activation.api.ActivationID;
import org.limewire.activation.api.ActivationManager;
import org.limewire.activation.api.ActivationModuleEvent;
import org.limewire.concurrent.SimpleTimer;
import org.limewire.core.settings.DownloadSettings;
import org.limewire.inject.EagerSingleton;
import org.limewire.lifecycle.Service;
import org.limewire.lifecycle.ServiceRegistry;
import org.limewire.listener.EventListener;
import org.limewire.logging.Log;
import org.limewire.logging.LogFactory;
import org.limewire.setting.IntSetting;
import org.limewire.setting.PropertiesSetting;
import org.limewire.util.FileUtils;
import org.limewire.util.StringUtils;
import org.limewire.util.SystemUtils;

import com.google.inject.Inject;
import com.jacob.activeX.ActiveXComponent;
import com.jacob.com.CLSCTX;
import com.jacob.com.ComFailException;
import com.jacob.com.ComThread;
import com.jacob.com.Dispatch;
import com.jacob.com.Variant;
import com.sun.jna.Native;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import com.sun.jna.win32.StdCallLibrary;
import com.sun.jna.win32.W32APIFunctionMapper;
import com.sun.jna.win32.W32APITypeMapper;

@EagerSingleton // Register eagerly to guarantee it stops, but initialize lazily
class VirusScannerImpl implements VirusScanner, Service {

    private static final Log LOG = LogFactory.getLog(VirusScannerImpl.class);

    private final VirusDefinitionManager virusDefinitionManager;
    private final ScheduledExecutorService queue;
    private volatile int definitionsVersion = -1;

    // If this cache is removed then tests will need to be updated.
    private volatile Boolean supported = null;
    
    // These must only be accessed from the queue's thread
    private boolean comInitialized = false;
    private Dispatch avg = null;

    private AntivirusSupportConfiguration supportConfiguration;

    @Inject
    VirusScannerImpl(VirusDefinitionManager virusDefinitionManager, AntivirusSupportConfiguration supportConfiguration) {
        LOG.debug("Creating VirusScannerImpl");
        this.virusDefinitionManager = virusDefinitionManager;
        this.supportConfiguration = supportConfiguration;;
        // All COM calls must happen on the same thread
        queue = new SimpleTimer("VirusScannerThread", true);
    }

    @Inject
    public void register(ServiceRegistry serviceRegistry, ActivationManager activationManager) {
        serviceRegistry.register(this);
        
        // if AVG Module state changes, recheck the support setting
        activationManager.addModuleListener(new EventListener<ActivationModuleEvent>(){
            @Override
            public void handleEvent(final ActivationModuleEvent event) {
                if(event.getData() == ActivationID.AVG_MODULE) {
                    supported = null;
                }
            }            
        });
    }

    @Override
    public void initialize() {
        // Initialize lazily
    }

    @Override
    public void start() {
        // Initialize lazily
    }

    @Override
    public String getServiceName() {
        return "AntiVirusService";
    }

    @Override
    public void stop() {
        Future<Void> stop = queue.submit(new StopCommand());
        try {
            stop.get();
        } catch(ExecutionException e) {
            LOG.debug("Failed to stop", e);
        } catch(InterruptedException e) {
            LOG.debug("Failed to stop", e);
        }
    }

    @Override
    public boolean isSupported() {
        if(supported == null) {
            synchronized (this) {
                if(supported == null) {
                    if(supportConfiguration.isTemporaryDirectoryInUse()) {
                        LOG.debug("Not supported: temporary settings directory");
                        supported = false;
                    } else if(!supportConfiguration.isAVGCompatibleWindows()) {
                        LOG.debug("Not supported: incompatible OS");
                        supported = false;
                     } else if(supportConfiguration.isBetaRelease() &&
                            !supportConfiguration.isRemoveFromFreeVersion5_5_0()) {
                        //TODO this if check can be removed after the beta
                        LOG.debug("Supported: free beta version");
                        supported = true;
                    } else if(supportConfiguration.isAVGModuleEnabled()) {
                        LOG.debug("Supported: pro version");
                        supported = true;
                    } else {
                        LOG.debug("Not supported: free version, or turned off");
                        supported = false;
                    }
                }
            }
        }
        return supported;
    }
    

    @Override
    public boolean isEnabled() {
        return isSupported() && supportConfiguration.isVirusScannerEnabledInSettings();
    }

    private String readLicense() throws IOException {
        File licenseFile = VirusUtils.getLicenseFile();
        if(!licenseFile.exists())
            throw new IOException("License file not found");
        byte[] license = FileUtils.readFileFully(licenseFile);
        if(license == null || license.length == 0)
            throw new IOException("Error reading license");
        return new String(license);
    }

    private void initializeLazily() throws VirusScanException {
        if(avg != null)
            return;
        
        getDefinitionsVersion();
        
        if(definitionsVersion == 0) {
            throw new VirusScanException("No virus definitions",
                    VirusScanException.Detail.DOWNLOADING_DEFINITIONS);    
        }
        try {
            ComThread.InitMTA();
            comInitialized = true;
            avg = new ActiveXComponent("AvgSdkCom.AvgSdk",
                    CLSCTX.CLSCTX_LOCAL_SERVER).getObject();
            Dispatch.call(avg, "InitializeLicense", readLicense());
        } catch(ComFailException e) {
            uninitialize();
            int hr = e.getHResult();
            LOG.debugf(e, "Failed to initialize: {0}", hr);
            throw new VirusScanException("hr: " + hr, e);
        } catch(IOException e) {
            uninitialize();
            LOG.debugf(e, "Error reading license");
            throw new VirusScanException(e);
        }
        File db = VirusUtils.getDatabaseDirectory();
        try {
            Dispatch.call(avg, "LoadVdbFiles", db.getAbsolutePath());
        } catch(ComFailException e) {
            uninitialize();
            // Wipe out the definitions and get a new set
            FileUtils.forceDeleteRecursive(db);
            definitionsVersion = 0;
            virusDefinitionManager.checkForDefinitions();
            int hr = e.getHResult();
            LOG.debugf(e, "Failed to load definitions: {0}", hr);
            throw new VirusScanException("hr: " + hr, e);
        }
    }

    @Override
    public int getDefinitionsVersion() {
        if(definitionsVersion == -1) {
            File db = VirusUtils.getDatabaseDirectory();
            File nfo = new File(db, "version.nfo");
            try {
                String version = VirusUtils.getNfoValue(nfo, "VDB_RELEASE_VERSION");
                definitionsVersion = Integer.parseInt(version);
            } catch(FileNotFoundException e) {
                LOG.debug("Cannot find version.nfo");
                definitionsVersion = 0;
            } catch(IOException e) {
                LOG.debug("Cannot find VBD_RELEASE_VERSION");
                definitionsVersion = 0;
            } catch(NumberFormatException e) {
                LOG.debug("Cannot parse VDB_RELEASE_VERSION");
                definitionsVersion = 0;
            }
        }
        LOG.debugf("Virus definitions version {0}", definitionsVersion);
        return definitionsVersion;
    }
    
    @Override
    public long getLibraryBuildVersion() throws IOException {
        Future<Long> version = queue.submit(new GetLibraryVersionCommand());
        try {
            Long v = version.get();
            if(v == null) {
                return 0;
            } else {
                return v;
            }
        } catch(ExecutionException e) {
            if(e.getCause() instanceof IOException) {
                throw (IOException)e.getCause();
            } else {
                throw new IOException(e);
            }
        } catch(InterruptedException e) {
            throw new IOException(e);
        }
    }

    @Override
    public boolean isInfected(File file) throws VirusScanException {
        Future<Boolean> infected = queue.submit(new ScanCommand(file));
        try {
            boolean result = infected.get();
            return result;
        } catch(ExecutionException e) {
            DownloadSettings.NUM_SCANS_FAILED.set(DownloadSettings.NUM_SCANS_FAILED.get() + 1);
            if(e.getCause() instanceof VirusScanException) {
                throw (VirusScanException)e.getCause();
            } else {
                throw new VirusScanException(e);
            }
        } catch(InterruptedException e) {
            DownloadSettings.NUM_SCANS_FAILED.set(DownloadSettings.NUM_SCANS_FAILED.get() + 1);
            throw new VirusScanException(e);
        }
    }

    private void updateStats(File file, boolean infected) {
        IntSetting numScannedInfected = DownloadSettings.NUM_SCANNED_INFECTED;
        IntSetting numScannedClean = DownloadSettings.NUM_SCANNED_CLEAN;
        PropertiesSetting infectedExtensions = DownloadSettings.INFECTED_EXTENSIONS;
        if(infected) {
            numScannedInfected.set(numScannedInfected.get() + 1);
            String ext = FileUtils.getFileExtension(file);
            Properties props = infectedExtensions.get();
            String inf = props.getProperty(ext);
            Integer numInfectedForExtension = inf != null ? Integer.valueOf(inf) : 0;
            numInfectedForExtension++;            
            props.put(ext, numInfectedForExtension.toString());
            infectedExtensions.set(props);
        } else {
            numScannedClean.set(numScannedClean.get() + 1);
        }
    }

    @Override
    public void stopScanner() {
        stop();
    }

    @Override
    public void loadFullUpdate(File updateDir) throws VirusScanException {
        Future<Void> load = queue.submit(new LoadFullUpdateCommand(updateDir));
        try {
            load.get();
        } catch(ExecutionException e) {
            DownloadSettings.NUM_AV_FULL_UPDATES_FAILED.set(DownloadSettings.NUM_AV_FULL_UPDATES_FAILED.get() + 1);
            if(e.getCause() instanceof VirusScanException) {
                throw (VirusScanException)e.getCause();
            } else {
                throw new VirusScanException(e);
            }
        } catch(InterruptedException e) {
            DownloadSettings.NUM_AV_FULL_UPDATES_FAILED.set(DownloadSettings.NUM_AV_FULL_UPDATES_FAILED.get() + 1);
            throw new VirusScanException(e);
        }
        DownloadSettings.NUM_AV_FULL_UPDATES_SUCCEEDED.set(DownloadSettings.NUM_AV_FULL_UPDATES_SUCCEEDED.get() + 1);
    }

    @Override
    public void loadIncrementalUpdate(File updateDir) throws IOException, VirusScanException {
        Future<Void> load = queue.submit(new LoadIncrementalUpdateCommand(updateDir));
        try {
            load.get();
        } catch(ExecutionException e) {
            DownloadSettings.NUM_AV_INCREMENTAL_UPDATES_FAILED.set(DownloadSettings.NUM_AV_INCREMENTAL_UPDATES_FAILED.get() + 1);
            if(e.getCause() instanceof VirusScanException) {
                throw (VirusScanException)e.getCause();
            } else if(e.getCause() instanceof IOException) {
                throw (IOException)e.getCause();
            } else {
                throw new VirusScanException(e);
            }
        } catch(InterruptedException e) {
            DownloadSettings.NUM_AV_INCREMENTAL_UPDATES_FAILED.set(DownloadSettings.NUM_AV_INCREMENTAL_UPDATES_FAILED.get() + 1);
            throw new VirusScanException(e);
        }
        DownloadSettings.NUM_AV_INCREMENTAL_UPDATES_SUCCEEDED.set(DownloadSettings.NUM_AV_INCREMENTAL_UPDATES_SUCCEEDED.get() + 1);
    }

    private void uninitialize() {
        if(avg != null) {
            LOG.debug("Releasing AvgSdk instance");
            avg.safeRelease();
            avg = null;
        }
        if(comInitialized) {
            try {
                LOG.debug("Uninitializing COM");
                ComThread.Release();
            } catch(ComFailException e) {
                int hr = e.getHResult();
                LOG.debugf(e, "Failed to uninitialize COM: {0}", hr);
            }
            comInitialized = false;
        }
        definitionsVersion = -1;
    }

    private class ScanCommand implements Callable<Boolean> {
        private final File file;

        ScanCommand(File file) {
            this.file = file;
        }

        /**
         * Returns true if the file is infected or false if it's clean.
         * @throws VirusScanException if the file cannot be scanned.
         */
        @Override
        public Boolean call() throws VirusScanException {
            if(!file.exists())
                return false;
            initializeLazily();
            try {
                Variant resultVar = new Variant();
                Dispatch params =
                    new ActiveXComponent("AvgSdkCom.AvgScanParameters",
                            CLSCTX.CLSCTX_LOCAL_SERVER).getObject();
                String path = file.getAbsolutePath();
                Variant infected;
                if(file.isDirectory()) {
                    LOG.debugf("Scanning directory: {0}", path);
                    infected = Dispatch.call(avg, "ScanDirectory", path,
                            resultVar, params);
                } else {
                    LOG.debugf("Scanning file: {0}", path);
                    infected = Dispatch.call(avg, "ScanFile", path, path,
                            resultVar, params);
                }
                params.safeRelease();
                boolean isInfected =  infected.getBoolean();
                LOG.debugf("Infected: {0}", infected);
                updateStats(file, isInfected);
                return isInfected;
            } catch(ComFailException e) {
                int hr = e.getHResult();
                LOG.debugf(e, "Failed to scan {0}: {1}", file, hr);
                throw new VirusScanException("hr: " + hr, e);
            }
        }
    }

    private class StopCommand implements Callable<Void> {
        @Override
        public Void call() {
            uninitialize();
            return null;
        }
    }

    private class LoadIncrementalUpdateCommand implements Callable<Void> {

        private final File updateDir;

        LoadIncrementalUpdateCommand(File updateDir) {
            this.updateDir = updateDir;
        }

        @Override
        public Void call() throws IOException, VirusScanException {
            LOG.debugf("Loading incremental update from {0}", updateDir);
            definitionsVersion = -1;
            try {
                initializeLazily();
            } catch(VirusScanException e) {
                // Convert to IOException because the old definitions are intact
                throw new IOException(e);
            }
            // Find the patch file in the update directory
            File patch = null;
            File[] files = updateDir.listFiles();
            if(files == null)
                throw new IOException("Update directory is empty");
            for(File file : files) {
                if(file.getName().endsWith(".trs")) {
                    patch = file;
                    break;
                }
            }
            if(patch == null)
                throw new IOException("Could not find patch file");
            // Find the source file for the merge in the database directory
            File db = VirusUtils.getDatabaseDirectory();
            File source = new File(db, "incavi.avm");
            if(!source.exists())
                throw new IOException("Could not find source file");
            // The destination file will be created in the temporary directory
            File temp = VirusUtils.getTemporaryDirectory();
            temp.mkdirs();
            File destination = new File(temp, "incavi.avm");
            try {
                Dispatch avgVDBUpdate =
                    new ActiveXComponent("AvgSdkCom.AvgVdbUpd",
                            CLSCTX.CLSCTX_LOCAL_SERVER).getObject();
                Dispatch.call(avgVDBUpdate, "UpdateIncrementalVdbFile",
                        source.getAbsolutePath(),
                        destination.getAbsolutePath(), 1,
                        patch.getAbsolutePath(), new Variant());
                avgVDBUpdate.safeRelease();
            } catch(ComFailException e) {
                int hr = e.getHResult();
                LOG.debugf(e, "Failed to merge incremental update: {0}", hr);
                throw new IOException("hr: " + hr, e);
            }
            // Move the new incavi.avm into the database directory
            definitionsVersion = 0;
            source.delete();
            if(!destination.renameTo(source))
                throw new VirusScanException("Failed to rename incavi.avm");
            // Move the new version.nfo into the database directory
            File newVersion = new File(updateDir, "version.nfo");
            File oldVersion = new File(db, "version.nfo");
            oldVersion.delete();
            if(!newVersion.renameTo(oldVersion))
                throw new VirusScanException("Failed to rename version.nfo");
            // Load the new definitions
            try {
                Dispatch.call(avg, "ReloadVdbFiles");
            } catch(ComFailException e) {
                int hr = e.getHResult();
                LOG.debugf(e, "Failed to reload definitions: {0}", hr);
                throw new VirusScanException("hr: " + hr, e);
            }
            // Determine the new version
            definitionsVersion = -1;
            getDefinitionsVersion();
            return null;
        }
    }

    private class LoadFullUpdateCommand implements Callable<Void> {

        private final File updateDir;

        LoadFullUpdateCommand(File updateDir) {
            this.updateDir = updateDir;
        }

        @Override
        public Void call() throws VirusScanException {
            LOG.debugf("Loading full update from {0}", updateDir);
            // Shut down the scanner
            uninitialize();
            // Wipe out the old definitions (if any)
            definitionsVersion = 0;
            File db = VirusUtils.getDatabaseDirectory();
            FileUtils.forceDeleteRecursive(db);
            db.mkdirs();
            db.mkdir();
            // Move the update files into the database directory
            File[] files = updateDir.listFiles();
            if(files == null)
                throw new VirusScanException("Update directory is empty");
            for(File file : files) {
                if(!file.renameTo(new File(db, file.getName())))
                    throw new VirusScanException("Failed to rename file");
            }
            // Determine the new version
            definitionsVersion = -1;
            getDefinitionsVersion();
            return null;
        }
    }
    
    private class GetLibraryVersionCommand implements Callable<Long> {
        
        @Override
        public Long call() throws IOException {
            LOG.debug("Getting library version.");
            String clsid = SystemUtils.registryReadText("HKEY_CLASSES_ROOT", "AvgSdkCom.AvgSdk\\CLSID", "");
            if(StringUtils.isEmpty(clsid)) {
                throw new IOException("unable to get clsid (registry not setup?)");
            }
            
            String sdkPath = SystemUtils.registryReadText("HKEY_CLASSES_ROOT", "CLSID\\" + clsid + "\\InprocServer32", "");
            if(StringUtils.isEmpty(sdkPath)) {
                throw new IOException("unable to get path (registry not setup right?)");
            }
            
            File avgSdkCom = new File(sdkPath).getAbsoluteFile();
            if(avgSdkCom.getParentFile() == null) {
                throw new IOException("No parent path for avgSdkCom [" + avgSdkCom + "]");
            }
            
            File avgCoreEx = new File(avgSdkCom.getParentFile(), "avgcorex.dll");   
            String corePath = avgCoreEx.getAbsolutePath();            
            VersionDll v = VersionDll.INSTANCE;
            int size = v.GetFileVersionInfoSize(corePath, new IntByReference());
            if(size == 0) {
                throw new IOException("unable to get size data");
            }
            
            Buffer buffer = ByteBuffer.allocateDirect(size);
            boolean result = v.GetFileVersionInfo(corePath, 0, size, buffer);
            if(!result) {
                throw new IOException("unable to get version info");
            }
            
            
            PointerByReference versionData = new PointerByReference();
            IntByReference vdLen = new IntByReference();
            result = v.VerQueryValue(buffer, "\\", versionData, vdLen);
            if(!result) {
                throw new IOException("Unable to get value out of version info");
            }
            
            VersionDll.VS_FIXEDFILEINFO info = new VersionDll.VS_FIXEDFILEINFO(versionData.getValue());
            long v1 = (short)(info.dwFileVersionMS >> 16);
//            long v2 = (short)(info.dwFileVersionMS &0xffff);
//            long v3 = (short)(info.dwFileVersionLS >>16);
            long v4 = (short)(info.dwFileVersionLS &0xffff);
            return v1 * 1000 + v4;
        }
    }
    
    private interface VersionDll extends StdCallLibrary {
        
        public class VS_FIXEDFILEINFO extends com.sun.jna.Structure {
            @SuppressWarnings("unused") public int dwSignature;
            @SuppressWarnings("unused") public int dwStrucVersion;
            public int dwFileVersionMS;
            public int dwFileVersionLS;
            @SuppressWarnings("unused") public int dwProductVersionMS;
            @SuppressWarnings("unused") public int dwProductVersionLS;
            @SuppressWarnings("unused") public int dwFileFlagsMask;
            @SuppressWarnings("unused") public int dwFileFlags;
            @SuppressWarnings("unused") public int dwFileOS;
            @SuppressWarnings("unused") public int dwFileType;
            @SuppressWarnings("unused") public int dwFileSubtype;
            @SuppressWarnings("unused") public int dwFileDateMS;
            @SuppressWarnings("unused") public int dwFileDateLS;
                public VS_FIXEDFILEINFO(com.sun.jna.Pointer p){
                    super(p);
                    read();
                }
        } 

        /** Standard options to use the unicode version of a w32 API. */
        @SuppressWarnings("unchecked")
        Map UNICODE_OPTIONS = new HashMap() {
            {
                put(OPTION_TYPE_MAPPER, W32APITypeMapper.UNICODE);
                put(OPTION_FUNCTION_MAPPER, W32APIFunctionMapper.UNICODE);
            }
        };
        
        /** Standard options to use the ASCII/MBCS version of a w32 API. */
        @SuppressWarnings("unchecked")
        Map ASCII_OPTIONS = new HashMap() {
            {
                put(OPTION_TYPE_MAPPER, W32APITypeMapper.ASCII);
                put(OPTION_FUNCTION_MAPPER, W32APIFunctionMapper.ASCII);
            }
        };
        Map DEFAULT_OPTIONS = Boolean.getBoolean("w32.ascii") ? ASCII_OPTIONS : UNICODE_OPTIONS;

        VersionDll INSTANCE = (VersionDll) Native.loadLibrary("version", VersionDll.class, DEFAULT_OPTIONS);
        
        int GetFileVersionInfoSize(String lpstrFilename, IntByReference lpdwHandle);
        boolean GetFileVersionInfo(String lpstrFilename, int dwHandle, int dwLen, Buffer lpData);
        boolean VerQueryValue(Buffer pBlock, String lpSubBlock, PointerByReference lplpBuffer, IntByReference puLen);
    }
    
    /**
     * Method to access the supported cache to ease testing.
     */
    void setSupported(boolean state) {
        supported = state;
    }
    
   
}