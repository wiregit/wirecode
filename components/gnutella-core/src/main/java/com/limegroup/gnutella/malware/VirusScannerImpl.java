package com.limegroup.gnutella.malware;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
import java.util.Scanner;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

import org.limewire.concurrent.ExecutorsHelper;
import org.limewire.concurrent.ThreadPoolListeningExecutor;
import org.limewire.core.settings.FilterSettings;
import org.limewire.inject.EagerSingleton;
import org.limewire.inject.MutableProvider;
import org.limewire.io.Expand;
import org.limewire.io.IOUtils;
import org.limewire.lifecycle.Service;
import org.limewire.lifecycle.ServiceRegistry;
import org.limewire.util.FileUtils;
import org.limewire.util.OSUtils;
import org.limewire.util.SystemUtils;

import com.google.inject.Inject;
import com.jacob.activeX.ActiveXComponent;
import com.jacob.com.CLSCTX;
import com.jacob.com.ComFailException;
import com.jacob.com.ComThread;
import com.jacob.com.Dispatch;
import com.jacob.com.Variant;
import com.limegroup.gnutella.util.LimeWireUtils;

@EagerSingleton // Register eagerly but initialize lazily
class VirusScannerImpl implements VirusScanner, Service {

    private final VirusDefinitionManager manager;
    private final Object lock = new Object();
    private final MutableProvider<Integer> numScannedClean;
    private final MutableProvider<Integer> numScannedInfected;
    private final MutableProvider<Properties> infectedExtensions;
    private final ThreadPoolListeningExecutor queue;
    private volatile Boolean supported = null;

    // These must only be accessed from the queue's thread
    private boolean installed = false;
    private boolean installFailed = false;
    private boolean initialized = false;
    private Dispatch avg = null;

    @Inject
    VirusScannerImpl(VirusDefinitionManager manager,
                     @NumScannedClean MutableProvider<Integer> numScannedClean,
                     @NumScannedInfected MutableProvider<Integer> numScannedInfected,
                     @InfectedExtensions MutableProvider<Properties> infectedExtensions) {
        this.manager = manager;
        this.numScannedClean = numScannedClean;
        this.numScannedInfected = numScannedInfected;
        this.infectedExtensions = infectedExtensions;
        // All COM calls must happen on the same thread
        queue = ExecutorsHelper.newSingleThreadExecutor(
                ExecutorsHelper.daemonThreadFactory("AntiVirusExecutor"));
        queue.allowCoreThreadTimeOut(false);
    }

    @Inject
    public void register(ServiceRegistry serviceRegistry) {
        serviceRegistry.register(this);
    }

    @Override
    public void initialize() {
        // Initialize lazily
    }

    @Override
    public void start() {
        // Initialize lazily
        if(isSupported())
            manager.checkForDefinitions(); // FIXME: wait a bit after startup?
    }

    @Override
    public String getServiceName() {
        return "AntiVirusService";
    }

    @Override
    public void stop() {
        if(queue == null)
            return;
        Future<Void> stop = queue.submit(new StopCommand());
        try {
            stop.get();
        } catch(ExecutionException e) {
            // FIXME: log
            e.printStackTrace();
        } catch(InterruptedException e) {
            // FIXME: log
            e.printStackTrace();
        }
    }

    @Override
    public boolean isSupported() {
        if(!FilterSettings.VIRUS_SCANNER_ENABLED.getValue())
            return false;
        if(supported == null) {
            synchronized (this) {
                if(supported == null) {
                    File zipFile = VirusUtils.getZipFile();
                    // FIXME: minimum Windows version
                    supported = OSUtils.isGoodWindows() &&
                    zipFile != null &&
                    zipFile.exists() &&
                    (LimeWireUtils.isPro() ||
                            LimeWireUtils.isBetaRelease() ||
                            LimeWireUtils.isTestingVersion());
                }
            }
        }
        return supported;
    }

    private boolean install() {
        if(installed)
            return true;
        if(installFailed)
            return false;
        // Did we install during a previous session?
        File versionFile = VirusUtils.getVersionFile();
        if(versionFile == null) {
            installFailed = true;
            return false;
        }
        if(versionFile.exists()) {
            installed = true;
            return true;
        }
        // We need to install the DLLs
        File installPath = VirusUtils.getInstallationDirectory();
        if(installPath == null) {
            installFailed = true;
            return false;
        }
        File zipFile = VirusUtils.getZipFile();
        if(zipFile == null || !zipFile.exists()) {
            installFailed = true;
            return false;
        }
        
        //FIXME FileUtils.deleteRecursive(installPath); This is needed to properly replace the avg directory, but there is a race condition with the avg download.
        //maybe we just need to force initialization of avg before the avg download starts.
        InputStream in = null;
        try {
            in = new BufferedInputStream(new FileInputStream(zipFile));
            Expand.expandFile(in, installPath, true, null);
            if(!registerDLLs()) {
                installFailed = true;
                return false;
            }
            versionFile.createNewFile();
            installed = true;
            return true;
        } catch (IOException e) {
            installFailed = true;
            return false;
        } finally {
            IOUtils.close(in);
        }
    }

    private String readLicense() {
        File licenseFile = VirusUtils.getLicenseFile();
        String license = "";
        try {
            Scanner scanner = new Scanner(licenseFile);
            if(scanner.hasNextLine())
                license = scanner.nextLine();
            scanner.close();
        } catch(IOException e) {
            // FIXME: log
            e.printStackTrace();
        }
        return license;
    }

    private boolean registerDLLs() {
        // Read the registry entries from a comma-separated file
        String installationPath =
            VirusUtils.getInstallationDirectory().getAbsolutePath();
        File keys = VirusUtils.getKeyFile();
        Scanner scanner = null;
        try {
            scanner = new Scanner(keys);
            while(scanner.hasNextLine()) {
                String line = scanner.nextLine();
                String[] s = line.split(",");
                if(s.length != 4) {
                    System.err.println("Malformed line: " + line);
                    continue;
                }
                s[3] = s[3].replace("_EMPTY_", ""); // I hate you, split()
                s[3] = s[3].replace("_PATH_", installationPath);
                if(!SystemUtils.registryWriteText(s[0], s[1], s[2], s[3])) {
                    System.err.println("Failed to register " + line);
                    return false;
                }
            }
            scanner.close();
        } catch(IOException e) {
            // FIXME: log
            e.printStackTrace();
            return false;
        } finally {
            if(scanner != null) {
                scanner.close();
            }
        }
        
        return true;
    }

    private boolean initializeLazily() throws VirusScanException {
        if(initialized)
            return true;
        File defs = VirusUtils.getLatestDefinitionsDirectory();
        if(defs == null) {
            VirusScanException.Detail detail = manager.isChecking() ?
                    VirusScanException.Detail.DOWNLOADING_DEFINITIONS : VirusScanException.Detail.NONE;
            // TODO race condition between isChecking() and VirusUtils.getLatestDefinitionsDirectory()
            throw new VirusScanException("No virus definitions", detail);    
        }            
        try {
            ComThread.InitMTA();
            avg = new ActiveXComponent("AvgSdkCom.AvgSdk", CLSCTX.CLSCTX_INPROC_SERVER).getObject();
            Dispatch.call(avg, "InitializeLicense", readLicense());
            Dispatch.call(avg, "LoadVdbFiles", defs.getAbsolutePath());
        } catch(ComFailException e) {
            // FIXME: log
            e.printStackTrace();
            throw new VirusScanException(e);
        }
        initialized = true;
        return true;
    }

    @Override
    public boolean isInfected(File file) throws VirusScanException {
        assert isSupported();
        Future<Boolean> infected = queue.submit(new ScanCommand(file));
        try {
            boolean result = infected.get();
            synchronized (lock) {
                updateStats(file, result);
            }
            return result;
        } catch(ExecutionException e) {
            throw new VirusScanException(e);
        } catch(InterruptedException e) {
            throw new VirusScanException(e);
        }
    }

    private void updateStats(File file, boolean infected) {
        if(infected) {
            numScannedInfected.set(numScannedInfected.get() + 1);
            String ext = FileUtils.getFileExtension(file);
            Integer numInfectedForExtension = (Integer)infectedExtensions.get().get(ext);
            if(numInfectedForExtension != null) {
                numInfectedForExtension++;
            } else {
                numInfectedForExtension = 1;
            }
            Properties props = infectedExtensions.get();
            props.put(ext, numInfectedForExtension);
            infectedExtensions.set(props);
        } else {
            numScannedClean.set(numScannedClean.get() + 1);
        }
    }

    private class ScanCommand implements Callable<Boolean> {
        private final File file;

        ScanCommand(File file) {
            this.file = file;
        }

        /**
         * Returns true if the file is infected or false if it's clean.
         * @throws VirusScanException if the file cannot be scanned.
         */
        @Override
        public Boolean call() throws VirusScanException {
            if(!file.exists())
                return false;
            if(!install())
                throw new VirusScanException("Failed to install");
            if(!initializeLazily())
                throw new VirusScanException("Failed to initialize");
            try {
                Variant resultVar = new Variant();
                Dispatch params =
                    new ActiveXComponent("AvgSdkCom.AvgScanParameters", CLSCTX.CLSCTX_INPROC_SERVER).getObject();
                String path = file.getAbsolutePath();
                Variant infected =
                    Dispatch.call(avg, "ScanFile", path, path, resultVar, params);
                return infected.getBoolean();
            } catch(ComFailException e) {
                throw new VirusScanException(e);
            }
        }
    }

    private class StopCommand implements Callable<Void> {
        @Override
        public Void call() {
            if(!initialized)
                return null;
            try {
                ComThread.Release();
            } catch(ComFailException e) {
                // FIXME: log
                e.printStackTrace();
            }
            initialized = false;
            return null;
        }
    }
}
