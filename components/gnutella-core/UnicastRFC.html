Content-Type: text/html

<html><head><title>Gnutella Developer Forum: Gnutella UltraPeer Walking v0.01</title>
<meta http-equiv="Expires" content="Tue, 27 Aug 2002 22:27:34 +0000">
<STYLE type='text/css'>
    .title { color: #990000; font-size: 22px; line-height: 22px; font-weight: bold; text-align: right;
             font-family: helvetica, arial, sans-serif }
    .filename { color: #666666; font-size: 18px; line-height: 28px; font-weight: bold; text-align: right;
                  font-family: helvetica, arial, sans-serif }
    p.copyright { color: #000000; font-size: 10px;
                  font-family: verdana, charcoal, helvetica, arial, sans-serif }
    p { margin-left: 2em; margin-right: 2em; }
    li { margin-left: 3em;  }
    ol { margin-left: 2em; margin-right: 2em; }
    ul.text { margin-left: 2em; margin-right: 2em; }
    pre { margin-left: 3em; color: #333333 }
    ul.toc { color: #000000; line-height: 16px;
             font-family: verdana, charcoal, helvetica, arial, sans-serif }
    H3 { color: #333333; font-size: 16px; line-height: 16px; font-family: helvetica, arial, sans-serif }
    H4 { color: #000000; font-size: 14px; font-family: helvetica, arial, sans-serif }
    TD.header { color: #ffffff; font-size: 10px; font-family: arial, helvetica, san-serif; valign: top }
    TD.author-text { color: #000000; font-size: 10px;
                     font-family: verdana, charcoal, helvetica, arial, sans-serif }
    TD.author { color: #000000; font-weight: bold; margin-left: 4em; font-size: 10px; font-family: verdana, charcoal, helvetica, arial, sans-serif }
     A:link { color: #990000; font-weight: bold;
              font-family: MS Sans Serif, verdana, charcoal, helvetica, arial, sans-serif }
     A:visited { color: #333333; font-weight: bold;
                 font-family: MS Sans Serif, verdana, charcoal, helvetica, arial, sans-serif }
     A:name { color: #333333; font-weight: bold;
              font-family: MS Sans Serif, verdana, charcoal, helvetica, arial, sans-serif }
    .link2 { color:#ffffff; font-weight: bold; text-decoration: none;
             font-family: monaco, charcoal, geneva, MS Sans Serif, helvetica, monotype, verdana, sans-serif;
             font-size: 9px }
    .RFC { color:#666666; font-weight: bold; text-decoration: none;
           font-family: monaco, charcoal, geneva, MS Sans Serif, helvetica, monotype, verdana, sans-serif;
           font-size: 9px }
    .hotText { color:#ffffff; font-weight: normal; text-decoration: none;
               font-family: charcoal, monaco, geneva, MS Sans Serif, helvetica, monotype, verdana, sans-serif;
               font-size: 9px }
</style>
</head>
<body bgcolor="#ffffff" text="#000000" alink="#000000" vlink="#666666" link="#990000">
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<table width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table width="100%" border="0" cellpadding="2" cellspacing="1">
<tr valign="top"><td width="33%" bgcolor="#666666" class="header">Gnutella Developer Forum</td><td width="33%" bgcolor="#666666" class="header">S. Daswani</td></tr>
<tr valign="top"><td width="33%" bgcolor="#666666" class="header">&nbsp;</td><td width="33%" bgcolor="#666666" class="header">A. Fisk</td></tr>
<tr valign="top"><td width="33%" bgcolor="#666666" class="header">&nbsp;</td><td width="33%" bgcolor="#666666" class="header">LimeWire LLC</td></tr>
<tr valign="top"><td width="33%" bgcolor="#666666" class="header">&nbsp;</td><td width="33%" bgcolor="#666666" class="header">August 27, 2002</td></tr>
</table></td></tr></table>
<div align="right"><font face="monaco, MS Sans Serif" color="#990000" size="+3"><b><br><span class="title">Gnutella UltraPeer Walking v0.01</span></b></font></div>
<font face="verdana, helvetica, arial, sans-serif" size="2">

<h3>Abstract</h3>

<p>
	    This RFC outlines a technique for performing unicast searches 
		of UltraPeers on the Gnutella network.  Shifting from the 
		current broadcast search model to this system of unicast 
		searches can dramatically reduce the overall network bandwidth, 
		CPU, and memory required to support the Gnutella search 
		architecture while providing search results comparable to 
		the old broadcast model.  For rare files, the unicast search 
		model may even provide better results than broadcast.
	  
</p><a name="toc"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<h3>Table of Contents</h3>
<ul compact class="toc">
<b><a href="#intro">1.</a>&nbsp;
Introduction<br></b>
<b><a href="#anchor1">1.1</a>&nbsp;
Purpose<br></b>
<b><a href="#requirements">1.2</a>&nbsp;
Requirements<br></b>
<b><a href="#problems">1.3</a>&nbsp;
Problems with the Current Model<br></b>
<b><a href="#queries">1.3.1</a>&nbsp;
Out of Control Queries<br></b>
<b><a href="#hits">1.3.2</a>&nbsp;
Out of Control Query Hits<br></b>
<b><a href="#anchor2">1.4</a>&nbsp;
Switch to Iterative Unicast<br></b>
<b><a href="#searching_architecture">2.</a>&nbsp;
Searching Architecture<br></b>
<b><a href="#algorithm">2.1</a>&nbsp;
Client<br></b>
<b><a href="#server">2.2</a>&nbsp;
Server<br></b>
<b><a href="#discovery">2.3</a>&nbsp;
UltraPeer Discovery<br></b>
<b><a href="#udp">3.</a>&nbsp;
UDP<br></b>
<b><a href="#port">3.1</a>&nbsp;
Open a UDP Port<br></b>
<b><a href="#fragmentation">3.2</a>&nbsp;
Fragmentation<br></b>
<b><a href="#congestion">3.3</a>&nbsp;
Congestion<br></b>
<b><a href="#security">4.</a>&nbsp;
Security Considerations<br></b>
<b><a href="#anchor3">4.1</a>&nbsp;
Distributed Denial of Service (DDOS) Attack<br></b>
<b><a href="#anchor4">4.2</a>&nbsp;
DDOS Prevention<br></b>
<b><a href="#other">5.</a>&nbsp;
Other Considerations<br></b>
<b><a href="#push">5.1</a>&nbsp;
Push Downloads<br></b>
<b><a href="#ggep">6.</a>&nbsp;
GGEP Extensions<br></b>
<b><a href="#ggep_pongs">6.1</a>&nbsp;
Advertise UDP port in Pongs<br></b>
<b><a href="#features">7.</a>&nbsp;
Additional Features<br></b>
<b><a href="#cycles">7.1</a>&nbsp;
Cycles No Longer a Concern<br></b>
<b><a href="#rfc.references1">&#167;</a>&nbsp;
References<br></b>
<b><a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br></b>
<b><a href="#anchor5">A.</a>&nbsp;
Acknowledgements<br></b>
</ul>
<br clear="all">

<a name="intro"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;Introduction</h3>

<a name="rfc.section.1.1"></a><h4><a name="anchor1">1.1</a>&nbsp;Purpose</h4>

<p>
        The use of broadcast searches with high Time To Live (TTL)s on the 
	    Gnutella network uses a great deal of bandwidth and provides little 
	    control over the propagation of 
		messages.<a href="#refs.RandomWalk" title="Lv, Q., Cao, P., Cohen, E., Li, K. and S. Shenker, Search and Replication in Unstructured Peer-to-Peer Networks, June 2002.">[1]</a>  This document seeks to 
	    alleviate both problems through the use of iterative unicast 
	    searches of Gnutella UltraPeers.<a href="#refs.UltraPeer" title="Rohrs, C. and A. Singla, UltraPeers: Another Step Towards Gnutella Scalability, December 2001.">[2]</a>
	    In this scheme, a client continuously queries UltraPeers with a TTL 
	    of 1 until the desired number of search results is achieved.  Due 
	    to the number of nodes that may be dynamically queried in this model,
	    these messages are sent over UDP in the absence of static TCP 
	    connections.  This proposal is not intended to replace work 
		done in areas such as query 
		meshes.  (See <a href="#refs.QueryMesh" title="Falco, V. and S. Darwin, Query Mesh v0.1, March 2002.">[3]</a> and <a href="#refs.http_mesh_proxy" title="Klingberg, T., Gnutella over HTTP, Query Mesh, Push Proxy, August 2002.">[4]</a>)
		It does not, for example, easily allow existing web servers to 
		be modified to service queries.  Rather, it combines aspects of 
		several powerful ideas from different parties, most notably the 
		importance of carefully controlling query propagation and the 
		potential for queries and replies to be sent over UDP, making 
		such a system feasible.
	  
</p>
<a name="rfc.section.1.2"></a><h4><a name="requirements">1.2</a>&nbsp;Requirements</h4>

<p>The key words “MUST”, “MUST NOT”, “REQUIRED”, 
		“SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, 
		“RECOMMENDED”, “MAY”, and “OPTIONAL” in this 
		document are to be interpreted as described in 
		RFC 2119.<a href="#refs.RFC2119" title="Bradner, S., Key words for use in RFCs to Indicate Requirement Levels, May 1997.">[5]</a>
		An implementation is not compliant if it fails to satisfy one or 
		more of the MUST or REQUIRED level requirements for the protocols 
		it implements. An implementation that satisfies all the MUST or 
		REQUIRED level and all the SHOULD level requirements for its 
		protocols is said to be “unconditionally compliant”; one that 
		satisfies all the MUST level requirements but not all the SHOULD 
		level requirements for its protocols is said to be “conditionally
        compliant.”
</p>
<a name="rfc.section.1.3"></a><h4><a name="problems">1.3</a>&nbsp;Problems with the Current Model</h4>

<p>The current broadcast search model consumes excessive bandwidth 
	    and produces a high load on nodes.  This occurs because: 

	      
<blockquote class="text">
<li>The number of nodes queried per search is uncontrolled.
</li>
<li>Even if the number of nodes queried per search were constant,
		    the number of query hits generated per search would still be 
		    highly variable.
</li>
</blockquote><p>
</p>
<a name="rfc.section.1.3.1"></a><h4><a name="queries">1.3.1</a>&nbsp;Out of Control Queries</h4>

<p>The first problem is a result of the volatile, ad-hoc nature of
		  Gnutella.  Nodes come and go unpredictably, making the connectivity
		  of different parts of the network highly variable, or at least
		  potentially so.  The current query model accounts for this
		  volatility by flooding -- it always takes whatever it can.
		  It does this by:

	        
<blockquote class="text">
<li>Sending queries with high TTLs (typically 7), making the 
		      number of nodes searched unpredictable and dependent upon the 
		      network topology.
</li>
<li>Always forwarding queries to all connected nodes (it floods 
		      whenever the TTL is above 1) regardless of variable conditions.
</li>
</blockquote><p>

	      As a result, searches for common keywords in highly 
		  connected areas of the network have disproportionate impacts 
		  on network load, while searches for less common keywords in
		  less connected areas are not able to reach enough nodes to
		  obtain a satisfactory number of replies.
		  
</p>
<a name="rfc.section.1.3.2"></a><h4><a name="hits">1.3.2</a>&nbsp;Out of Control Query Hits</h4>

<p>While the unpredictable nature of queries presents the first half 
		  of the problem, the unpredictable nature of query hits has a comparable 
		  debilitating effect.  The problem with queries spills over into 
		  hits -- a variable number of nodes queried results 
		  in a variable number of query hits.  The problem is more serious 
		  than this, however.  The number of query hits generated per 
		  search also varies independently because:
	  
	        
<blockquote class="text">
<li>Some searches match a far higher percentage of files than other
		      searches (a search for "txt" produces more results than a search
		      for "The_Gettysburg_Address.txt").
</li>
<li>Some nodes share more files than others, so the query hits 
		      depend not only on the number of nodes queried, but on which
		      nodes queries happen to reach.
</li>
</blockquote><p>

		  With this system, users frequently get more results than they need 
		  for popular content while they have a difficult time finding files
		  that are not as widely distributed.  In either case, queries and query 
		  hits follow the same model where they are allowed to run wild,
		  devouring network resources as they go.
	      
</p>
<a name="rfc.section.1.4"></a><h4><a name="anchor2">1.4</a>&nbsp;Switch to Iterative Unicast</h4>

<p>
	      We propose to alleviate these issues by reducing the TTL to 1 on
		  outgoing queries and by sending queries to one UltraPeer at a time
		  until some desired number of results is received or a limit on
		  the number of UltraPeers queried is reached.  Such a change 
		  grants the client initiating a query substantially more control
		  over the number of nodes the query reaches and over the number of 
		  query hits generated.  As such, it takes a significant step
		  towards solving the primary two problems with the current query
		  model noted above.  It does not eliminate these issues because
		  UltraPeers have varying numbers of leaves, nodes still share
		  varying numbers of files, and some searches will still return
		  far more results from given UltraPeers than others.
		  Nevertheless, this change dramatically mitigates the effects
		  of these problems.
	    
</p>
<a name="searching_architecture"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;Searching Architecture</h3>

<p>
	    In several ways, this scheme is simple and easy to 
		implement.  In particular, the system is completely transparent
		to leaves.  From the leaf perspective, the search system has
		not changed at all.  This simplifies the design and allows 
		any leaves not implementing this proposal to benefit from it
		nevertheless.  From the UltraPeer perspective, it is simply 
		a switch to sending out all queries with TTL=1 while querying
		a much larger set of UltraPeers directly over UDP, in addition
		to the traditional queries on intra-UltraPeer connections over
		TCP.  


		<br>
<br>

		The details of the UltraPeer changes are significant.  UltraPeers 
		must send queries iteratively to known UltraPeers via UDP,
		stopping when enough results are received.  UltraPeers are 
		also responsible for maintaining a full cache of other 
		UltraPeers that they can query via UDP.  On the server side,
		UltraPeers must listen on a UDP port, and they must send their
		responses over the same UDP port they are listening on.  Aside from
		the protocol used when sending or receiving messages, however,
		the changes are minimal.
		The following sections discuss these changes.  In this discussion,
		the "client" is the UltraPeer initiating the query, either on its
		own behalf or on behalf of one of its leaves (most importantly,
		the "client" is never a leaf -- it is always the UltraPeer).  
		The "server" is the receiver of the query, which can either
		be an UltraPeer or a leaf.
	  
</p>
<a name="rfc.section.2.1"></a><h4><a name="algorithm">2.1</a>&nbsp;Client</h4>

<p>
		UltraPeers query other UltraPeers one by one until either:
		  
<ol class="text">
<li>
			  The desired number of results is received.
			
</li>
<li>
			  The maximum number of UltraPeers is queried.
			
</li>
</ol><p>
		
		The client MUST pause for a reasonable amount
		of time between UltraPeer queries, perhaps about
		600 milliseconds.  This gives the previous query time to supply
		all of its results, potentially reaching the desired number
		and ending the query.  The optimal interval between searches
		should be determined by experimentation, but implementors MUST
		send as few queries as possible without degrading user experience. 
		This is a tradeoff between latency and network impact.

		<br>
<br>

		With regard to 1) above, implementors have some flexibility, 
		particularly in their technique for
		determing what they consider "enough" results.  
		A simple algorithm would be for the client to continue 
		querying until it has received 100 results or queried 1,000 UltraPeers, 
		for example.  An alternative would be for the number of results 
		considered "enough" to decrease as a function
		of the number of UltraPeers searched.  This algorithm would 
		recognize, for example, that if a search has returned no
		results after querying 500 UlraPeers, it is unlikely
		to get very many results from querying the next 500,
		and it may be satisfied as soon as it receives any results
		at all and stop there.  This would reduce the total number
		of UltraPeers required to service queries for rare files.
		The details of these algorithms should also be determined 
		through experimentation by client developers, again keeping
		in mind that the overall goal is to reduce query and query 
		hit traffic for everyone while maintaining searchability and 
		improving searchability for rare files.  Clients should also 
		keep in mind that an overly aggressive implementation will
		ultimately damage their own clients.
		
		<br>
<br>

		When performing this search, there are several rules that
		UltraPeers MUST follow.  These are:
		  
<ol class="text">
<li>
			  Searches MUST NOT be sent to more than 20,000
			  UltraPeers.
			
</li>
<li>
			  Clients MUST NOT seek more than 2,000 results.
			
</li>
<li>
			  Clients MUST NOT query more than 1 UltraPeer every
			  100 milliseconds.
			
</li>
<li>
			  UltraPeers MUST NOT query the same UltraPeer more 
			  than once.
			
</li>
<li>
			  Although already implied by 4), for clarity, a node
			  MUST NOT send a second query to an UltraPeer if it
			  does not receive responses to the first query (it
			  MUST NOT consider that the datagram was lost and
			  requery as a result).
			
</li>
</ol><p>

	    These numbers SHOULD be considered the absolute maximum
		values, and they are not the settings developers should use.
		Again, the optimal limits should be determined by 
		experimentation, but the above rules always apply.  Implementors
		should keep in mind that Gnutella is a network that relies on
		the fact that other clients are not overly selfish or
		abusive -- Gnutella relies on trust to a large degree.  
		The overall goal of this change is to reduce 
		query and query hit traffic for 
		everyone while maintaining current levels of searchability 
		and even improving
		searchability for rare files.  The reduction in traffic
		should reduce the bandwidth, CPU, and memory load on
		UltraPeers, but this is only possible if developers use 
		conservative values when writing their implementations.
		
</p>
<a name="rfc.section.2.2"></a><h4><a name="server">2.2</a>&nbsp;Server</h4>

<p>
	    The changes on the server side are less significant.  Again,
		no changes are required for leaves.  In fact, leaves SHOULD NOT open
		UDP ports for incoming traffic, as they never receive UDP
		messages directly.
		UltraPeers MUST, however, open a port
		for incoming UDP traffic, and they MUST use the same 
		port that they are using for incoming Gnutella messages 
		over TCP.  When a server receives a message over its open UDP
		port, it MUST send any replies via UDP and over the same
		port it is listening on.  As in the current Gnutella 
		network, all replies are sent back to the sender.  Otherwise,
		servers should respond to messages just as if they 
		recieved them over TCP.  Servers SHOULD accept all of the
		traditional Gnutella messages, as defined in 
		the <a href="#refs.gnutella_rfc" title="Thomas, J., Gnutella Protocol, August 2002.">Gnutella RFC</a>[12].
		
</p>
<a name="rfc.section.2.3"></a><h4><a name="discovery">2.3</a>&nbsp;UltraPeer Discovery</h4>

<p>
		  For this scheme to work, all UltraPeers must have the
		  ability to discover other UltraPeers that accept incoming
		  messages over UDP.  UltraPeers 
		  supporting this proposal MUST advertise this fact
		  using a <a href="#ggep_pongs">GGEP extension</a> 
		  in pongs.  UltraPeers also MUST ensure that they always
		  have a full cache of other UltraPeers to query.  
		  Because leaves always query the network via their
		  UltraPeer, leaves do not have to maintain a set of
		  UltraPeers to query -- this is the UltraPeer's 
		  responsibility.		  
		  <br>
<br>

		  If an UltraPeer's cache of other UltraPeers drops
		  below a certain threshold, for example 1000, the
		  UltraPeer MUST take steps to refresh its cache.  To
		  do this, UltraPeers send pings over UDP to the 
		  It does so using the normal broadcast ping message, 
		  looking for 
		  the <a href="#ggep_pongs">GGEP extension</a> in
		  pongs.  UltraPeers also SHOULD read any pongs that
		  they pass, even when not intended for them directly,
		  to limit the need to send broadcast
		  pings on their own.
		
</p>
<a name="udp"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;UDP</h3>

<p>
	      In this scheme, clients must dynamically query a 
	      potentially high number of UltraPeers directly for each 
		  search.  In the current Gnutella network, all messages are
		  sent using TCP, so the most obvious implementation of this
		  proposal would use a new, transient connection also over TCP.  
		  Opening and closing TCP connections incurs significant CPU 
		  and memory costs, however, potentially making the proposed
		  change unworkable.  As others have noted, however, the 
		  reliability of TCP is not a requirement for Gnutella 
		  queries and replies.  If a message is lost, who cares?  
		  In fact, these queries and their associated replies can 
		  easily be sent over UDP.  In many ways, UDP is the more 
		  appropriate transport layer protocol -- we're sending messages 
		  to an amorphous group of nodes, and reliability is not 
		  a requirement.  Clients wishing to implement this change
		  MUST do so over UDP, as a TCP implementation would incur
		  excessive overhead for other nodes, and would be 
		  impossible without a new, transient connection.
	    
</p>
<a name="rfc.section.3.1"></a><h4><a name="port">3.1</a>&nbsp;Open a UDP Port</h4>

<p>
		    To implement this change, UltraPeers MUST open a UDP
			port that listens for incoming UDP traffic.  It is
			RECOMMENDED that UltraPeers listen on port 6346, the 
			same port registered for Gnutella for TCP.
			UltraPeers MAY, however, listen 
			on a different port, particularly when, for example,
			there is anothing Gnutella client listening on 6346,
			or when another application is using that port for
			any reason.  In all cases, clients MUST
			listen on the same port for both TCP and UDP traffic.
			This makes the implementation slightly more
			rigid.  The IP and TCP port are already reported in a
			number of Gnutella messages, headers, and extensions, 
			however, and this choice makes the reuse of that 
			information possible.  One example is the "Listen IP" 
			connection handshaking header that we will use right
			away to check the firewalled status of leaves.
		  
</p>
<a name="rfc.section.3.2"></a><h4><a name="fragmentation">3.2</a>&nbsp;Fragmentation</h4>

<p>
		    One difference between UDP and TCP is that UDP does 
			not perform any segmenting of datagrams on its own:
			it sends a single datagram that may be split into
			multiple packets at the IP layer, either at the 
			originating host or at an intermediate router.  
			This fragmentation depends upon the 
			Maximum Transmission Unit (MTU) of the underlying
			link-layer.<a href="#refs.TCPIP" title="Stevens, R., The Protocols (TCP/IP Illustrated, Volume 1), January 1994.">[7]</a><br>
<br>

			Fragmentation of datagrams in itself is far from
			disastrous.  The IP layer reassembles packets into 
			complete datagrams at the destination host, making
			the process largely transparent to application 
			developers.  The danger lies, however, in the 
			possibility that individual packets are lost.  If 
			any fragment is lost, the entire datagram 
			is lost.<a href="#refs.TCPIP" title="Stevens, R., The Protocols (TCP/IP Illustrated, Volume 1), January 1994.">[7]</a>  It is
			therefore RECOMMENDED that clients take steps
			to minimize the size of their datagrams to avoid
			excessive fragmentation.  The MTU of modem links
			can be prohibitively small, as low as 296 bytes,
			so we make no attempt to remain below this 
			threshold.<a href="#refs.MTU" title="Mogul, J. and S. Deering, Path MTU Discovery, November 1990.">[8]</a>  These links
			should only occur on the edges of the network,
			however, as long as UltraPeer election algorithms are 
			correctly measuring bandwidth.  This means that any
			fragmentation that may occur along modem links will
			likely result in little to no packet loss, so we
			need not consider this barrier when determing
			datagram sizes.  In general, clients SHOULD limit the
			size of their datagrams whenever appropriate.  A limit
			of 512 is very conservative, and limiting datagrams 
			to 1,024 bytes or less should avoid fragmentation on
			the vast majority of routers.  This will often not
			be possible for query hits.  Hits returning many
			results, however, may indicate an overly general 
			query (such as "txt"), so client MAY choose to
			limit the responses per query hit to limit the 
			overall size.
		  
</p>
<a name="rfc.section.3.3"></a><h4><a name="congestion">3.3</a>&nbsp;Congestion</h4>

<p>
		    Another significant difference between TCP and UDP
			is that UDP does not provide congestion control.
			Given that this query scheme dramatically reduces
			overall message traffic, congestion may not be a 
			concern.  If congestion does prove to cause a 
			high degree of packet loss, however, clients
			may be forced to implement congestion control
			at the application layer.  The architecture for
			such a scheme is beyond the scope of this
			proposal.
		  
</p>
<a name="security"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;Security Considerations</h3>

<a name="rfc.section.4.1"></a><h4><a name="anchor3">4.1</a>&nbsp;Distributed Denial of Service (DDOS) Attack</h4>

<p>
			In the past, a principal objection to using UDP has been
			that it allows anyone to easily execute a DDOS attack
			on any target machine.  To execute such an attack, a
			node would simply have to send out queries advertising 
			the IP and port of the target machine in the GGEP block.
			If no precautions were taken, all replying nodes would
			attempt to reply to the target machine, quickly flooding
			it with UDP datagrams.  			  
	      
</p>
<a name="rfc.section.4.2"></a><h4><a name="anchor4">4.2</a>&nbsp;DDOS Prevention</h4>

<p>
			  To prevent such an attack, UltraPeers MUST verify that
		      the IP address in the advertised GGEP block matches the 
		      source IP address of the datagram itself.
		      The ports are allowed to vary, as clients
			  MAY send their UDP queries out over ephemeral ports.
			  Clients also MAY send these queries over TCP while 
			  expecting replies over UDP.  If the advertised IP 
			  address does not match the IP address of the datagram, 
			  UltraPeers MUST discard the query.  By performing this 
			  check, UltraPeers largely thwart the attack described 
			  above.  With this check in place, attackers would have 
			  to establish UltraPeers themselves on a large scale and let 
			  these queries through, which is difficult.  This security 
			  check is required because not performing this check would 
			  effectively do the attackers' work for them.
			
</p>
<a name="other"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;Other Considerations</h3>

<a name="rfc.section.5.1"></a><h4><a name="push">5.1</a>&nbsp;Push Downloads</h4>

<p>
		  This query scheme gracefully handles push downloads.  In
		  fact, it incorporates many of the ideas of the 
		  Push Proxy proposal.<a href="#refs.push_proxy" title="Thomas, J., Push Proxy v0.1, August 2002.">[11]</a>
		  This scheme does not, however, allow two firewalled hosts
		  to download from each other, as in the "Download Proxy"
		  proposal.<a href="#refs.download_proxy" title="Thomas, J., Download Proxy v0.1, January 2002.">[10]</a>
</p>
<a name="ggep"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;GGEP Extensions</h3>

<a name="rfc.section.6.1"></a><h4><a name="ggep_pongs">6.1</a>&nbsp;Advertise UDP port in Pongs</h4>

<p>
			    UltraPeers that are capable of receiving Gnutella 
			    messages over UDP MUST advertise that fact in a
			    new GGEP extension in 
			    pongs.<a href="#refs.GGEP" title="Thomas, J., Gnutella Generic Extension Protocol (GGEP) v0.51, Fedruary 2002.">[9]</a>
			    TODO: describe the GGEP extension in more detail.		  
		      
</p>
<a name="features"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;Additional Features</h3>

<a name="rfc.section.7.1"></a><h4><a name="cycles">7.1</a>&nbsp;Cycles No Longer a Concern</h4>

<p>
	      Adoption of this proposal has several additional benefits.  For example,
		  concern for cycles in intra-UltraPeer connections is eliminated.  In the
		  current network, cycles can be a serious problem in the worst case,
		  resulting in nodes receiving many duplicate 
		  messages.<a href="#refs.RandomWalk" title="Lv, Q., Cao, P., Cohen, E., Li, K. and S. Shenker, Search and Replication in Unstructured Peer-to-Peer Networks, June 2002.">[1]</a>  This eliminates
		  these duplicates except in the case where leaves are connected to 
		  multiple UltraPeers, and two or more of their UltraPeers are sent
		  the same query.  
	    
</p>
<a name="rfc.references1"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<h3>References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><b><a name="refs.RandomWalk">[1]</a></b></td>
<td class="author-text"><a href="mailto:qlv@cs.princeton.edu">Lv, Q.</a>, <a href="mailto:cao@cisco.com">Cao, P.</a>, <a href="mailto:edith@research.att.com">Cohen, E.</a>, <a href="mailto:li@cs.princeton.edu">Li, K.</a> and <a href="mailto:shenker@icsi.berkeley.edu">S. Shenker</a>, "<a href="http://www.cs.princeton.edu/~qlv/download/searchp2p_full.pdf">Search and Replication in Unstructured Peer-to-Peer Networks</a>", June 2002.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.UltraPeer">[2]</a></b></td>
<td class="author-text"><a href="http://www.limewire.org">Rohrs, C.</a> and <a href="http://www.limewire.org">A. Singla</a>, "<a href="http://groups.yahoo.com/group/the_gdf/files/Proposals/Ultrapeer/Ultrapeers_proper_format.html">UltraPeers: Another Step Towards Gnutella Scalability</a>", December 2001.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.QueryMesh">[3]</a></b></td>
<td class="author-text"><a href="http://www.freepeers.com">Falco, V.</a> and <a href="http://www.freepeers.com">S. Darwin</a>, "<a href="http://groups.yahoo.com/group/the_gdf/files/Proposals/querymesh.txt">Query Mesh v0.1</a>", March 2002.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.http_mesh_proxy">[4]</a></b></td>
<td class="author-text"><a href="http://www.freepeers.com">Klingberg, T.</a>, "<a href="http://groups.yahoo.com/group/the_gdf/message/9533">Gnutella over HTTP, Query Mesh, Push Proxy</a>", August 2002.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.RFC2119">[5]</a></b></td>
<td class="author-text">Bradner, S., "<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">Key words for use in RFCs to Indicate Requirement Levels</a>", RFC 2119, May 1997.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.agthorr">[6]</a></b></td>
<td class="author-text">Agthorr, D., "<a href="http://groups.yahoo.com/group/the_gdf/message/4492">Re: GGEP 0.31 comments</a>", January 2002.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.TCPIP">[7]</a></b></td>
<td class="author-text">Stevens, R., "<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0201633469/qid=1029899071/sr=8-1/ref=sr_8_1/002-2563381-7557664?s=books&n=507846">The Protocols (TCP/IP Illustrated, Volume 1)</a>", January 1994.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.MTU">[8]</a></b></td>
<td class="author-text">Mogul, J. and S. Deering, "<a href="http://www.faqs.org/rfcs/rfc1191.html">Path MTU Discovery</a>", RFC 1191, November 1990.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.GGEP">[9]</a></b></td>
<td class="author-text"><a href="mailto:jason@jasonthomas.com">Thomas, J.</a>, "<a href="http://groups.yahoo.com/group/the_gdf/files/Proposals/GGEP/GnutellaGenericExtensionProtocol.0.51.html">Gnutella Generic Extension Protocol (GGEP) v0.51</a>", Fedruary 2002.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.download_proxy">[10]</a></b></td>
<td class="author-text"><a href="mailto:jason@jasonthomas.com">Thomas, J.</a>, "<a href="http://groups.yahoo.com/group/the_gdf/files/Proposals/Download%20Proxy/Download%20Proxy.html">Download Proxy v0.1</a>", January 2002.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.push_proxy">[11]</a></b></td>
<td class="author-text"><a href="mailto:jason@jasonthomas.com">Thomas, J.</a>, "<a href="http://groups.yahoo.com/group/the_gdf/message/9317">Push Proxy v0.1</a>", August 2002.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.gnutella_rfc">[12]</a></b></td>
<td class="author-text"><a href="mailto:jason@jasonthomas.com">Thomas, J.</a>, "<a href="http://groups.yahoo.com/group/the_gdf/message/9317">Gnutella Protocol</a>", August 2002.</td></tr>
</table>

<a name="rfc.authors"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Susheel Daswani</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">LimeWire LLC</td></tr>
<tr><td class="author" align="right">EMail:&nbsp;</td>
<td class="author-text"><a href="mailto:sdaswani@limewire.com">sdaswani@limewire.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.limewire.org">http://www.limewire.org</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Adam A. Fisk</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">LimeWire LLC</td></tr>
<tr><td class="author" align="right">EMail:&nbsp;</td>
<td class="author-text"><a href="mailto:afisk@limewire.com">afisk@limewire.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.limewire.org">http://www.limewire.org</a></td></tr>
</table>

<a name="anchor5"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;Acknowledgements</h3>

<p>
	    The authors would like to thank the rest of the LimeWire team, all participants
		in the Gnutella Developer Forum (GDF), and all members of the LimeWire open
		source initiative.
	  
</p></font></body></html>

