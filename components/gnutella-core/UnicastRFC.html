Content-Type: text/html

<html><head><title>Gnutella Developer Forum: Gnutella UltraPeer Extension for Scalable Searches (GUESS) v0.01</title>
<meta http-equiv="Expires" content="Thu, 05 Sep 2002 03:20:20 +0000">
<STYLE type='text/css'>
    .title { color: #990000; font-size: 22px; line-height: 22px; font-weight: bold; text-align: right;
             font-family: helvetica, arial, sans-serif }
    .filename { color: #666666; font-size: 18px; line-height: 28px; font-weight: bold; text-align: right;
                  font-family: helvetica, arial, sans-serif }
    p.copyright { color: #000000; font-size: 10px;
                  font-family: verdana, charcoal, helvetica, arial, sans-serif }
    p { margin-left: 2em; margin-right: 2em; }
    li { margin-left: 3em;  }
    ol { margin-left: 2em; margin-right: 2em; }
    ul.text { margin-left: 2em; margin-right: 2em; }
    pre { margin-left: 3em; color: #333333 }
    ul.toc { color: #000000; line-height: 16px;
             font-family: verdana, charcoal, helvetica, arial, sans-serif }
    H3 { color: #333333; font-size: 16px; line-height: 16px; font-family: helvetica, arial, sans-serif }
    H4 { color: #000000; font-size: 14px; font-family: helvetica, arial, sans-serif }
    TD.header { color: #ffffff; font-size: 10px; font-family: arial, helvetica, san-serif; valign: top }
    TD.author-text { color: #000000; font-size: 10px;
                     font-family: verdana, charcoal, helvetica, arial, sans-serif }
    TD.author { color: #000000; font-weight: bold; margin-left: 4em; font-size: 10px; font-family: verdana, charcoal, helvetica, arial, sans-serif }
     A:link { color: #990000; font-weight: bold;
              font-family: MS Sans Serif, verdana, charcoal, helvetica, arial, sans-serif }
     A:visited { color: #333333; font-weight: bold;
                 font-family: MS Sans Serif, verdana, charcoal, helvetica, arial, sans-serif }
     A:name { color: #333333; font-weight: bold;
              font-family: MS Sans Serif, verdana, charcoal, helvetica, arial, sans-serif }
    .link2 { color:#ffffff; font-weight: bold; text-decoration: none;
             font-family: monaco, charcoal, geneva, MS Sans Serif, helvetica, monotype, verdana, sans-serif;
             font-size: 9px }
    .RFC { color:#666666; font-weight: bold; text-decoration: none;
           font-family: monaco, charcoal, geneva, MS Sans Serif, helvetica, monotype, verdana, sans-serif;
           font-size: 9px }
    .hotText { color:#ffffff; font-weight: normal; text-decoration: none;
               font-family: charcoal, monaco, geneva, MS Sans Serif, helvetica, monotype, verdana, sans-serif;
               font-size: 9px }
</style>
</head>
<body bgcolor="#ffffff" text="#000000" alink="#000000" vlink="#666666" link="#990000">
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<table width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table width="100%" border="0" cellpadding="2" cellspacing="1">
<tr valign="top"><td width="33%" bgcolor="#666666" class="header">Gnutella Developer Forum</td><td width="33%" bgcolor="#666666" class="header">S. Daswani</td></tr>
<tr valign="top"><td width="33%" bgcolor="#666666" class="header">&nbsp;</td><td width="33%" bgcolor="#666666" class="header">A. Fisk</td></tr>
<tr valign="top"><td width="33%" bgcolor="#666666" class="header">&nbsp;</td><td width="33%" bgcolor="#666666" class="header">LimeWire LLC</td></tr>
<tr valign="top"><td width="33%" bgcolor="#666666" class="header">&nbsp;</td><td width="33%" bgcolor="#666666" class="header">August 2002</td></tr>
</table></td></tr></table>
<div align="right"><font face="monaco, MS Sans Serif" color="#990000" size="+3"><b><br><span class="title">Gnutella UltraPeer Extension for Scalable Searches (GUESS) v0.01</span></b></font></div>
<font face="verdana, helvetica, arial, sans-serif" size="2">

<h3>Abstract</h3>

<p>
	    "GUESS" is a technique for performing iterative unicast 
		searches of UltraPeers on the Gnutella network, or "UltraPeer 
		crawling."  Shifting from the current broadcast search model 
		to this system can dramatically reduce the 
		overall network bandwidth, CPU, and memory required to support 
		the Gnutella search architecture while providing comparable 
		search results to the old broadcast model.  For rare files, the 
		unicast search model may even provide better results than 
		broadcast.
	  
</p><a name="toc"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<h3>Table of Contents</h3>
<ul compact class="toc">
<b><a href="#intro">1.</a>&nbsp;
Introduction<br></b>
<b><a href="#anchor1">1.1</a>&nbsp;
Purpose<br></b>
<b><a href="#requirements">1.2</a>&nbsp;
Requirements<br></b>
<b><a href="#problems">1.3</a>&nbsp;
Problems with the Current Model<br></b>
<b><a href="#queries">1.3.1</a>&nbsp;
Out of Control Queries<br></b>
<b><a href="#hits">1.3.2</a>&nbsp;
Out of Control Query Hits<br></b>
<b><a href="#anchor2">1.4</a>&nbsp;
Switch to Iterative Unicast, or 'UltraPeer Crawling'<br></b>
<b><a href="#searching_architecture">2.</a>&nbsp;
Searching Architecture<br></b>
<b><a href="#algorithm">2.1</a>&nbsp;
Client<br></b>
<b><a href="#server">2.2</a>&nbsp;
Server<br></b>
<b><a href="#discovery">3.</a>&nbsp;
UltraPeer Discovery<br></b>
<b><a href="#udp">4.</a>&nbsp;
UDP<br></b>
<b><a href="#port">4.1</a>&nbsp;
Open a UDP Port<br></b>
<b><a href="#fragmentation">4.2</a>&nbsp;
Fragmentation<br></b>
<b><a href="#congestion">4.3</a>&nbsp;
Congestion<br></b>
<b><a href="#security">5.</a>&nbsp;
Security Considerations<br></b>
<b><a href="#anchor3">5.1</a>&nbsp;
Distributed Denial of Service (DDOS) Attack<br></b>
<b><a href="#ggep">6.</a>&nbsp;
GGEP Extensions<br></b>
<b><a href="#ggep_pongs">6.1</a>&nbsp;
Advertise UDP port in Pongs<br></b>
<b><a href="#features">7.</a>&nbsp;
Additional Features<br></b>
<b><a href="#cycles">7.1</a>&nbsp;
Cycles No Longer a Concern<br></b>
<b><a href="#push">7.2</a>&nbsp;
Higher Success Rate for Push Downloads<br></b>
<b><a href="#stop">7.3</a>&nbsp;
Stopping Queries Has Meaning<br></b>
<b><a href="#improved_security">7.4</a>&nbsp;
Moderately Improved Security<br></b>
<b><a href="#rfc.references1">&#167;</a>&nbsp;
References<br></b>
<b><a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br></b>
<b><a href="#anchor4">A.</a>&nbsp;
Acknowledgements<br></b>
</ul>
<br clear="all">

<a name="intro"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;Introduction</h3>

<a name="rfc.section.1.1"></a><h4><a name="anchor1">1.1</a>&nbsp;Purpose</h4>

<p>
        The use of broadcast searches with high Time To Live (TTL)s on the 
	    Gnutella network uses a great deal of bandwidth and provides little 
	    control over the propagation of 
		messages.<a href="#refs.RandomWalk" title="Lv, Q., Cao, P., Cohen, E., Li, K. and S. Shenker, Search and Replication in Unstructured Peer-to-Peer Networks, June 2002.">[1]</a>  This document seeks to 
	    alleviate both problems through the use of iterative unicast 
	    searches of Gnutella UltraPeers.<a href="#refs.UltraPeer" title="Rohrs, C. and A. Singla, UltraPeers: Another Step Towards Gnutella Scalability, December 2001.">[2]</a>
	    In this scheme, a client continuously queries UltraPeers with a TTL 
	    of 1 until the desired number of search results is achieved.  Due 
	    to the number of nodes that may be dynamically queried in this model,
	    these messages are sent over UDP in the absence of static TCP 
	    connections.  This proposal is not intended to replace work 
		done in areas such as query 
		meshes.  (See <a href="#refs.QueryMesh" title="Falco, V. and S. Darwin, Query Mesh v0.1, March 2002.">[3]</a> and <a href="#refs.http_mesh_proxy" title="Klingberg, T., Gnutella over HTTP, Query Mesh, Push Proxy, August 2002.">[4]</a>)
		It does not, for example, easily allow existing web servers to 
		be modified to service queries.  Rather, it combines aspects of 
		several powerful ideas from different parties, most notably the 
		importance of carefully controlling query propagation and the 
		potential for queries and replies to be sent over UDP, making 
		such a system feasible.
	  
</p>
<a name="rfc.section.1.2"></a><h4><a name="requirements">1.2</a>&nbsp;Requirements</h4>

<p>The key words “MUST”, “MUST NOT”, “REQUIRED”, 
		“SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, 
		“RECOMMENDED”, “MAY”, and “OPTIONAL” in this 
		document are to be interpreted as described in 
		RFC 2119.<a href="#RFC2119" title="Bradner, S., Key words for use in RFCs to Indicate Requirement Levels, March 1997.">[5]</a>
		An implementation is not compliant if it fails to satisfy one or 
		more of the MUST or REQUIRED level requirements for the protocols 
		it implements. An implementation that satisfies all the MUST or 
		REQUIRED level and all the SHOULD level requirements for its 
		protocols is said to be “unconditionally compliant”; one that 
		satisfies all the MUST level requirements but not all the SHOULD 
		level requirements for its protocols is said to be “conditionally
        compliant.”
</p>
<a name="rfc.section.1.3"></a><h4><a name="problems">1.3</a>&nbsp;Problems with the Current Model</h4>

<p>The current broadcast search model consumes excessive bandwidth 
	    and produces a high load on nodes.  This occurs because: 

	      
<blockquote class="text">
<li>The number of nodes queried per search is uncontrolled.
</li>
<li>Even if the number of nodes queried per search were constant,
		    the number of query hits generated per search would still be 
		    highly variable.
</li>
</blockquote><p>
</p>
<a name="rfc.section.1.3.1"></a><h4><a name="queries">1.3.1</a>&nbsp;Out of Control Queries</h4>

<p>The first problem is a result of the volatile, ad-hoc nature of
		  Gnutella.  Nodes come and go unpredictably, making the connectivity
		  of different parts of the network highly variable, or at least
		  potentially so.  The current query model accounts for this
		  volatility by flooding -- it always takes whatever it can.
		  It does this by:

	        
<blockquote class="text">
<li>Sending queries with high TTLs (typically 7), making the 
		      number of nodes searched unpredictable and dependent upon the 
		      network topology.
</li>
<li>Always forwarding queries to all connected nodes (it floods 
		      whenever the TTL is above 1) regardless of variable conditions.
</li>
</blockquote><p>

	      As a result, searches for common keywords in highly 
		  connected areas of the network have disproportionate impacts 
		  on network load, while searches for less common keywords in
		  less connected areas are not able to reach enough nodes to
		  obtain a satisfactory number of replies.
		  
</p>
<a name="rfc.section.1.3.2"></a><h4><a name="hits">1.3.2</a>&nbsp;Out of Control Query Hits</h4>

<p>While the unpredictable nature of queries presents the first half 
		  of the problem, the unpredictable nature of query hits has a 
		  comparable debilitating effect.  The problem with queries spills 
		  over into hits -- a variable number of nodes queried results 
		  in a variable number of query hits.  The problem is more serious 
		  than this, however.  The number of query hits generated per 
		  search also varies independently because:
	  
	        
<blockquote class="text">
<li>Some searches match a far higher percentage of files than other
		      searches (a search for "txt" produces more results than a search
		      for "The_Gettysburg_Address.txt").
</li>
<li>Some nodes share more files than others, so the query hits 
		      depend not only on the number of nodes queried, but on which
		      nodes queries happen to reach.
</li>
</blockquote><p>

		  With this system, users frequently get more results than they need 
		  for popular content while they have a difficult time finding files
		  that are not as widely distributed.  In either case, queries and query 
		  hits follow the same model where they are allowed to run wild,
		  devouring network resources as they go.
	      
</p>
<a name="rfc.section.1.4"></a><h4><a name="anchor2">1.4</a>&nbsp;Switch to Iterative Unicast, or 'UltraPeer Crawling'</h4>

<p>
	      We propose to alleviate these issues by reducing the TTL to 1 on
		  outgoing queries and by sending queries to one UltraPeer at a time
		  until some desired number of results is received or a limit on
		  the number of UltraPeers queried is reached.  Such a change 
		  grants the client initiating a query substantially more control
		  over the number of nodes the query reaches and over the number of 
		  query hits generated.  As such, it takes a significant step
		  towards solving the primary two problems with the current query
		  model noted above.  It does not eliminate these issues because
		  UltraPeers have varying numbers of leaves, nodes still share
		  varying numbers of files, and some searches will still return
		  far more results from given UltraPeers than others.
		  Nevertheless, this change dramatically mitigates the effects
		  of these problems.
	    
</p>
<a name="searching_architecture"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;Searching Architecture</h3>

<p>
	    In several ways, this scheme is simple and easy to 
		implement.  In particular, the system is completely transparent
		to leaves.  From the leaf perspective, the search system has
		not changed at all.  This simplifies the design and allows 
		any leaves not implementing this proposal to benefit from it
		nevertheless.  From the UltraPeer perspective, implementing this
		proposal on a high level simply means sending out all 
		queries with TTL=1 while querying a much larger set of UltraPeers 
		directly over either TCP or UDP.

		<br>
<br>

		The details of the UltraPeer changes are significant.  UltraPeers 
		must send queries iteratively to known UltraPeers supporting GUESS,
		stopping when enough results are received.  These queries can be
		sent via TCP if there is a TCP connection available.  Otherwise,
		they are sent over UDP.  UltraPeers are also responsible
		for maintaining a full cache of other GUESS UltraPeers to query.  
		On the server side, UltraPeers must listen on a UDP port, and they 
		must send their responses over the same UDP port they are 
		listening on.  Aside from the protocol used when sending or 
		receiving messages, however, the changes are minimal.
		The following sections discuss the details of these changes.  In 
		this discussion, the "client" is the UltraPeer initiating the 
		query, either on its own behalf or on behalf of one of its 
		leaves (most importantly, the "client" is never a leaf -- 
		it is always the UltraPeer).  The "server" is the receiver 
		of the query, which can be either a leaf or an UltraPeer.
		Developers implementing this proposal MUST implement both the 
		client side and the server side.  This means that any developers
		wishing to implement GUESS also MUST implement 
		the <a href="#refs.UltraPeer" title="Rohrs, C. and A. Singla, UltraPeers: Another Step Towards Gnutella Scalability, December 2001.">UltraPeer proposal</a>[2].				
	  
</p>
<a name="rfc.section.2.1"></a><h4><a name="algorithm">2.1</a>&nbsp;Client</h4>

<p>
		UltraPeers send queries to other UltraPeers one by one until 
		one of the following occurs:
		  
<ol class="text">
<li>
			  The desired number of results is received.
			
</li>
<li>
			  The maximum number of UltraPeers is queried.
			
</li>
</ol><p>
		
		To make sure these queries do not flood the network with too
		much traffic, the client MUST pause for a reasonable amount
		of time between each query, perhaps about 200 milliseconds.  This 
		pause accounts for network latency, as it takes a variable 
		amount of time to receive results from an UltraPeer
		and its leaves.  The interval allocates time to receive these
		replies.  During the interval, the desired number of results may
		be reached, making another query unnecessary.  The optimal 
		interval between searches should be determined by 
		experimentation, but implementors MUST send as few queries 
		as possible without degrading user experience and without 
		prohibitively increasing the load on participating 
		UltraPeers. Implementations may also vary the interval 
		between queries depending on how many UltraPeers 
		have already been reached.  For example, the interval may 
		be 400 milliseconds for the first 20 UltraPeers, but then 
		go down to 200 for the next 100, potentially even getting
		smaller after that.  Such an algorithm may make sense 
		because the probability of receiving a reply to a given 
		query likely gets smaller as more UltraPeers are queried
		and the desired number of results is not achieved.  At that
		point, it may make sense to speed up the query to quickly
		reach as many nodes as possible.

		<br>
<br>

		With regard to the desired number of results, 
		implementors have some flexibility, particularly in 
		their technique for determing what they consider "enough"
		results to stop the search.  A simple  
		algorithm would be for the client to continue 
		querying until it has received 100 results or queried 1,000 
		UltraPeers, for example.  An alternative would be for the 
		number of results considered "enough" to decrease as a function
		of the number of UltraPeers searched.  This algorithm would 
		recognize, for example, that if a search has returned no
		results after querying 500 UlraPeers, it is unlikely
		to get very many results from querying the next 500,
		and it may be satisfied as soon as it receives any results
		at all and stop there.  This would reduce the total number
		of UltraPeers required to service queries for rare files.
		The details of these algorithms should also be determined 
		through experimentation by Gnutella developers, again keeping
		in mind that the overall goal is to reduce query and query 
		hit traffic for everyone while maintaining current levels of 
		searchability for common files and improving searchability 
		for rare files.  Clients should also keep in mind that an 
		overly aggressive implementation will ultimately damage 
		their own clients through increasing everyone's overall 
		network load.
		
		<br>
<br>

		When performing this search, there are several rules that
		UltraPeers MUST follow.  These are:
		  
<ol class="text">
<li>
			  Searches MUST NOT be sent to more than 10,000
			  UltraPeers.
			
</li>
<li>
			  Clients MUST NOT seek more than 1,000 results.
			
</li>
<li>
			  Clients MUST NOT query more than 1 UltraPeer every
			  20 milliseconds.  For the first 20 UltraPeers
			  queried, however, clients MUST pause for at least 200 
			  milliseconds between queries.  The query should initially
			  begin slowly as it in effect determines the popularity
			  of the file.
			
</li>
<li>
			  UltraPeers MUST NOT query the same UltraPeer more 
			  than once.  In particular, a node MUST NOT send a 
			  second query to an UltraPeer if it does not receive responses 
			  to the first query (it MUST NOT consider that the datagram 
			  was lost and requery as a result).  If the datagram was,
			  in fact, lost, this indicates high loss around that node,
			  and resending the query will only make the situation worse.
			
</li>
</ol><p>

	    These numbers should be considered the absolute maximum
		values, and they are not the settings developers should use.
		Again, the optimal limits should be determined by 
		experimentation, but the above rules always apply.  Implementors
		should keep in mind that Gnutella is a network that relies on
		the fact that other clients are not overly selfish or
		abusive -- Gnutella relies on trust to a large degree.  
		The reduction in traffic should reduce the bandwidth, CPU, 
		and memory load on all UltraPeers, but this is only possible 
		if developers use conservative values when writing their 
		implementations.
		
</p>
<a name="rfc.section.2.2"></a><h4><a name="server">2.2</a>&nbsp;Server</h4>

<p>
	    The changes on the server side are less significant.  Again,
		no changes are required for leaves.  In fact, leaves SHOULD NOT 
		open UDP ports for incoming traffic, as they never receive UDP
		messages directly.  UltraPeers MUST, however, open a port
		for incoming UDP traffic, and they MUST use the same 
		port that they are using for incoming Gnutella messages 
		over TCP.  The details of this are discussed in 
		the <a href="#udp">section</a> on UDP.
		When a server receives a message over its open UDP
		port, it MUST send any replies via UDP and over the same
		port it is listening on.  As in the current Gnutella 
		network, all replies are sent back to the sender.  This is
		an important point in terms 
		of <a href="#security">security</a>.  Otherwise,
		servers should respond to messages just as if they 
		recieved them over TCP.  Servers SHOULD accept all of the
		traditional Gnutella messages over their UDP port.  These
		messages are defined in 
		the <a href="#refs.clip2" title="Clip2, The Gnutella Protocol Specification v0.4, Document Revision 1.2, .">Gnutella Protocol Specification v0.4</a>[13].
		
		<br>
<br>

		On the server side, UltraPeers also MUST start forwarding 
		TTL=1 queries to leaves.  Without this change, queries would
		have to be sent with TTL=2, which would lessen the fine-grained
		control over the query and would eliminate benefits such as
		no longer needing to concern ourselves 
		with <a href="#cycles">cycles</a>.  The current practice
		of not forwarding TTL=1 queries to leaves also fails to take
		advantage of the powerful UltraPeer infrastructure that 
		can be used more productively. 
		
</p>
<a name="discovery"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;UltraPeer Discovery</h3>

<p>
		  For this scheme to work, all UltraPeers must have the
		  ability to discover other UltraPeers that accept incoming
		  messages over UDP.  In fact, UltraPeer discovery may be one
		  of the most challenging components of this proposal, as
		  UltraPeers do not simply have to discover other UltraPeers -- 
		  they have to discover LOTS of them.  As we will see, the 
		  scheme has UltraPeer discovery built in to some degree. 
		  UltraPeers supporting this proposal MUST advertise this fact
		  using a <a href="#ggep_pongs">GGEP extension</a> in
		  pongs.  There are three techniques for discovering these
		  marked pongs on the network:
		    
<ol class="text">
<li>
			    Through standard Gnutella broadcast pings and pong caching.
			  
</li>
<li>
                Through specialized pings sent over UDP.
			  
</li>
<li>
			    Through the storing of the IP and port of the many queries
				and pings passing through UltraPeers over UDP.
			  
</li>
</ol><p>

		  The last technique is perhaps the most intriguing.  Each UltraPeer
		  crawl may send out queries to 10,000 other nodes.  As a result,
		  UltraPeers will naturally receive large numbers of queries over UDP
		  from other UltraPeers that must be supporting this proposal.  They
		  can simply treat these queries as pongs, and add those UltraPeers 
		  to their cache.  This is made possible because the host sending the
		  query has to be listening on the same port stored in the
		  datagram.  The same is true for any pings received over UDP.  
		  While these incoming messages will only supply the IP address and 
		  port of hosts supporting GUESS without the additional data 
		  contained in normal pongs, the IP address and port are really all 
		  that are necessary for our purposes.  This built-in distribution 
		  of host information can dramatically reduce the need for 
		  any pings and pongs at all -- so much so that UltraPeers 
		  MUST store the IP and port from all UDP messages they receive.
		  Similarly, GUESS UltraPeers MUST include these pongs when
		  appropriate in response to UDP pings.

		  <br>
<br>

		  The other specialized technique for UltraPeer discovery is the
		  use of the normal Gnutella ping, only over UDP.  When UltraPeers
		  receive pings over UDP, they should take special action.  Instead 
		  of returning the normal pongs, UltraPeers are REQUIRED to send 
		  pongs from other UltraPeers with 
		  the <a href="#ggep_pongs">GGEP extension</a> marking 
		  support for GUESS.  They SHOULD send some moderate number of these
		  UltraPeer pongs, somewhere in the range of about 5-20.  Given
		  that GUESS UltraPeer discovery is one of the more difficult 
		  aspects of the proposal, the optimal number of pongs to send 
		  should be determined by experimentation.  UltraPeers MUST NOT
		  include a pong for themselves in the returned set, as the
		  pinging UltraPeer already knows about the UltraPeers it pings.
		  This technique allows nodes to discover UltraPeers outside the
		  network horizon of normal broadcast pings.

		  <br>
<br>

		  Using these techniques, UltraPeers also MUST maintain
		  a full cache of other UltraPeers to query.  
		  Because leaves always query the network via their
		  UltraPeer, leaves do not have to maintain any of this 
		  information -- this is the UltraPeer's 
		  responsibility.  If an UltraPeer's cache of other GUESS-supporting 
		  UltraPeers drops below a certain threshold, for example 5,000,
		  the UltraPeer MUST use these techniques to refresh its 
		  UltraPeer cache.  While UltraPeers MUST maintain an adequate 
		  cache of other UltraPeers to query, they also MUST send a minimum
		  number of pings to make this possible, less the network
		  become flooded with ping and pong traffic.
		
</p>
<a name="udp"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;UDP</h3>

<p>
	      In this scheme, clients must dynamically query a 
	      potentially high number of UltraPeers directly for each 
		  search.  In the current Gnutella network, all messages are
		  sent using TCP, so the most obvious implementation of this
		  proposal would use a new, transient connection also over TCP.  
		  Opening and closing TCP connections incurs significant CPU 
		  and memory costs, however, potentially making the proposed
		  change unworkable.  Moreover, Windows 95/98/Me do not allow 
		  more than 100 TCP connections.  While this setting can be 
		  changed in the registry, these systems were clearly not designed 
		  to handle high numbers of simultaneous connections.  As opposed 
		  to UDP, TCP also uses significantly more bandwidth and increases 
		  delay.  As others have noted, however, the reliability of TCP 
		  is not a requirement for Gnutella queries and 
		  hits.<a href="#refs.agthorr" title="Agthorr, D., Re: GGEP 0.31 comments, January 2002.">[6]</a>  If a message is lost, 
		  who cares?  In fact, these queries and their associated replies 
		  can easily be sent over UDP.  In many ways, UDP is the more 
		  appropriate transport layer protocol, as this scheme sends a 
		  large number of messages to an amorphous group of nodes
		  very quickly, and reliability is not a requirement.  In fact, 
		  with the high transience of Gnutella nodes, reliability cannot
		  be expected and is undesirable.  Clients wishing to implement 
		  this change MUST do so over UDP, as a TCP implementation would 
		  incur excessive overhead for other nodes, and would be 
		  impossible without a new, transient connection.  If a TCP
		  connection already exists, UltraPeers MUST send messages
		  just as if the connection were over UDP, using TTL=1
		  in particular.
	    
</p>
<a name="rfc.section.4.1"></a><h4><a name="port">4.1</a>&nbsp;Open a UDP Port</h4>

<p>
		    To implement this change, UltraPeers MUST open a UDP
			port that listens for incoming UDP traffic, as mentioned
			in the section on server-side changes.  It is
			RECOMMENDED that UltraPeers listen on port 6346, the 
			same port registered for Gnutella for TCP.
			UltraPeers MAY, however, listen 
			on a different port, particularly when, for example,
			there is another Gnutella client listening on 6346,
			or when another application is using that port for
			any reason.  In all cases, clients MUST
			listen on the same port for both TCP and UDP traffic.
			While this makes the implementation slightly more
			rigid, the IP and TCP port are already reported in a
			number of Gnutella messages, headers, and extensions, 
			however, and this choice makes the reuse of that 
			information possible.  
		  
</p>
<a name="rfc.section.4.2"></a><h4><a name="fragmentation">4.2</a>&nbsp;Fragmentation</h4>

<p>
		    One difference between UDP and TCP is that UDP does 
			not perform any segmenting of datagrams on its own:
			it sends a single datagram that may be split into
			multiple packets at the IP layer, either at the 
			originating host or at an intermediate router.  
			This fragmentation depends upon the 
			Maximum Transmission Unit (MTU) of the underlying
			link-layer.<a href="#refs.TCPIP" title="Stevens, R., The Protocols (TCP/IP Illustrated, Volume 1), January 1994.">[7]</a><br>
<br>

			Fragmentation of datagrams in itself is far from
			disastrous.  The IP layer reassembles packets into 
			complete datagrams at the destination host, making
			the process largely transparent to application 
			developers.  The danger lies, however, in the 
			possibility that individual packets are lost.  If 
			any fragment is lost, the entire datagram 
			is lost.<a href="#refs.TCPIP" title="Stevens, R., The Protocols (TCP/IP Illustrated, Volume 1), January 1994.">[7]</a>  It is
			therefore RECOMMENDED that clients take steps
			to minimize the size of their datagrams to avoid
			excessive fragmentation.  The MTU of modem links
			can be prohibitively small, as low as 296 bytes,
			so we make no attempt to remain below this 
			threshold.<a href="#RFC1191" title="Mogul, J. and S. Deering, Path MTU discovery, November 1990.">[8]</a>  These links
			should only occur on the edges of the network,
			however, as long as UltraPeer election algorithms are 
			correctly measuring bandwidth.  This means that any
			fragmentation that may occur along modem links will
			likely result in little to no packet loss, so we
			need not consider this barrier when determing
			datagram sizes.  In general, clients SHOULD limit the
			size of their datagrams whenever appropriate.  A limit
			of 512 is very conservative, and limiting datagrams 
			to 1,500 bytes or less should avoid fragmentation on
			the vast majority of 
			routers.<a href="#RFC1191" title="Mogul, J. and S. Deering, Path MTU discovery, November 1990.">[8]</a>  This is because 
			1,500 bytes is the MTU for Ethernet links, which most
			TCP/IP stacks take into account.
			
			<br>
<br>
	
			This will often not be possible for query hits.  
			To address this problem, it is RECOMMENDED that 
			developers break up large query hits into multiple smaller 
			query hits.  This will increase the bandwidth required 
			to return results only slightly (due to sending the same 
			header multiple times) while reducing or eliminating fragmentation.
			It also avoids the current "all or nothing" approach where all 
			results from a host are lost if one packet is lost.  In this 
			scheme, some hits can still get through when a packet 
			from another hit is lost.
		  
</p>
<a name="rfc.section.4.3"></a><h4><a name="congestion">4.3</a>&nbsp;Congestion</h4>

<p>
		    Another significant difference between TCP and UDP
			is that UDP does not provide congestion control.
			Given that this query scheme dramatically reduces
			overall message traffic, congestion may not be a 
			concern.  Particularly because clients will no longer receive
			the floods of query hits currently associated with 
			queries for popular content (probably the most severe 
			case of congestion on the current network), packet loss
			rates under this scheme should be significantly lower. 
			If congestion does prove to cause a 
			high degree of packet loss, however, clients
			may be forced to implement congestion control
			at the application layer.  The architecture for
			such a scheme is beyond the scope of this
			proposal.
		  
</p>
<a name="security"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;Security Considerations</h3>

<a name="rfc.section.5.1"></a><h4><a name="anchor3">5.1</a>&nbsp;Distributed Denial of Service (DDOS) Attack</h4>

<p>
			In the past, a principal objection to using UDP has been
			that it allows anyone to easily execute a DDOS attack
			on any target machine.  This concern has been based on the
			assumption that queries would require an extension listing
			the IP address and UDP port to reply to, however.  In this
			proposal, this extension is not required, as responses are
			always sent directly back to the node that sent them, 
			rendering such an attack impossible.
	      
</p>
<a name="ggep"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;GGEP Extensions</h3>

<a name="rfc.section.6.1"></a><h4><a name="ggep_pongs">6.1</a>&nbsp;Advertise UDP port in Pongs</h4>

<p>
		    UltraPeers that are capable of receiving Gnutella 
			messages over UDP MUST advertise that fact in a
			new GGEP extension in 
			pongs.<a href="#refs.GGEP" title="Thomas, J., Gnutella Generic Extension Protocol (GGEP) v0.51, Fedruary 2002.">[9]</a>
            The GGEP extension should have the value "UDP" as its
			extension header.  The extension value should be the version
			number of the protocol supported - for example, this is
			version .01.  The version number in the GGEP block should the
			version number support multiplied by 10 (i.e. .01 would have 1,
			2.4 would have 24, etc.).  This will allow for potential
			feature specific use in the future.
		  
</p>
<a name="features"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;Additional Features</h3>

<a name="rfc.section.7.1"></a><h4><a name="cycles">7.1</a>&nbsp;Cycles No Longer a Concern</h4>

<p>
	      Adoption of this proposal has several additional benefits.  For 
		  example, concern for cycles in intra-UltraPeer connections is 
		  eliminated.  In the current network, cycles can be a serious 
		  problem in the worst case.  As a general, the number of cycles 
		  increases as the connectivity of the network graph increases.
		  This is highly problematic because there are significant benefits
		  to having a more highly connected graph.  These cycles result in 
		  nodes receiving many duplicate messages, wasting bandwidth, CPU, and 
		  memory.(See <a href="#refs.RandomWalk" title="Lv, Q., Cao, P., Cohen, E., Li, K. and S. Shenker, Search and Replication in Unstructured Peer-to-Peer Networks, June 2002.">[1]</a> and <a href="#refs.tutorial" title="Berk and Cybenko, File Sharing Protocols: A Tutorial on Gnutella, March 2001.">[11]</a>
		  This eliminates
		  these duplicates except in the case where leaves are connected to 
		  multiple UltraPeers, and two or more of their UltraPeers are sent
		  the same query.
	    
</p>
<a name="rfc.section.7.2"></a><h4><a name="push">7.2</a>&nbsp;Higher Success Rate for Push Downloads</h4>

<p>
		  This query scheme gracefully handles push downloads.  In
		  fact, it incorporates many of the ideas of the 
		  Push Proxy proposal.<a href="#refs.push_proxy" title="Thomas, J., Push Proxy v0.1, August 2002.">[12]</a>
		  This scheme does not, however, allow two firewalled hosts
		  to download from each other, as in the "Download Proxy"
		  proposal.<a href="#refs.download_proxy" title="Thomas, J., Download Proxy v0.1, January 2002.">[10]</a>  In the current
		  network, push requests frequently fail, primarily because
		  the node serving the file may be 7 hops away from the node
		  requesting a file, and the request has to travel through
		  all intervening nodes.  As a result, if any node along that
		  path leaves the network, the push will not go through.
		  With the adoption of this proposal, success rates for 
		  push request should increase dramatically, as the node 
		  serving the file will only be from 2 to 3 hops away 
		  (depending on whether the node serving the file is
		  a leaf or an UltraPeer).
		
</p>
<a name="rfc.section.7.3"></a><h4><a name="stop">7.3</a>&nbsp;Stopping Queries Has Meaning</h4>

<p>
		  Another benefit of this scheme is that the user manually "stopping"
		  a query can, in fact, stop that query from being sent to more
		  hosts, saving network resources.
		
</p>
<a name="rfc.section.7.4"></a><h4><a name="improved_security">7.4</a>&nbsp;Moderately Improved Security</h4>

<p>
		  GUESS has the added benefit that it makes the most obvious 
		  DDOS attack on Gnutella less feasible.  In such an attack, a
		  single attacker can connect to a large number of hosts simultaneously
		  and send out repeated queries for popular content with a high TTL.  
		  Given current flow control algorithms, relatively few attackers could
		  likely have a rapid and dramatic negative impact on overall network
		  performance.  While attackers can still connect to many UltraPeers
		  in this scheme, the effective elimination of TTL in GUESS means that
		  an attacker would have to use far more bandwidth to achieve the
		  same effect.
		  <br>
<br>

		  In addition, GUESS makes Gnutella application-level 
		  "man in the middle" attacks more difficult.
		  With GUESS, there are fewer nodes between the sender and the
		  receiver, so each message will pass through far fewer nodes along
		  its path to the recipient.  So, while this by no means eliminates the 
		  ability to view and/or alter messages on the path to the recipient,
		  it makes it slightly more difficult.
		
</p>
<a name="rfc.references1"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<h3>References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><b><a name="refs.RandomWalk">[1]</a></b></td>
<td class="author-text"><a href="mailto:qlv@cs.princeton.edu">Lv, Q.</a>, <a href="mailto:cao@cisco.com">Cao, P.</a>, <a href="mailto:edith@research.att.com">Cohen, E.</a>, <a href="mailto:li@cs.princeton.edu">Li, K.</a> and <a href="mailto:shenker@icsi.berkeley.edu">S. Shenker</a>, "<a href="http://www.cs.princeton.edu/~qlv/download/searchp2p_full.pdf">Search and Replication in Unstructured Peer-to-Peer Networks</a>", June 2002.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.UltraPeer">[2]</a></b></td>
<td class="author-text"><a href="http://www.limewire.org">Rohrs, C.</a> and <a href="http://www.limewire.org">A. Singla</a>, "<a href="http://groups.yahoo.com/group/the_gdf/files/Proposals/Ultrapeer/Ultrapeers_proper_format.html">UltraPeers: Another Step Towards Gnutella Scalability</a>", December 2001.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.QueryMesh">[3]</a></b></td>
<td class="author-text"><a href="http://www.freepeers.com">Falco, V.</a> and <a href="http://www.freepeers.com">S. Darwin</a>, "<a href="http://groups.yahoo.com/group/the_gdf/files/Proposals/querymesh.txt">Query Mesh v0.1</a>", March 2002.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.http_mesh_proxy">[4]</a></b></td>
<td class="author-text"><a href="http://www.freepeers.com">Klingberg, T.</a>, "<a href="http://groups.yahoo.com/group/the_gdf/message/9533">Gnutella over HTTP, Query Mesh, Push Proxy</a>", August 2002.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="RFC2119">[5]</a></b></td>
<td class="author-text"><a href="mailto:-">Bradner, S.</a>, "<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.agthorr">[6]</a></b></td>
<td class="author-text">Agthorr, D., "<a href="http://groups.yahoo.com/group/the_gdf/message/4492">Re: GGEP 0.31 comments</a>", January 2002.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.TCPIP">[7]</a></b></td>
<td class="author-text">Stevens, R., "<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0201633469/qid=1029899071/sr=8-1/ref=sr_8_1/002-2563381-7557664?s=books&n=507846">The Protocols (TCP/IP Illustrated, Volume 1)</a>", January 1994.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="RFC1191">[8]</a></b></td>
<td class="author-text"><a href="mailto:mogul@decwrl.dec.com">Mogul, J.</a> and <a href="mailto:deering@xerox.com">S. Deering</a>, "<a href="ftp://ftp.isi.edu/in-notes/rfc1191.txt">Path MTU discovery</a>", RFC 1191, November 1990.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.GGEP">[9]</a></b></td>
<td class="author-text"><a href="mailto:jason@jasonthomas.com">Thomas, J.</a>, "<a href="http://groups.yahoo.com/group/the_gdf/files/Proposals/GGEP/GnutellaGenericExtensionProtocol.0.51.html">Gnutella Generic Extension Protocol (GGEP) v0.51</a>", Fedruary 2002.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.download_proxy">[10]</a></b></td>
<td class="author-text"><a href="mailto:jason@jasonthomas.com">Thomas, J.</a>, "<a href="http://groups.yahoo.com/group/the_gdf/files/Proposals/Download%20Proxy/Download%20Proxy.html">Download Proxy v0.1</a>", January 2002.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.tutorial">[11]</a></b></td>
<td class="author-text">Berk and Cybenko, "<a href="http://www.ists.dartmouth.edu/IRIA/knowledge_base/p2p/p2p.pdf">File Sharing Protocols: A Tutorial on Gnutella</a>", March 2001.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.push_proxy">[12]</a></b></td>
<td class="author-text"><a href="mailto:jason@jasonthomas.com">Thomas, J.</a>, "<a href="http://groups.yahoo.com/group/the_gdf/message/9317">Push Proxy v0.1</a>", August 2002.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="refs.clip2">[13]</a></b></td>
<td class="author-text">Clip2, "<a href="http://www.clip2.com/GnutellaProtocol04.pdf">The Gnutella Protocol Specification v0.4, Document Revision 1.2</a>".</td></tr>
</table>

<a name="rfc.authors"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Susheel Daswani</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">LimeWire LLC</td></tr>
<tr><td class="author" align="right">EMail:&nbsp;</td>
<td class="author-text"><a href="mailto:sdaswani@limewire.com">sdaswani@limewire.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.limewire.org">http://www.limewire.org</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Adam A. Fisk</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">LimeWire LLC</td></tr>
<tr><td class="author" align="right">EMail:&nbsp;</td>
<td class="author-text"><a href="mailto:afisk@limewire.com">afisk@limewire.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.limewire.org">http://www.limewire.org</a></td></tr>
</table>

<a name="anchor4"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;Acknowledgements</h3>

<p>
	    The authors would like to thank Christopher Rohrs and the rest of the 
		LimeWire team.  In addition, we would like to thank Gordon Mohr of Bitzi,
		Inc., Jakob Eriksson, Ph.D. student at the Computer Science department at
		the University of California, Riverside, all participants in the 
		Gnutella Developer Forum (GDF), and all members of the LimeWire open 
		source initiative.
	  
</p></font></body></html>

